<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="何政韩的博客">
<meta property="og:url" content="http://zhenghanho.github.io/page/2/index.html">
<meta property="og:site_name" content="何政韩的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="何政韩的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zhenghanho.github.io/page/2/"/>





  <title>何政韩的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">何政韩的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Thinking outside the box</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhenghanho.github.io/2018/09/10/e6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-e4-b9-8b-e5-bd-92-e5-b9-b6-e6-8e-92-e5-ba-8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhenghan He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何政韩的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/e6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-e4-b9-8b-e5-bd-92-e5-b9-b6-e6-8e-92-e5-ba-8f/" itemprop="url">排序算法之归并排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T05:08:14-04:00">
                2018-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/排序算法/" itemprop="url" rel="index">
                    <span itemprop="name">排序算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>归并排序是分治的典型例子(divide-conquer)。总体的步骤为采用分的思想，将问题小化递归求解（分的阶段），然后将小化后的子问题合并得到最终大问题的解。对于排序而言，若细化为两个只有一个数字的数列时对齐合并处理可以很简单地得到有序的数列，归并排序运用的就是这种思想。</p>
<h2 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h2><p>整体设计上，算法主要包括分与治这两个过程，</p>
<h2 id="分的设计："><a href="#分的设计：" class="headerlink" title="分的设计："></a>分的设计：</h2><p>分是递归地解决问题，所以要充分考虑好参数的问题。 参数1：为了节省空间，不会在递归的函数中为分产生的数组分配新的空间，故分的数组是基于原数组空间的，所以需要一个参数为原数组的地址。 参数2与3：另外分主要依靠的是待分数组的左起点和右终点，同时这两个参数也可作为递归终止条件的判断。（这里顺便聊一下递归终止条件的书写，为了使递归有出口，终止条件应当尽量严格，比如在可以写right &lt;= left 和 right == left 的情况下，前者更好，这里相当于偷了个懒，因为不确定分到最后right和left的具体情况） 参数4：考虑到合的过程中需要将结果临时存在一个辅助数组里再赋值到原数组中，故在这里设置一个已经分配好空间的数组指针作为参数。 分析好参数之后，递归就按照宏观思想来写就可以了。即先写终止条件，然后写递归体。</p>
<h2 id="治的设计："><a href="#治的设计：" class="headerlink" title="治的设计："></a>治的设计：</h2><p>合并数组变得相对简单了。因为合并是在一个数组中的前后两部分进行，所以只需要知道开始点，中点，结束点就可以了。注意，因为采用了递归的设计，最终的结果应当保留到原数组中覆盖之前的结果，别只留在临时数组里。 具体代码如下： （这里为了调用方便包装了一下，所以其实两个函数是够了的）</p>
<p>class solution {<br>    public void merge(int[] a, int left, int mid, int right, int[] b) {<br>        int i = left, j = mid + 1, k = 0;<br>        while (i &lt;= mid &amp;&amp; j &lt;= right) {<br>            if (a[i] &lt; a[j]) {<br>                b[k++] = a[i++];<br>            } else {<br>                b[k++] = a[j++];<br>            }<br>        }<br>        while (i &lt;= mid) {<br>            b[k++] = a[i++];<br>        }<br>        while (j &lt;= right) {<br>            b[k++] = a[j++];<br>        }<br>        k = 0;<br>        while(left &lt;= right){<br>            a[left++] = b[k++];<br>        }<br>    }</p>
<pre><code>public int\[\] merge_sort(int\[\] input) {
    if(input.length == 1){
        return input;
    }
    int\[\] result = new int\[input.length\];
    sort(input, 0, input.length - 1, result);
    return result;
}

private void sort(int\[\] input, int left, int right, int\[\] result) {
    if (left &lt; right) {
        int mid = (right + left) / 2;
        sort(input, left, mid, result);
        sort(input, mid+1, right, result);
        merge(input, left, mid, right, result);
    }

}
</code></pre><p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhenghanho.github.io/2018/08/30/leetcode329-longest-increasing-path-in-a-matrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhenghan He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何政韩的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/30/leetcode329-longest-increasing-path-in-a-matrix/" itemprop="url">Leetcode(329) Longest Increasing Path in a Matrix</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-30T04:25:41-04:00">
                2018-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode刷题笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode刷题笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><p>Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). <strong>Example 1:</strong></p>
<p>Input: nums =<br>[<br>  [9,9,4],<br>  [6,6,8],<br>  [2,1,1]<br>]<br>Output: 4<br>Explanation: The longest increasing path is [1, 2, 6, 9].</p>
<p><strong>Example 2:</strong></p>
<p>Input: nums =<br>[<br>  [3,4,5],<br>  [3,2,6],<br>  [2,2,1]<br>]<br>Output: 4<br>Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>
<h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><p>首先自然而然地想到了对于每一个点采用深度优先的搜索算法，得到以该点为起点的最长路径，然而在这个过程中，其实存在重复搜索的问题而影响了程序的效率。代码跑出来果然超时了。以下为DFS代码：</p>
<p>public class Solution {<br>    public int longestIncreasingPath(int[][] matrix) {<br>        if (matrix.length == 0) {<br>            return 0;<br>        }<br>        int row = matrix.length;<br>        int col = matrix[0].length;<br>        int max = 0;<br>        for (int i = 0; i &lt; row; i++) {<br>            for (int j = 0; j &lt; col; j++) {<br>                int cnt = dfs(i, j, matrix, row, col);<br>                if (cnt &gt; max) {<br>                    max = cnt;<br>                }<br>            }<br>        }<br>        return max;<br>    }</p>
<pre><code>private int dfs(int i, int j, int\[\]\[\] matrix, int row, int col) {
    Stack s = new Stack();
    node start = new node(i, j, matrix\[i\]\[j\],1);
    s.push(start);
    node now = start;
    int\[\]\[\] direction = { {-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    int cnt = 0;
    while (!s.isEmpty()) {
        now = (node) s.pop();
        int flag = 0;
        for (int ii = 0; ii &lt; 4; ii++) {
            node next = new node(now.i+ direction\[ii\]\[0\], now.j + direction\[ii\]\[1\], -1,1);
            if (isvalid(next, row, col) &amp;&amp; matrix\[next.i\]\[next.j\] &gt; now.value) {
                next.value = matrix\[next.i\]\[next.j\];
                next.step = now.step + 1;
                s.push(next);
                flag = 1;
            }
        }
        if(flag == 0){
            if(now.step &gt; cnt){
                cnt = now.step;
            }
        }
    }
    return cnt;
}

private boolean isvalid(node n, int row, int col) {
    if (n.i &gt;= 0 &amp;&amp; n.i &lt; row &amp;&amp; n.j &gt;= 0 &amp;&amp; n.j &lt; col ) {
        return true;
    }
    return false;
}
</code></pre><p>}</p>
<p>class node {<br>    int i;<br>    int j;<br>    int value;<br>    int step = 1;</p>
<pre><code>node(int i, int j, int value,int step) {
    this.i = i;
    this.j = j;
    this.value = value;
    this.step = step;
}
</code></pre><p>}</p>
<p>  为解决重复搜索问题，引入动态规划思想，以空间换时间。引入记忆矩阵，改写DFS搜索方法，采用递归的方式进行搜索。代码如下：</p>
<p>public class Solution {<br>    public int longestIncreasingPath(int[][] matrix) {<br>        if (matrix.length == 0) {<br>            return 0;<br>        }<br>        int row = matrix.length;<br>        int col = matrix[0].length;<br>        int memory[][] = new int[row][col];<br>        int max = 0;<br>        for (int i = 0; i &lt; row; i++) {<br>            for (int j = 0; j &lt; col; j++) {<br>                int cnt = dfs(i, j, matrix, row, col,memory);<br>                if (cnt &gt; max) {<br>                    max = cnt;<br>                }<br>            }<br>        }<br>        return max;<br>    }</p>
<pre><code>private int dfs(int i, int j, int\[\]\[\] matrix, int row, int col,int\[\]\[\] memory) {
    int maxstep = 1;
    if(memory\[i\]\[j\]&gt;0){
        return memory\[i\]\[j\];
    }
    node now = new node(i,j,matrix\[i\]\[j\],0);
    int\[\]\[\] direction = { {-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    for (int ii = 0; ii &lt; 4; ii++){
        node next = new node(now.i+ direction\[ii\]\[0\], now.j + direction\[ii\]\[1\], -1,1);
        if (isvalid(next, row, col) &amp;&amp; matrix\[next.i\]\[next.j\] &gt; now.value){
            next.value = matrix\[next.i\]\[next.j\];
            int cal = dfs(next.i,next.j,matrix,row,col,memory) + 1;
            if(maxstep &lt; cal){
                maxstep = cal;
            }
        }
    }
    memory\[i\]\[j\] = maxstep;
    return memory\[i\]\[j\];
}

private boolean isvalid(node n, int row, int col) {
    if (n.i &gt;= 0 &amp;&amp; n.i &lt; row &amp;&amp; n.j &gt;= 0 &amp;&amp; n.j &lt; col ) {
        return true;
    }
    return false;
}
</code></pre><p>}</p>
<p>class node {<br>    int i;<br>    int j;<br>    int value;<br>    int step = 1;</p>
<pre><code>node(int i, int j, int value,int step) {
    this.i = i;
    this.j = j;
    this.value = value;
    this.step = step;
}
</code></pre><p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhenghanho.github.io/2018/07/28/leetcode173-binary-search-tree-iterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhenghan He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何政韩的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/leetcode173-binary-search-tree-iterator/" itemprop="url">Leetcode(173) Binary Search Tree Iterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-28T14:18:32-04:00">
                2018-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode刷题笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode刷题笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling <code>next()</code> will return the next smallest number in the BST. <strong>Note: </strong><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(_h_) memory, where _h_ is the height of the tree.</p>
<h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><p>首先来复习一下二叉搜索树的概念。二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 这样一来，相当于给一棵搜索树，按从小到大的顺序输出排序结果。由搜索树的性质可知，采用二叉树的中序遍历可以得到该序列。借助栈的帮助可以完成遍历。具体代码如下：</p>
<p>public class BSTIterator {<br>    private Stack<treenode> s = new Stack<treenode>();</treenode></treenode></p>
<pre><code>public BSTIterator(TreeNode root) {
    TreeNode cur = root;
    while (cur != null) {
        s.push(cur);
        cur = cur.left;
    }
}

/\*\*
 \* @return whether we have a next smallest number
 */
public boolean hasNext() {
    if (!s.empty()) {
        return true;
    }
    return false;
}

/\*\*
 \* @return the next smallest number
 */
public int next() {
    TreeNode cur = s.pop();
    int result = cur.val;
    cur = cur.right;
    while (cur != null) {
        s.push(cur);
        cur = cur.left;
    }
    return result;
}
</code></pre><p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhenghanho.github.io/2018/07/27/leetcode401-binary-watch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhenghan He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何政韩的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/27/leetcode401-binary-watch/" itemprop="url">Leetcode(401) Binary Watch</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-27T14:50:01-04:00">
                2018-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode刷题笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode刷题笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><p>A binary watch has 4 LEDs on the top which represent the <strong>hours</strong> (<strong>0-11</strong>), and the 6 LEDs on the bottom represent the <strong>minutes</strong> (<strong>0-59</strong>). Each LED represents a zero or one, with the least significant bit on the right. <img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt="">For example, the above binary watch reads “3:25”. Given a non-negative integer _n_ which represents the number of LEDs that are currently on, return all possible times the watch could represent. <strong>Example:</strong></p>
<p>Input: n = 1<br>Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]</p>
<p><strong>Note:</strong></p>
<ul>
<li>The order of output does not matter.</li>
<li>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</li>
<li>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</li>
</ul>
<h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><p>这是我在Easy上花的时间最久的一道题。解法采用回溯法，即深度优先搜索，设计一个数组模拟10个小灯泡，初始为全0的状态，每次从头到尾找一个为0的点，置1点亮，继续进行下一层的搜索，搜索终止条件为需要点亮的灯泡数为0。注意回溯的精髓在于在搜索完成或失败的回退处理，具体来说，就是在递归调用之后需将状态还原。实现过程中还利用对称性进行了剪枝。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">​    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>\[\] led = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">            dfs(num, led);</span><br><span class="line">            List&lt;String&gt; tmpresult = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String s :</span><br><span class="line">                    result) &#123;</span><br><span class="line">                String\[\] tmp = s.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">int</span> hours = Integer.parseInt(tmp\[<span class="number">0</span>\]);</span><br><span class="line">                <span class="keyword">int</span> minute = Integer.parseInt(tmp\[<span class="number">1</span>\]);</span><br><span class="line">                <span class="keyword">if</span> (minute &gt;= <span class="number">60</span> || hours &gt;= <span class="number">12</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String h = Integer.toString(hours);</span><br><span class="line">                String m = Integer.toString(minute);</span><br><span class="line">                <span class="keyword">if</span> (minute &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                    m = <span class="string">'0'</span> + m;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!tmpresult.contains(h + <span class="string">":"</span> + m)) &#123;</span><br><span class="line">                    tmpresult.add(h + <span class="string">":"</span> + m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = tmpresult;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(<span class="number">10</span> - num, led);</span><br><span class="line">            List&lt;String&gt; tmpresult = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String s :</span><br><span class="line">                    result) &#123;</span><br><span class="line">                String\[\] tmp = s.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">int</span> hours = Integer.parseInt(tmp\[<span class="number">0</span>\]);</span><br><span class="line">                <span class="keyword">int</span> minute = Integer.parseInt(tmp\[<span class="number">1</span>\]);</span><br><span class="line">                hours = <span class="number">15</span> - hours;</span><br><span class="line">                minute = <span class="number">63</span> - minute;</span><br><span class="line">                <span class="keyword">if</span> (minute &gt;= <span class="number">60</span> || hours &gt;= <span class="number">12</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String h = Integer.toString(hours);</span><br><span class="line">                String m = Integer.toString(minute);</span><br><span class="line">                <span class="keyword">if</span> (minute &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                    m = <span class="string">'0'</span> + m;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!tmpresult.contains(h + <span class="string">":"</span> + m)) &#123;</span><br><span class="line">                    tmpresult.add(h + <span class="string">":"</span> + m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = tmpresult;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span>\[\] led)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> hour = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> minute = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                    hour = (<span class="keyword">int</span>) (hour + led\[i\] * Math.pow(<span class="number">2</span>, i));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    minute = (<span class="keyword">int</span>) (minute + led\[i\] * Math.pow(<span class="number">2</span>, i - <span class="number">4</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String h = Integer.toString(hour);</span><br><span class="line">            String m = Integer.toString(minute);</span><br><span class="line">            <span class="keyword">if</span> (minute &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                m = <span class="string">'0'</span> + m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!result.contains(h + <span class="string">":"</span> + m)) &#123;</span><br><span class="line">                result.add(h + <span class="string">":"</span> + m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (led\[i\] == <span class="number">0</span>) &#123;</span><br><span class="line">                led\[i\] = <span class="number">1</span>;</span><br><span class="line">                dfs(num - <span class="number">1</span>, led);</span><br><span class="line">                led\[i\] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhenghanho.github.io/2018/07/25/leetcode103-binary-tree-zigzag-level-order-traversal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhenghan He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何政韩的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/leetcode103-binary-tree-zigzag-level-order-traversal/" itemprop="url">Leetcode(103) Binary Tree Zigzag Level Order Traversal</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T15:21:16-04:00">
                2018-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode刷题笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode刷题笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>3
</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7</p>
<p>return its zigzag level order traversal as:</p>
<p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
<h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><p>这道题需要仔细一点，虽然思路很简单，但是有点绕。要实现之字形走位，因为相邻行的方向不同，考虑使用两个栈进行操作，并且两个栈的进栈顺序也不同，一个先进右节点，一个先进左节点，具体代码如下：</p>
<p>class Solution {<br>    public List&lt;List<integer>&gt; zigzagLevelOrder(TreeNode root) {<br>        List&lt;List<integer>&gt; result = new LinkedList&lt;List<integer>&gt;();<br>        if (root == null) {<br>            return result;<br>        }<br>        Stack<treenode> s1 = new Stack<treenode>();<br>        Stack<treenode> s2 = new Stack<treenode>();<br>        s1.push(root);<br>        while (!s1.empty() || !s2.empty()) {<br>            if (s2.empty()) {<br>                List<integer> tmp = new ArrayList<integer>();<br>                while (!s1.empty()) {<br>                    TreeNode now = s1.pop();<br>                    if (now.left != null) {<br>                        s2.push(now.left);<br>                    }<br>                    if (now.right != null) {<br>                        s2.push(now.right);<br>                    }<br>                    tmp.add(now.val);<br>                }<br>                result.add(tmp);<br>            } else {<br>                List<integer> tmp = new ArrayList<integer>();<br>                while (!s2.empty()) {<br>                    TreeNode now = s2.pop();<br>                    if (now.right != null) {<br>                        s1.push(now.right);<br>                    }<br>                    if (now.left != null) {<br>                        s1.push(now.left);<br>                    }<br>                    tmp.add(now.val);<br>                }<br>                result.add(tmp);<br>            }<br>        }<br>        return result;<br>    }<br>}</integer></integer></integer></integer></treenode></treenode></treenode></treenode></integer></integer></integer></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhenghanho.github.io/2018/07/22/leetcode61-rotate-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhenghan He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何政韩的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/22/leetcode61-rotate-list/" itemprop="url">Leetcode(61) Rotate List</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T15:48:44-04:00">
                2018-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode刷题笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode刷题笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><p>Given a linked list, rotate the list to the right by _k_ places, where _k_ is non-negative. Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Explanation: rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4 Output: 2-&gt;0-&gt;1-&gt;NULL Explanation: rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</p>
<h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><p>考虑到是移动链表题，而单向链表不太好进行回退操作，故考虑将其先变为循环链表，然后根据原链表的长度与移动的次数确定在哪个位置进行断开和指定谁为右移后的头指针。经过分析可得，从原始链表头指针往后走n-  1 - k % n个节点就到达新链表的头结点前一个点（n为链表长度）。具体实现代码如下：</p>
<p>class Solution {<br>    public ListNode rotateRight(ListNode head, int k) {<br>        if (head == null || k == 0) {<br>            return head;<br>        }<br>        int count = 0;<br>        ListNode tmp = head;<br>        while (tmp.next != null) {<br>            tmp = tmp.next;<br>            count++;<br>        }<br>        tmp.next = head;<br>        tmp = head;<br>        for (int i = 1; i &lt;= count - k % (count + 1); i++) {<br>            tmp = tmp.next;<br>        }<br>        head = tmp.next;<br>        tmp.next = null;<br>        return head;<br>    }<br>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhenghanho.github.io/2018/07/22/leetcode74-search-a-2d-matrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhenghan He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何政韩的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/22/leetcode74-search-a-2d-matrix/" itemprop="url">Leetcode(74) Search a 2D Matrix</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T09:34:20-04:00">
                2018-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode刷题笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode刷题笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><p>Write an efficient algorithm that searches for a value in an _m_ x _n_ matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p>Input:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 3<br>Output: true</p>
<p><strong>Example 2:</strong></p>
<p>Input:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 13<br>Output: false</p>
<h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><p>搜索题，如果遍历整个矩阵一定是超时的，不过因为矩阵的排列存在大小规律，可以根据这一特点调整搜索策略，先根据大小关系定位目标可能在的行，然后再遍历该行查找目标。值得注意的是需要考虑边界条件。具体实现的代码如下：</p>
<p>class Solution {<br>    public boolean searchMatrix(int[][] matrix, int target) {<br>        if (matrix.length == 0 || matrix[0].length == 0) {<br>            return false;<br>        }<br>        int resulti = 0;<br>        boolean result = false;<br>        for (int i = 0; i &lt; matrix.length; i++) {<br>            if (target &lt; matrix[i][0]) {<br>                resulti = i - 1;<br>                result = true;<br>                break;<br>            } else if (target == matrix[i][0]) {<br>                return true;<br>            }<br>            if (i == matrix.length - 1) {<br>                resulti = i;<br>                result = true;<br>            }<br>        }<br>        if (!result) {<br>            return result;<br>        }<br>        if (resulti == -1) {<br>            return false;<br>        }<br>        for (int j = 0; j &lt; matrix[resulti].length; j++) {<br>            if (matrix[resulti][j] == target) {<br>                return true;<br>            }<br>        }<br>        return false;<br>    }<br>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhenghanho.github.io/2018/07/21/leetcode106-construct-binary-tree-from-inorder-and-postorder-traversal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhenghan He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何政韩的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/21/leetcode106-construct-binary-tree-from-inorder-and-postorder-traversal/" itemprop="url">Leetcode(106) Construct Binary Tree from Inorder and Postorder Traversal</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-21T15:31:31-04:00">
                2018-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode刷题笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode刷题笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><p>Given inorder and postorder traversal of a tree, construct the binary tree. <strong>Note:</strong> You may assume that duplicates do not exist in the tree. For example, given</p>
<p>inorder = [9,3,15,20,7]<br>postorder = [9,15,7,20,3]</p>
<p>Return the following binary tree:</p>
<pre><code>3
</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7</p>
<h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><p>根据后序和中序遍历还原二叉树，解法与<a href="http://111.230.18.90:1997/leetcode105-construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">Leetcode(105) Construct Binary Tree from Preorder and Inorder Traversal</a>类似。 代码如下：</p>
<p>class Solution {<br>    public TreeNode buildTree(int[] inorder, int[] postorder) {<br>        TreeNode res = mybuild(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);<br>        return res;<br>    }</p>
<pre><code>private TreeNode mybuild(int\[\] inorder, int startin, int endin, int\[\] postorder, int startpost, int endpost) {
    if (startin &gt; endin || startpost &gt; endpost) {
        return null;
    }
    TreeNode root = new TreeNode(postorder\[endpost\]);
    for (int i = startin; i &lt;= endin; i++) {
        if (inorder\[i\] == root.val) {
            root.left = mybuild(inorder, startin, i - 1, postorder, startpost, startpost + i - startin - 1);
            root.right = mybuild(inorder, i + 1, endin, postorder, startpost + i - startin, endpost - 1);
        }
    }
    return root;
}
</code></pre><p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhenghanho.github.io/2018/07/21/leetcode105-construct-binary-tree-from-preorder-and-inorder-traversal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhenghan He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何政韩的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/21/leetcode105-construct-binary-tree-from-preorder-and-inorder-traversal/" itemprop="url">Leetcode(105) Construct Binary Tree from Preorder and Inorder Traversal</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-21T15:11:29-04:00">
                2018-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode刷题笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode刷题笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><p>Given preorder and inorder traversal of a tree, construct the binary tree. <strong>Note:</strong> You may assume that duplicates do not exist in the tree. For example, given</p>
<p>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]</p>
<p>Return the following binary tree:</p>
<pre><code>3
</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法:"></a>解法:</h1><p>题意简洁明了，即根据二叉树的前序遍历结果与中序遍历结果还原二叉树。（倒吸一口凉气啊，我真的对递归有阴影）。首先分析各顺序遍历的特点，具体如下：</p>
<ul>
<li>特性A，对于前序遍历，第一个肯定是根节点；</li>
<li>特性B，对于后序遍历，最后一个肯定是根节点；</li>
<li>特性C，利用前序或后序遍历，确定根节点，在中序遍历中，根节点的两边就可以分出左子树和右子树；</li>
<li>特性D，对左子树和右子树分别做前面3点的分析和拆分，相当于做递归，我们就可以重建出完整的二叉树；</li>
</ul>
<p>我们以一个例子做一下这个过程，假设：</p>
<ul>
<li>前序遍历的顺序是: CABGHEDF</li>
<li>中序遍历的顺序是: GHBACDEF</li>
</ul>
<p>第一步，我们根据特性A，可以得知根节点是C，然后，根据特性C，我们知道左子树是：GHBA，右子树是：DEF。</p>
<pre><code>    C
 /     \
GHBA   DEF
</code></pre><p>第二步，取出左子树，左子树的前序遍历是：ABGH，中序遍历是：GHBA，根据特性A和C，得出左子树的父节点是A，并且A没有右子树。</p>
<pre><code>      C
    /    \
   A    DEF
  /
GBH
</code></pre><p>第三步，使用同样的方法，前序是BGH，中序是GBH，得出父节点是B，G和H分别是左右节点。</p>
<pre><code>         C
      /     \
     A    DEF
    /
   B
 /    \
G      H
</code></pre><p>第四步，回到右子树，它的前序是EDF，中序是DEF，依然根据特性A和C，得出父节点是E，左右节点是D和F。</p>
<pre><code>      C
   /     \
  A        E
 /       /    \
B       D      F
</code></pre><p>   /    \<br>  G      H</p>
<p>到此，我们得到了这棵完整的二叉树，因此，它的后序遍历就是：GHBADFEC。</p>
<p>那么，思路变得简单了（0.0），即对于现有的序列，先确定根节点，根节点的左子树，根节点的右子树序列，然后在各子树中递归建树。递归的终止条件为序列为空（体现在起始值与终止值上）。</p>
<p>具体实现如下：</p>
<p>class Solution {<br>    public TreeNode buildTree(int[] preorder, int[] inorder) {<br>        TreeNode res = mybuild(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);<br>        return res;<br>    }</p>
<pre><code>private TreeNode mybuild(int\[\] preorder, int startpre, int endpre, int\[\] inorder, int startin, int endin) {
    if (startpre &gt; endpre || startin &gt; endin) {
        return null;
    }
    TreeNode root = new TreeNode(preorder\[startpre\]);
    for (int i = startin; i &lt;= endin; i++) {
        if (inorder\[i\] == root.val) {
            root.left = mybuild(preorder, startpre + 1, startpre + i - startin, inorder, startin, i - 1);
            root.right = mybuild(preorder, startpre - startin + i + 1, endpre, inorder, i + 1, endin);
        }
    }
    return root;
}
</code></pre><p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhenghanho.github.io/2018/07/20/leetcode36-valid-sudoku/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhenghan He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何政韩的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/leetcode36-valid-sudoku/" itemprop="url">Leetcode(36) Valid Sudoku</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-20T17:08:28-04:00">
                2018-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode刷题笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode刷题笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Description: Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following rules</strong>:</p>
<ol>
<li>Each row must contain the digits <code>1-9</code> without repetition.</li>
<li>Each column must contain the digits <code>1-9</code> without repetition.</li>
<li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li>
</ol>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""> A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>. <strong>Example 1:</strong></p>
<p>Input:<br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>Output: true</p>
<p><strong>Example 2:</strong></p>
<p>Input:<br>[<br>  [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>Output: false<br>Explanation: Same as Example 1, except with the 5 in the top left corner being<br>modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid.</p>
<p><strong>Note:</strong></p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
<li>The given board contain only digits <code>1-9</code> and the character <code>&#39;.&#39;</code>.</li>
<li>The given board size is always <code>9x9</code>.</li>
</ul>
<p>解法： 此题无需判断数独是否有解，只需要保证3个基本条件，即每一行的元素不重复，每一列的元素不重复，每一个子格的元素不重复。对于重复的判断，借用数据结构Map（因为Map的Key不允许重复）。 整体上来看，判断是否重复的对象为9行，9列，9个子格，故外层需循环9次。而内层循环针对外层循环的内部元素进行循环。对于行，列，子格，其内部都有9个最小单位元素。 对于行而言，第i行对应的元素为</p>
<p>board[i][j]</p>
<p>  对于列而言，第i列对应的元素为</p>
<p>board[j][i]</p>
<p>  对于子格元素的对应 观察行号规律： 第0个九宫格：000111222; 第1个九宫格：000111222; 第2个九宫格：000111222; 第3个九宫格：333444555; 第4个九宫格：333444555; 第5个九宫格：333444555; 第6个九宫格：666777888; 第7个九宫格：666777888; 第8个九宫格：666777888; 可见对于每三个九宫格行号增3；对于单个九宫格，每三个格点行号增1。 因此第i个九宫格的第j个格点的行号可表示为i/3*3+j/3 观察列号规律： 第0个九宫格：012012012; 第1个九宫格：345345345; 第2个九宫格：678678678; 第3个九宫格：012012012; 第4个九宫格：345345345; 第5个九宫格：678678678; 第6个九宫格：012012012; 第7个九宫格：345345345; 第8个九宫格：678678678; 可见对于下个九宫格列号增3，循环周期为3；对于单个九宫格，每个格点行号增1，周期也为3。 周期的数学表示就是取模运算mod。 因此第i个九宫格的第j个格点的列号可表示为i%3*3+j%3 故为：</p>
<p>board[i/3*3 + j/3][i%3*3 + j%3]</p>
<p>具体代码如下：</p>
<p>class Solution {<br>    public boolean isValidSudoku(char[][] board) {<br>        for (int i = 0; i &lt; 9; i++) {<br>            Map&lt;Character, Boolean&gt; judge_row = new HashMap&lt;Character, Boolean&gt;();<br>            Map&lt;Character, Boolean&gt; judge_col = new HashMap&lt;Character, Boolean&gt;();<br>            Map&lt;Character, Boolean&gt; judge_sub = new HashMap&lt;Character, Boolean&gt;();<br>            for (int j = 0; j &lt; 9; j++) {<br>                if (board[i][j] != ‘.’) {<br>                    if (judge_row.containsKey(board[i][j])) {<br>                        return false;<br>                    }<br>                    judge_row.put(board[i][j], true);<br>                }<br>                if (board[j][i] != ‘.’) {<br>                    if (judge_col.containsKey(board[j][i])) {<br>                        return false;<br>                    }<br>                    judge_col.put(board[j][i], true);<br>                }<br>                if (board[i / 3 <em> 3 + j / 3][i % 3 </em> 3 + j % 3] != ‘.’) {<br>                    if (judge_sub.containsKey(board[i / 3 <em> 3 + j / 3][i % 3 </em> 3 + j % 3])) {<br>                        return false;<br>                    }<br>                    judge_sub.put(board[i / 3 <em> 3 + j / 3][i % 3 </em> 3 + j % 3], true);<br>                }<br>            }<br>        }<br>        return true;<br>    }<br>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhenghan He</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhenghan He</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
