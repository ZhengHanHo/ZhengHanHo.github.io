<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leecode(199) Binary Tree Right Side View]]></title>
    <url>%2F2019%2F10%2F03%2FLeecode-199-Binary-Tree-Right-Side-View%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: 123456789Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- 解法其实是按层遍历的变形，只要把每层的最后一个节点记录下来就可以了。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; res= new ArrayList&lt;&gt;(); public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; if(root == null)&#123; return res; &#125; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); while(!q.isEmpty())&#123; int size = q.size(); for(int k = 0; k&lt;size; k++)&#123; TreeNode tmp = q.poll(); if(tmp.left!=null)&#123; q.offer(tmp.left); &#125; if(tmp.right!=null)&#123; q.offer(tmp.right); &#125; if(k == size -1 )&#123; res.add(tmp.val); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(143) Reorder List]]></title>
    <url>%2F2019%2F10%2F02%2FLeetcode-143-Reorder-List%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a singly linked list L: L0→L1→…→L**n-1→Ln,reorder it to: L0→L**n→L1→L**n-1→L2→L**n-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed. Example 1: 1Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3. Example 2: 1Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. 解法思路： 找到链表的中点，并将链表从中点处断开，形成两个独立的链表 将第二个链翻转。 将第二个链表的元素间隔地插入第一个链表中。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; public void reorderList(ListNode head) &#123; if (head == null || head.next == null) &#123; return; &#125; int length = 0; ListNode start = head; while (start != null) &#123; length++; start = start.next; &#125; ListNode head2 = head; ListNode pre = null; int move = length / 2; while (move &gt; 0) &#123; pre = head2; head2 = head2.next; move--; &#125; pre.next = null; head2 = reverseList(head2); ListNode newhead = head; ListNode head1 = head.next; newhead.next = null; int step = 1; while (head1 != null || head2 != null) &#123; if (step % 2 == 1) &#123; if (head2 != null) &#123; newhead.next = head2; newhead = newhead.next; head2 = head2.next; newhead.next = null; &#125; step++; &#125; else &#123; if (head1 != null) &#123; newhead.next = head1; newhead = newhead.next; head1 = head1.next; newhead.next = null; &#125; step++; &#125; &#125; newhead.next = null; &#125; ListNode reverseList(ListNode head) &#123; if (head == null) &#123; return head; &#125; if (head.next == null) &#123; return head; &#125; ListNode res = reverseList(head.next); head.next.next = head; head.next = null; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(160) Intersection of Two Linked Lists]]></title>
    <url>%2F2019%2F10%2F02%2FLeetcode-160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[DescriptionWrite a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. Example 1: 123Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3Output: Reference of the node with value = 8Input Explanation: The intersected node&apos;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Example 2: 123Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1Output: Reference of the node with value = 2Input Explanation: The intersected node&apos;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3: 1234Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2Output: nullInput Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.Explanation: The two lists do not intersect, so return null. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 解法用一个HashSet存储节点即可，遍历完两个链表，如果有相交节点，那么第一个冲突的点就是交点啦 具体代码如下： 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; HashSet&lt;ListNode&gt; hs = new HashSet&lt;&gt;(); while (headA != null || headB != null) &#123; if (headA != null) &#123; if (hs.contains(headA)) &#123; return headA; &#125; hs.add(headA); headA = headA.next; &#125; if (headB != null) &#123; if (hs.contains(headB)) &#123; return headB; &#125; hs.add(headB); headB = headB.next; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(958) Check Completeness of a Binary Tree]]></title>
    <url>%2F2019%2F10%2F01%2FLeetcode-958-Check-Completeness-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, determine if it is a complete binary tree. Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example 1: 123Input: [1,2,3,4,5,6]Output: trueExplanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible. Example 2: 123Input: [1,2,3,4,5,null,7]Output: falseExplanation: The node with value 7 isn&apos;t as far left as possible. Note: The tree will have between 1 and 100 nodes. 解法按层遍历二叉树节点，无论当前节点的子节点是否为空均加入队列，如果在队列中碰到为空的节点，那么如果是一棵完全树，则队列中的剩余元素必都为空，否则是不完全的。 具体代码如下： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isCompleteTree(TreeNode root) &#123; if(root == null)&#123; return true; &#125; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); while(q.peek()!=null)&#123; TreeNode tmp = q.poll(); q.offer(tmp.left); q.offer(tmp.right); &#125; while(!q.isEmpty())&#123; TreeNode tmp = q.poll(); if(tmp != null)&#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(314) Binary Tree Vertical Order Traversal]]></title>
    <url>%2F2019%2F10%2F01%2FLeetcode-314-Binary-Tree-Vertical-Order-Traversal%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, return the vertical order traversal of its nodes’ values. (ie, from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right. Examples 1: 123456789101112131415161718Input: [3,9,20,null,null,15,7] 3 /\ / \ 9 20 /\ / \ 15 7 Output:[ [9], [3,15], [20], [7]] Examples 2: 12345678910111213141516171819Input: [3,9,8,4,0,1,7] 3 /\ / \ 9 8 /\ /\ / \/ \ 4 01 7 Output:[ [4], [9], [3,0,1], [8], [7]] Examples 3: 12345678910111213141516171819202122Input: [3,9,8,4,0,1,7,null,null,null,2,5] (0&apos;s right child is 2 and 1&apos;s left child is 5) 3 /\ / \ 9 8 /\ /\ / \/ \ 4 01 7 /\ / \ 5 2Output:[ [4], [9,5], [3,0,1], [8,2], [7]] 解法在TreeNode外包装一层level，然后通过BFS扫描（不能用前序遍历因为有顺序问题，必须是从上往下的），这里采用TreeMap保证已按Level排好序，遍历输出到list即可。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Definition of TreeNode: * public class TreeNode &#123; * public int val; * public TreeNode left, right; * public TreeNode(int val) &#123; * this.val = val; * this.left = this.right = null; * &#125; * &#125; */public class Solution &#123; /** * @param root: the root of tree * @return: the vertical order traversal */ List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); TreeMap&lt;Integer,List&gt; map = new TreeMap&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) &#123; // write your code here if(root == null)&#123; return null; &#125; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.offer(new Node(root,0)); while(!q.isEmpty())&#123; Node now = q.poll(); if(map.containsKey(now.level))&#123; map.get(now.level).add(now.realnode.val); &#125; else&#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.add(now.realnode.val); map.put(now.level,tmp); &#125; if(now.realnode.left!=null)&#123; Node left = new Node(now.realnode.left,now.level - 1); q.offer(left); &#125; if(now.realnode.right != null)&#123; Node right = new Node(now.realnode.right,now.level + 1); q.offer(right); &#125; &#125; Set&lt;Integer&gt; ks = map.keySet(); Iterator it = ks.iterator(); while(it.hasNext())&#123; res.add(map.get(it.next())); &#125; return res; &#125; class Node&#123; TreeNode realnode; int level; Node(TreeNode realnode,int level)&#123; this.realnode = realnode; this.level = level; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(286) Walls and Gates]]></title>
    <url>%2F2019%2F10%2F01%2FLeetcode-286-Walls-and-Gates%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given a m x n 2D grid initialized with these three possible values. -1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF. Example: Given the 2D grid: 1234INF -1 0 INFINF INF INF -1INF -1 INF -1 0 -1 INF INF After running your function, the 2D grid should be: 12343 -1 0 12 2 1 -11 -1 2 -10 -1 3 4 解法采用BFS解题即可。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Solution &#123; /** * @param rooms: m x n 2D grid * @return: nothing */ public void wallsAndGates(int[][] rooms) &#123; // write your code here if (rooms.length == 0) &#123; return; &#125; int[] dirx = &#123;-1, 1, 0, 0&#125;; int[] diry = &#123;0, 0, 1, -1&#125;; int[][] visit = new int[rooms.length][rooms[0].length]; for (int i = 0; i &lt; rooms.length; i++) &#123; for (int j = 0; j &lt; rooms[0].length; j++) &#123; if (rooms[i][j] == 0) &#123; for (int a = 0; a &lt; rooms.length; a++) &#123; for (int b = 0; b &lt; rooms[0].length; b++) &#123; visit[a][b] = 0; &#125; &#125; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.offer(new Node(i, j)); int step = 0; while (!q.isEmpty()) &#123; int size = q.size(); for (int k = 0; k &lt; size; k++) &#123; Node now = q.poll(); int x = now.i; int y = now.j; rooms[x][y] = rooms[x][y] &lt; step ? rooms[x][y] : step; visit[x][y] = 1; for (int l = 0; l &lt; 4; l++) &#123; int nextx = x + dirx[l]; int nexty = y + diry[l]; if (nextx &gt;= 0 &amp;&amp; nextx &lt; rooms.length &amp;&amp; nexty &gt;= 0 &amp;&amp; nexty &lt; rooms[0].length &amp;&amp; rooms[nextx][nexty] != 0 &amp;&amp; rooms[nextx][nexty] != -1 &amp;&amp; visit[nextx][nexty] == 0) &#123; q.offer(new Node(nextx, nexty)); &#125; &#125; &#125; step++; &#125; &#125; &#125; &#125; &#125; class Node &#123; int i; int j; Node(int i, int j) &#123; this.i = i; this.j = j; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(146) LRU Cache]]></title>
    <url>%2F2019%2F10%2F01%2FLeetcode-146-LRU-Cache%2F</url>
    <content type="text"><![CDATA[DescriptionDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 解法用一个哈希表和一个双向链表实现，注意删除节点，移动节点时头尾节点的处理，同时如果put一个已有的key对，则更新并置于队尾即可。写的真心心累… 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class LRUCache &#123; class Node &#123; int val; int key; Node next; Node pre; Node(int key, int val) &#123; this.val = val; this.key = key; &#125; &#125; Node head = null; Node tail = null; int capacity; HashMap&lt;Integer, Node&gt; valMap; public LRUCache(int capacity) &#123; this.capacity = capacity; this.valMap = new HashMap&lt;&gt;(); &#125; public int get(int key) &#123; if (this.valMap.containsKey(key)) &#123; Node result = this.valMap.get(key); Node pre = result.pre; Node next = result.next; if (head == result &amp;&amp; tail == result) &#123; return result.val; &#125; if (head == result) &#123; head = next; tail.next = result; result.pre = tail; result.next = null; tail = result; return result.val; &#125; else if (tail == result) &#123; return result.val; &#125; else &#123; pre.next = next; next.pre = pre; tail.next = result; result.pre = tail; result.next = null; tail = result; return result.val; &#125; &#125; return -1; &#125; public void put(int key, int value) &#123; if (valMap.containsKey(key)) &#123; this.get(key); tail.val = value; return; &#125; Node node = new Node(key, value); if (this.valMap.size() &lt; this.capacity) &#123; if (head == null) &#123; head = node; head.pre = null; head.next = null; tail = node; &#125; else &#123; tail.next = node; node.pre = tail; node.next = null; tail = node; &#125; &#125; else &#123; valMap.remove(head.key); if (head == tail) &#123; head = tail = node; this.valMap.put(key, node); return; &#125; head = head.next; head.pre = null; tail.next = node; node.pre = this.tail; node.next = null; tail = node; &#125; this.valMap.put(key, node); &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(317) Shortest Distance from All Buildings]]></title>
    <url>%2F2019%2F09%2F30%2FLeetcode-317-Shortest-Distance-from-All-Buildings%2F</url>
    <content type="text"><![CDATA[DescriptionYou want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where: Each 0 marks an empty land which you can pass by freely. Each 1 marks a building which you cannot pass through. Each 2 marks an obstacle which you cannot pass through. Example: 12345678910111213Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]1 - 0 - 2 - 0 - 1| | | | |0 - 0 - 0 - 0 - 0| | | | |0 - 0 - 1 - 0 - 0Output: 7 Explanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2), the point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7. Note:There will be at least one building. If it is not possible to build such house according to the above rules, return -1. 解法BFS解题，cnt数组存储能达到的building数目，dis记录到各building的距离合。就是麻烦了一点，没办法，没法用DFS写，因为没法保证最小距离 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.LinkedList;import java.util.Queue;public class Solution &#123; /** * @param grid: the 2D grid * @return: the shortest distance */ static public int shortestDistance(int[][] grid) &#123; int result = Integer.MAX_VALUE; int[][] dis = new int[grid.length][grid[0].length]; int[][] cnt = new int[grid.length][grid[0].length]; int buildingcnt = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] != 1) &#123; continue; &#125; buildingcnt++; int x = i; int y = j; int[][] visit = new int[grid.length][grid[0].length]; int[] dirx = &#123;0, 0, 1, -1&#125;; int[] diry = &#123;1, -1, 0, 0&#125;; visit[x][y] = 1; Node newpair = new Node(x, y); Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(newpair); int step = 0; dis[x][y] = step; while (!q.isEmpty()) &#123; int size = q.size(); for (int s = 0; s &lt; size; s++) &#123; Node p = q.poll(); x = p.x; y = p.y; dis[x][y] += step; cnt[x][y] += 1; for (int ii = 0; ii &lt; 4; ii++) &#123; int nexti = x + dirx[ii]; int nextj = y + diry[ii]; if (nexti &gt;= 0 &amp;&amp; nexti &lt; grid.length &amp;&amp; nextj &gt;= 0 &amp;&amp; nextj &lt; grid[0].length &amp;&amp; visit[nexti][nextj] == 0 &amp;&amp; grid[nexti][nextj] == 0) &#123; q.add(new Node(nexti, nextj)); visit[nexti][nextj] = 1; &#125; &#125; &#125; step += 1; &#125; &#125; &#125; for (int i = 0; i &lt; dis.length; i++) &#123; for (int j = 0; j &lt; dis[0].length; j++) &#123; result = dis[i][j] &lt; result &amp;&amp; grid[i][j] == 0 &amp;&amp; cnt[i][j] == buildingcnt ? dis[i][j] : result; &#125; &#125; if (result == Integer.MAX_VALUE) &#123; return -1; &#125; return result; &#125;&#125;class Node &#123; int x; int y; Node(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(670) Maximum Swap]]></title>
    <url>%2F2019%2F09%2F30%2FLeetcode-670-Maximum-Swap%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get. Example 1: 123Input: 2736Output: 7236Explanation: Swap the number 2 and the number 7. Example 2: 123Input: 9973Output: 9973Explanation: No swap. Note: The given number is in the range [0, 108] 解法思路：先找到每个位置对应的在他右边的最大的数，然后从高位起扫描数组，找到第一个存在右边比他大的数的位置，然后从数组尾部开始扫描，找到这个比他大的数，然后交换即可 具体代码如下： 1234567891011121314151617181920212223242526class Solution &#123; public int maximumSwap(int num) &#123; char[] input = Integer.toString(num).toCharArray(); char[] maxnum = new char[input.length - 1]; if(input.length == 1)&#123; return Integer.parseInt(new String(input)); &#125; maxnum[maxnum.length - 1] = (char) Math.max(input[maxnum.length], input[maxnum.length - 1]); for (int i = maxnum.length - 2; i &gt;= 0; i--) &#123; maxnum[i] = (char) Math.max(input[i], maxnum[i + 1]); &#125; for (int i = 0; i &lt; maxnum.length; i++) &#123; if (maxnum[i] &gt; input[i]) &#123; for (int j = input.length - 1; j &gt; i; j--) &#123; if (input[j] == maxnum[i]) &#123; char tmp = input[j]; input[j] = input[i]; input[i] = tmp; return Integer.parseInt(new String(input)); &#125; &#125; &#125; &#125; return Integer.parseInt(new String(input)); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(440) K-th Smallest in Lexicographical Order]]></title>
    <url>%2F2019%2F09%2F30%2FLeetcode-440-K-th-Smallest-in-Lexicographical-Order%2F</url>
    <content type="text"><![CDATA[DescriptionGiven integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n. Note: 1 ≤ k ≤ n ≤ 109. Example: 12345678Input:n: 13 k: 2Output:10Explanation:The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10. 解法思路是：对于每个点，有向右和像下两种走法，如果我们计算这个点一下的节点个数（不包含自己，但包含到这个点右边的节点的个数，在代码里为calstep的返回值），如果比剩余的步数少，则直接向右走，否则向下走。 计算这个点下的数目时，考虑是否为完整层，所以出现了calstep中与n的比较情况 参考思路：https://massivealgorithms.blogspot.com/2016/10/leetcode-440-k-th-smallest-in.html 具体代码如下： 12345678910111213141516171819202122232425262728293031class Solution &#123; public int findKthNumber(int n, int k) &#123; int current = 1; k -= 1; while (k &gt; 0) &#123; long step = calstep(current, current + 1, n); if (step &lt;= k) &#123; k -= step; current = current + 1; &#125; else &#123; k -= 1; current = current * 10; &#125; &#125; return current; &#125; long calstep(long current, long levelMaxNumber, int n) &#123; long step = 0; while (current &lt;= n) &#123; if (levelMaxNumber &gt; n) &#123; step += (n - current + 1); &#125; else &#123; step += (levelMaxNumber - current); &#125; current *= 10; levelMaxNumber *= 10; &#125; return step; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(386) Lexicographical Numbers]]></title>
    <url>%2F2019%2F09%2F30%2FLeetcode-386-Lexicographical-Numbers%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an integer n, return 1 - n in lexicographical order. For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9]. Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000. 解法采用DFS的解法，其实就是十叉树的前序遍历嘛。参考二叉树的前序遍历即可 具体代码如下： 1234567891011121314151617181920class Solution &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; lexicalOrder(int n) &#123; int root = 1; while (root &lt;= n &amp;&amp; root &lt;= 9) &#123; DFS(root, n); root += 1; &#125; return result; &#125; void DFS(int root,int n)&#123; result.add(root); for (int i = 0; i &lt;= 9; i++) &#123; if (root * 10 + i &lt;= n) &#123; DFS(root * 10 + i, n); &#125; &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(155) Min Stack]]></title>
    <url>%2F2019%2F09%2F24%2FLeetcode-155-Min-Stack%2F</url>
    <content type="text"><![CDATA[DescriptionDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 解法用两个栈来实现，其中一个栈正常地存数，另一个存对饮栈状态第一个栈中的最小值即可。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MinStack &#123; Stack&lt;Integer&gt; s; Stack&lt;Integer&gt; helper; /** initialize your data structure here. */ public MinStack() &#123; this.s = new Stack&lt;&gt;(); this.helper = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; s.push(x); if(this.helper.size() == 0)&#123; this.helper.push(x); &#125; else&#123; if(this.helper.peek() &lt; x)&#123; this.helper.push(this.helper.peek()); &#125; else&#123; this.helper.push(x); &#125; &#125; &#125; public void pop() &#123; this.s.pop(); this.helper.pop(); &#125; public int top() &#123; return this.s.peek(); &#125; public int getMin() &#123; return this.helper.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2019%2F09%2F23%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[0-1背包问题描述：有N件物品和一个容量为V的背包。第i件物品的费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使价值总和最大。 特点是：每种物品仅有一件，可以选择放或不放。 思路：对于前i件物品放入容量为j的背包中这个问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为j的背包中”，价值为f[i-1][j]；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为j-v[i]的背包中”，此时能获得的最大价值就是f[i-1][j-v[i]]再加上通过放入第i件物品获得的价值w[i]。 1dp[i][j] = max(f[i - 1][j],f[i - 1][j - w[i]] + v[i]) 例子：5个物品，（重量，价值）分别为：（5，12），（4，3），（7，10），（2，3），（6，6）: 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; int[] v = new int[]&#123;12, 3, 10, 3, 6&#125;; int[] w = new int[]&#123;5, 4, 7, 2, 6&#125;; int[][] dp = new int[5][16]; //初始化第一行 for (int j = 0; j &lt;= 15; j++) &#123; dp[0][j] = w[0] &lt;= j ? v[0] : 0; &#125; for (int i = 1; i &lt; 5; i++) &#123; for (int j = 1; j &lt;= 15; j++) &#123; if (j - w[i] &gt;= 0) &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; System.out.println(dp[4][15]); &#125;&#125; 拓展：对于空间的优化？ 采用滚动数组的思想进行降维处理： 将i视作数组的更新轮数 dp[i][v]是由dp[i-1][v]和dp[i-1][j-v[i]]两个子问题递推而来，能否保证在推dp[i][j]时（也即在第i次主循环中推dp[j]时）能够得到dp[i-1][j]和dp[i-1][j-v[i]]的值呢？事实上，这要求在每次主循环中我们以j=V..0的顺序推dp[j]，这样才能保证推dp[j]时dp[j-v[i]]保存的是状态dp[i-1][j-v[i]]的值。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了dp[i][j]由dp[i][j-v[i]]推知，与本题意不符。 伪代码： 12345for i=1..N: for j=V..0: dp[j]=max&#123;dp[j],f[j-v[i]]+w[i]&#125;; 再拓展：如果要求放满怎么办？ 那么在初始化时除了dp[0]为0,其它dp、[1..V]均设为负无穷，这样就可以保证最终得到的dp[N]是一种恰好装满背包的最优解。 可以这样理解：初始化的dp数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是负无穷了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。 完全背包问题描述：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 先说最基本的算法： 1dp[i][j]=max&#123; dp[i-1][j-k*c[i]]+k*w[i] | 0&lt;=k*c[i]&lt;=v&#125; 改进思路1：转化为01背包问题，因为物品都有无限件可用,那么没见物品最多放置V/v[i]个，我们可以把物品列表补全到这么多个然后用0-1背包的方法来解决（这里就不给代码啦） 改进思路2：在完全背包中，每种物品可选无限件，在求解加选第i种物品带来的收益f[i][v]时，在状态f[i][v-c[i]]中已经尽可能多的放入物品i了，此时在f[i][v-c[i]]的基础上，我们可以再次放入一件物品i，此时也是在不超过背包容量的基础下，尽可能多的放入物品i。完全背包的方程： 1dp[i][j] = max(f[i - 1][j],f[i][j - w[i]] + v[i]); 可以同样采用滚动数组的方法进行降维处理： 降维后的状态转移方程为： 12dp[j] = max(dp[j],dp[j-w[i]]+v[i]);//这里遍历j的时候就需要从0到v了，相当于一件一件地加第i件物品 多重背包问题描述：有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 直接上没有优化的状态转移公式吧 1dp[i][j] = max&#123;dp[i − 1][j − k * w[i]] + k * v[i] (0 ≤ k ≤ n[i]) &#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(135) Candy]]></title>
    <url>%2F2019%2F09%2F17%2FLeetcode-135-Candy%2F</url>
    <content type="text"><![CDATA[DescriptionThere are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? Example 1: 123Input: [1,0,2]Output: 5Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. Example 2: 1234Input: [1,2,2]Output: 4Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions. 解法网上看到的思路：先从左往右扫描一遍, 如果后面一个比前面大, 那么他分配的就多一颗糖, 否则就是1. 但是这样会产生一种情况, 就是两个相邻的排名一样, 那么后一个还是分一个, 但是后面的可能比这个值小, 但是仍然分得和这个值一样的糖, 因此还要从右往左再扫描一遍来补偿小的值. 具体代码如下： 123456789101112131415161718192021222324252627class Solution &#123; public int candy(int[] ratings) &#123; if(ratings == null)&#123; return 0; &#125; int[] res = new int[ratings.length]; res[0] = 1; for(int i = 1; i &lt; ratings.length; i++)&#123; if(ratings[i] &gt; ratings[i-1])&#123; res[i] = res[i-1] + 1; &#125; else&#123; res[i] = 1; &#125; &#125; for(int i = ratings.length - 2; i &gt;= 0 ; i--)&#123; if(ratings[i] &gt; ratings[i+1] &amp;&amp; res[i] &lt;= res[i+1])&#123; res[i] = res[i+1] + 1; &#125; &#125; int result = 0; for(int i = 0; i &lt; ratings.length; i++)&#123; result += res[i]; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(134) Gas Station]]></title>
    <url>%2F2019%2F09%2F17%2FLeetcode-134-Gas-Station%2F</url>
    <content type="text"><![CDATA[DescriptionThere are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example 1: 1234567891011121314Input: gas = [1,2,3,4,5]cost = [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. Example 2: 12345678910111213Input: gas = [2,3,4]cost = [3,4,3]Output: -1Explanation:You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 0. Your tank = 4 - 3 + 2 = 3Travel to station 1. Your tank = 3 - 3 + 3 = 3You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can&apos;t travel around the circuit once no matter where you start. 解法暴力求解，如果当前的油量加上当前站点的加油量减去去下一个站点的耗油量大于0，则可继续 具体代码如下： 1234567891011121314151617181920212223class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int largeIndex = gas.length; for (int i = 0; i &lt; largeIndex; i++) &#123; int step = 0; int gasLeft = 0; for (int j = i; step != largeIndex; j++) &#123; if (j == largeIndex) &#123; j = 0; &#125; gasLeft = gasLeft + gas[j] - cost[j]; if (gasLeft &lt; 0) &#123; break; &#125; step++; &#125; if (step == largeIndex) &#123; return i; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(133) Clone Graph]]></title>
    <url>%2F2019%2F09%2F17%2FLeetcode-133-Clone-Graph%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors. Example: 12345678Input:&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;Explanation:Node 1&apos;s value is 1, and it has two neighbors: Node 2 and 4.Node 2&apos;s value is 2, and it has two neighbors: Node 1 and 3.Node 3&apos;s value is 3, and it has two neighbors: Node 2 and 4.Node 4&apos;s value is 4, and it has two neighbors: Node 1 and 3. Note: The number of nodes will be between 1 and 100. The undirected graph is a simple graph#Simple_graph), which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph. 解法此题的关键在于邻居节点的处理，如果已经复制过一遍了，就不需要进行复制，我们创建一个hashmap来记录已经复制过的节点即可，然后DFS遍历复制整个图，注意，向hashmap中加键值对需发生在递归前，类似于图遍历中的标记操作（标记已经遍历过这个点了），否则会陷入死循环。 具体代码如下： 123456789101112131415161718192021class Solution &#123; HashMap&lt;Node,Node&gt; copyMap = new HashMap&lt;&gt;(); public Node cloneGraph(Node node) &#123; if(node == null)&#123; return null; &#125; if(!copyMap.containsKey(node))&#123; List&lt;Node&gt; newNodeNeighbor = new ArrayList&lt;&gt;(); Node newNode = new Node(node.val,newNodeNeighbor); copyMap.put(node,newNode); for(int i = 0; i &lt; node.neighbors.size(); i++)&#123; newNodeNeighbor.add(cloneGraph(node.neighbors.get(i))); &#125; return newNode; &#125; else&#123; return copyMap.get(node); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(131) Palindrome Partitioning]]></title>
    <url>%2F2019%2F09%2F10%2FLeetcode-131-Palindrome-Partitioning%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: 123456Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 解法经验：遇到要求所有组合、可能、排列等解集的题目，一般都是DFS + backtracking 首先传入s=”aab” path=[] res = [], 首先切割出”a”（然后是”aa” “aab” …），然后判读它是不是回文串： 如果不是，直接跳过 如果是，则此时剩余的 s=”ab”， path += [“a”] 写入res的判断是，当s=””时，记录结果 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;String&gt; path = new ArrayList&lt;&gt;(); helper(s, path); return res; &#125; void helper(String s, List&lt;String&gt; path)&#123; if(s.equals(""))&#123; if(path.size()!=0)&#123; List&lt;String&gt; respath = new ArrayList&lt;&gt;(path); res.add(respath); &#125; return; &#125; for(int i = 0; i &lt;= s.length(); i++)&#123; if(judge(s.substring(0,i)))&#123; path.add(s.substring(0,i)); helper(s.substring(i),path); path.remove(path.size() - 1); &#125; &#125; &#125; Boolean judge(String s)&#123; if(s.length() == 0)&#123; return false; &#125; for(int i = 0 ; i &lt; s.length(); i++)&#123; if(s.charAt(i) != s.charAt(s.length() - i - 1))&#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(130) Surrounded Regions]]></title>
    <url>%2F2019%2F09%2F10%2FLeetcode-130-Surrounded-Regions%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;. A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region. Example: 1234X X X XX O O XX X O XX O X X After running your function, the board should be: 1234X X X XX X X XX X X XX O X X Explanation: Surrounded regions shouldn’t be on the border, which means that any &#39;O&#39; on the border of the board are not flipped to &#39;X&#39;. Any &#39;O&#39; that is not on the border and it is not connected to an &#39;O&#39; on the border will be flipped to &#39;X&#39;. Two cells are connected if they are adjacent cells connected horizontally or vertically. 解法如果直接从一个’O’开始搜索判断是不是会到达边界，将会非常麻烦，因为需要保存路径上的每个’O’，如果到达边界就放弃这片区域的所有值，否则将其变为’X’。有一种更为聪明的做法是从四个边界出发，用DFS算法将从边界开始的’O’的区域都变成另外一个临时的值，这样做完之后剩下的‘O’将会是被包围的，然后将其变为‘X’，再将临时的值变为’O’即可。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public void solve(char[][] board) &#123; if(board.length == 0)&#123; return; &#125; int m = board.length; int n = board[0].length; for(int i = 0; i &lt; m; i++)&#123; if(board[i][0] == 'O')&#123; dfsHelper(board, i ,0); &#125; &#125; for(int i = 0; i &lt; m; i++)&#123; if(board[i][n-1] == 'O')&#123; dfsHelper(board, i , n-1); &#125; &#125; for(int j = 0; j &lt; n; j++)&#123; if(board[0][j] == 'O')&#123; dfsHelper(board, 0 ,j); &#125; &#125; for(int j = 0; j &lt; n; j++)&#123; if(board[m-1][j] == 'O')&#123; dfsHelper(board, m-1 ,j); &#125; &#125; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(board[i][j] == 'O')&#123; board[i][j] = 'X'; &#125; if(board[i][j] == '#')&#123; board[i][j] = 'O'; &#125; &#125; &#125; &#125; void dfsHelper(char[][] board, int x, int y)&#123; board[x][y] = '#'; int[] nextX = &#123;0,0,-1,1&#125;; int[] nextY = &#123;1,-1,0,0&#125;; for(int i = 0; i &lt; 4; i++)&#123; int newX = x + nextX[i]; int newY = y + nextY[i]; if(newX &gt;= 0 &amp;&amp; newX &lt; board.length &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; board[0].length)&#123; if(board[newX][newY] == 'O')&#123; dfsHelper(board, newX, newY); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(129) Sum Root to Leaf Numbers]]></title>
    <url>%2F2019%2F09%2F09%2FLeetcode-129-Sum-Root-to-Leaf-Numbers%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: 123456789Input: [1,2,3] 1 / \ 2 3Output: 25Explanation:The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Therefore, sum = 12 + 13 = 25. Example 2: 123456789101112Input: [4,9,0,5,1] 4 / \ 9 0 / \5 1Output: 1026Explanation:The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.The root-to-leaf path 4-&gt;0 represents the number 40.Therefore, sum = 495 + 491 + 40 = 1026. 解法DFS遍历每一条自顶向下的路径然后累加求和即可~ 具体代码如下： 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public int sumNumbers(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; dfs(root, root.val); int result = 0; for (Integer x : res) &#123; result += x; &#125; return result; &#125; public void dfs(TreeNode root, int pathSum) &#123; if (root.left == null &amp;&amp; root.right == null) &#123; res.add(pathSum); &#125; else if (root.left == null) &#123; dfs(root.right, pathSum * 10 + root.right.val); &#125; else if (root.right == null) &#123; dfs(root.left, pathSum * 10 + root.left.val); &#125; else &#123; dfs(root.right, pathSum * 10 + root.right.val); dfs(root.left, pathSum * 10 + root.left.val); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(128) Longest Consecutive Sequence]]></title>
    <url>%2F2019%2F09%2F09%2FLeetcode-128-Longest-Consecutive-Sequence%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: 123Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 解法补充以下，这题不用考虑数组中元素想等的情况，比如[1, 1, 1, 1]的输出为1。 这题的方法有点难想，最后参考的网上的解法： 使用一个集合HashSet存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那么将其移除，然后分别用两个变量pre和next算出其前一个数跟后一个数，然后在集合中循环查找，如果pre在集合中，那么将pre移除集合，然后pre再自减1，直至pre不在集合之中，对next采用同样的方法，那么next-pre-1就是当前数字的最长连续序列，更新res即可。这里再说下，为啥当检测某数字在集合中存在当时候，都要移除数字。这是为了避免大量的重复计算，就拿题目中的例子来说吧，我们在遍历到4的时候，会向下遍历3，2，1，如果都不移除数字的话，遍历到1的时候，还会遍历2，3，4。同样，遍历到3的时候，向上遍历4，向下遍历2，1，等等等。如果数组中有大量的连续数字的话，那么就有大量的重复计算，十分的不高效。 具体代码如下： 123456789101112131415161718192021222324252627282930class Solution &#123; public int longestConsecutive(int[] nums) &#123; if(nums.length == 0)&#123; return 0; &#125; HashSet&lt;Integer&gt; numSet = new HashSet(); for(int x : nums)&#123; numSet.add(x); &#125; int res = 1; for(int i = 0; i &lt; nums.length; i++)&#123; if(!numSet.contains(nums[i]))&#123; continue; &#125; numSet.remove(nums[i]); int pre = nums[i] - 1; int next = nums[i] + 1; while(numSet.contains(pre))&#123; numSet.remove(pre); pre--; &#125; while(numSet.contains(next))&#123; numSet.remove(next); next++; &#125; res = res &gt; next - pre -1 ? res : next - pre -1; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(127) Word Ladder]]></title>
    <url>%2F2019%2F09%2F09%2FLeetcode-127-Word-Ladder%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: 123456789Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. Example 2: 12345678Input:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: 0Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. 解法这题一看我开始是懵的，看网上的思路发现是一个BFS的题，即每次遍历26个字母替换的所有情况，如果在list里则入队，同时统计更改的步数，步数采用HashMap存储。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; HashSet&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); if(!wordSet.contains(endWord))&#123; return 0; &#125; HashMap&lt;String,Integer&gt; lengthMap = new HashMap&lt;&gt;(); lengthMap.put(beginWord, 1); Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offer(beginWord); while(!q.isEmpty())&#123; String word = q.poll(); for(int i = 0; i &lt; word.length() ; i++)&#123; String newWord = word; for(char j = 'a'; j &lt;= 'z' ;j++)&#123; newWord = newWord.substring(0, i) + j + newWord.substring(i + 1); if(wordSet.contains(newWord) &amp;&amp; newWord.equals(endWord))&#123; return lengthMap.get(word) + 1; &#125; if(wordSet.contains(newWord) &amp;&amp; !lengthMap.containsKey(newWord))&#123; q.offer(newWord); lengthMap.put(newWord,lengthMap.get(word) + 1); &#125; &#125; &#125; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(124) Binary Tree Maximum Path Sum]]></title>
    <url>%2F2019%2F09%2F09%2FLeetcode-124-Binary-Tree-Maximum-Path-Sum%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: 1234567Input: [1,2,3] 1 / \ 2 3Output: 6 Example 2: 123456789Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7Output: 42 解法嗯，递归解题，但是坑挺多，首先要注意路径不一定从根经过，另外路径必须能够展开成一条直线，这就意味着对于最终路径上的非跟节点必须选择左右子树的一边进行计算，导致递归的返回和进入优先队列的计算值不一样 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; Queue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;); public int maxPathSum(TreeNode root) &#123; maxPathSumHelper(root); return q.element(); &#125; public int maxPathSumHelper(TreeNode root) &#123; if (root.left == null &amp;&amp; root.right == null) &#123; q.offer(root.val); return root.val; &#125; if (root.right == null) &#123; int leftMax = maxPathSumHelper(root.left); q.offer(leftMax &gt; 0 ? root.val + leftMax : root.val); return leftMax &gt; 0 ? root.val + leftMax : root.val; &#125; if (root.left == null) &#123; int rightMax = maxPathSumHelper(root.right); q.offer(rightMax &gt; 0 ? root.val + rightMax : root.val); return rightMax &gt; 0 ? root.val + rightMax : root.val; &#125; int leftMax = maxPathSumHelper(root.left); int rightMax = maxPathSumHelper(root.right); int valA = root.val; int valB = leftMax + root.val; int valC = rightMax + root.val; int valD = leftMax + root.val + rightMax; int tmpA = Math.max(valA, valB); int tmpB = Math.max(valC, valD); q.offer(Math.max(tmpA, tmpB)); return Math.max(tmpA, valC); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(120) Triangle]]></title>
    <url>%2F2019%2F09%2F06%2FLeetcode-120-Triangle%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 解法一道典型的动态规划题： 1dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + A[i][j] 具体代码如下： 12345678910111213141516171819202122232425class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int minRes = 0; Integer[][] dp = new Integer[triangle.size()][triangle.size()]; dp[0][0] = triangle.get(0).get(0); for (int i = 1; i &lt; triangle.size(); i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; if (j == 0) &#123; dp[i][j] = dp[i - 1][j] + triangle.get(i).get(j); &#125; else if (j == i) &#123; dp[i][j] = dp[i - 1][j - 1] + triangle.get(i).get(j); &#125; else &#123; dp[i][j] = (dp[i - 1][j - 1] &lt; dp[i - 1][j] ? dp[i - 1][j - 1] : dp[i - 1][j]) + triangle.get(i).get(j); &#125; &#125; &#125; minRes = dp[triangle.size() - 1][0]; for (int j = 0; j &lt;= triangle.size() - 1; j++) &#123; if (dp[triangle.size() - 1][j] &lt; minRes) &#123; minRes = dp[triangle.size() - 1][j]; &#125; &#125; return minRes; &#125;&#125; 看到网上的大佬可以把二维降成一维的解题：https://blog.csdn.net/fuxuemingzhu/article/details/82883187]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(119) Pascal Triangle II]]></title>
    <url>%2F2019%2F09%2F06%2FLeetcode-119-Pascal-Triangle-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle. Note that the row index starts from 0. In Pascal’s triangle, each number is the sum of the two numbers directly above it. Example: 12Input: 3Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O(k) extra space? 解法118题的变体，这里我先用递归写了一遍： 具体代码如下： 12345678910111213141516171819202122232425class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; if(rowIndex &lt; 0)&#123; return null; &#125; if(rowIndex == 0)&#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); res.add(1); return res; &#125; else&#123; List&lt;Integer&gt; lastRow = getRow(rowIndex - 1); List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt;= rowIndex; i++)&#123; if(i == 0 || i == rowIndex)&#123; res.add(1); &#125; else&#123; res.add(lastRow.get(i-1)+lastRow.get(i)); &#125; &#125; return res; &#125; &#125;&#125; 在网上看到有更妙的解法： 12345678910111213 public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (rowIndex &lt; 0) return list; for (int i = 0; i &lt; rowIndex + 1; i++) &#123; list.add(0, 1); for (int j = 1; j &lt; list.size() - 1; j++) &#123; list.set(j, list.get(j) + list.get(j + 1)); &#125; &#125; return list;&#125; 在0的位置添上1：[1]，此时为第一行，不满足则继续；不执行小循环，继续0的位置添上1：[1，1]，此时为第二行，不满足则继续；不执行小循环，继续0的位置添上1：[1，1，1]，执行小循环，得[1，2，1]，此时为第三行，不满足则继续；此时继续0的位置添上1：[1，1，2，1]，执行小循环，得[1，3，3，1]，此时为第四行，不满足则继续；…… 这样下去确实可以得到每一行的数据，其实就是在一个List内模拟杨辉三角的性质，确实很赞。原文链接：https://blog.csdn.net/Cloudox_/article/details/52993117]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(118) Pascal Triangle]]></title>
    <url>%2F2019%2F09%2F06%2FLeetcode-118-Pascal-Triangle%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a non-negative integer numRows, generate the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it. Example: 123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 解法找到计算公式即可： 1234if j == 0 or i == j: A[i][j] = 1else: A[i][j] = A[i-1][j-1] + A[i-1][j] 具体代码如下： 1234567891011121314151617class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0;i &lt; numRows; i++)&#123; List&lt;Integer&gt; tmpRow = new ArrayList&lt;Integer&gt;(); tmpRow.add(1); for(int j = 1;j &lt; i;j++)&#123; tmpRow.add(res.get(i-1).get(j-1) + res.get(i-1).get(j)); &#125; if(i &gt;= 1)&#123; tmpRow.add(1); &#125; res.add(tmpRow); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(117) Populating Next Right Pointers in Each Node II]]></title>
    <url>%2F2019%2F09%2F05%2FLeetcode-117-Populating-Next-Right-Pointers-in-Each-Node-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example: Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. 解法116题的改版，只需要在连接前遍历父节点层找到下一个邻接节点即可，注意递归的时候应该先递归右边的部分，确保右边的next已经完全连上了，否则会导致结果的错误（在这个坑里WA了半天才想明白）。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public Node connect(Node root) &#123; if(root == null)&#123; return null; &#125; if(root.left != null)&#123; if(root.right != null)&#123; root.left.next = root.right; &#125; else&#123; Node tmp = root; while(tmp.next != null)&#123; if(tmp.next.left != null)&#123; root.left.next = tmp.next.left; break; &#125; else if(tmp.next.right != null)&#123; root.left.next = tmp.next.right; break; &#125; else&#123; tmp = tmp.next; &#125; &#125; &#125; &#125; if(root.right != null)&#123; Node tmp = root; while(tmp.next != null)&#123; if(tmp.next.left != null)&#123; root.right.next = tmp.next.left; break; &#125; else if(tmp.next.right != null)&#123; root.right.next = tmp.next.right; break; &#125; else&#123; tmp = tmp.next; &#125; &#125; &#125; connect(root.right); connect(root.left); return root; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(116) Populating Next Right Pointers in Each Node]]></title>
    <url>%2F2019%2F09%2F05%2FLeetcode-116-Populating-Next-Right-Pointers-in-Each-Node%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example: Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. 解法最开始没看到空间的要求，采用了两个队列按层遍历二叉树得到了结果 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val,Node _left,Node _right,Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if(root == null)&#123; return null; &#125; Queue&lt;Node&gt; currentLevelQueue = new LinkedList&lt;Node&gt;(); Queue&lt;Node&gt; nextLevelQueue = new LinkedList&lt;Node&gt;(); Node tmpNode = root; currentLevelQueue.offer(root); while(currentLevelQueue.size() != 0)&#123; tmpNode = currentLevelQueue.poll(); if(tmpNode.left != null)&#123; nextLevelQueue.offer(tmpNode.left); nextLevelQueue.offer(tmpNode.right); &#125; if(currentLevelQueue.size() == 0)&#123; tmpNode.next = null; Queue&lt;Node&gt; tmpq; tmpq = currentLevelQueue; currentLevelQueue = nextLevelQueue; nextLevelQueue = tmpq; &#125; else&#123; Node nextNode = currentLevelQueue.element(); tmpNode.next = nextNode; &#125; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Class 文件详解]]></title>
    <url>%2F2019%2F09%2F05%2FJava%20Class%20%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[转载于： https://windysha.github.io/2018/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8BJava%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88-class%EF%BC%89%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/ 什么是Class文件Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。它是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间（方便于网络的传输）。 Java源文件在被Java编译器编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活， 它甚至比Java源文件有着更强的描述能力。 class文件中的信息是一项一项排列的， 每项数据都有它的固定长度， 有的占一个字节， 有的占两个字节， 还有的占四个字节或8个字节， 数据项的不同长度分别用u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节。 可以把u1, u2, u3, u4看做class文件数据项的“类型” 。 Class文件的结构一个典型的class文件分为：MagicNumber，Version，Constant_pool，Access_flag，This_class，Super_class，Interfaces，Fields，Methods 和Attributes这十个部分，用一个数据结构可以表示如下： 1、magic在class文件开头的四个字节， 存放着class文件的魔数， 这个魔数是class文件的标志，他是一个固定的值： 0XCAFEBABE 。 也就是说他是判断一个文件是不是class格式的文件的标准， 如果开头四个字节不是0XCAFEBABE， 那么就说明它不是class文件， 不能被JVM识别。 2、minor_version 和 major_version紧接着魔数的四个字节是class文件的此版本号和主版本号。随着Java的发展， class文件的格式也会做相应的变动。 版本号标志着class文件在什么时候， 加入或改变了哪些特性。 举例来说， 不同版本的javac编译器编译的class文件， 版本号可能不同， 而不同版本的JVM能识别的class文件的版本号也可能不同， 一般情况下， 高版本的JVM能识别低版本的javac编译器编译的class文件， 而低版本的JVM不能识别高版本的javac编译器编译的class文件。 如果使用低版本的JVM执行高版本的class文件， JVM会抛出java.lang.UnsupportedClassVersionError 。具体的版本号变迁这里不再讨论， 需要的读者自行查阅资料。 3、constant_pool在class文件中， 位于版本号后面的就是常量池相关的数据项。 常量池是class文件中的一项非常重要的数据。 常量池中存放了：文字字符串，常量值，当前类的类名(全限定名。在源文件中的全限定名是java.lang.Object 。 而class文件中的全限定名是将点号替换成“/” 。 例如， Object类在class文件中的全限定名是 java/lang/Object )，字段名(Java中的属性(property)，通常可以理解为get和set方法，而字段(field)，通常叫做“类成员”，或 “类成员变量”，有时也叫“域”，理解为“数据成员”，用来承载数据的），方法名，各个字段和方法的描述符，对当前类的字段和方法的引用信息，当前类中对其他类的引用信息 常量池中几乎包含类中的所有信息的描述， class文件中的很多其他部分都是对常量池中的数据项的引用，比如后面要讲到的this_class, super_class, field_info, attribute_info等， 另外字节码指令中也存在对常量池的引用， 这个对常量池的引用当做字节码指令的一个操作数。此外，常量池中各个项也会相互引用。 常量池是一个类的结构索引，其它地方对“对象”的引用可以通过索引位置来代替，我们知道在程序中一个变量可以不断地被调用，要快速获取这个变量常用的方法就是通过索引变量。这种索引我们可以直观理解为“内存地址的虚拟”。我们把它叫静态池的意思就是说这里维护着经过编译“梳理”之后的相对固定的数据索引，它是站在整个JVM（进程）层面的共享池。 class文件中的项constant_pool_count的值为1, 说明每个类都只有一个常量池。 常量池中的数据也是一项一项的， 没有间隙的依次排放。常量池中各个数据项通过索引来访问， 有点类似与数组， 只不过常量池中的第一项的索引为1, 而不为0, 如果class文件中的其他地方引用了索引为0的常量池项， 就说明它不引用任何常量池项。class文件中的每一种数据项都有自己的类型， 相同的道理，常量池中的每一种数据项也有自己的类型。 常量池中的数据项的类型如下表： 每个数据项叫做一个XXX_info项，比如，一个常量池中一个CONSTANT_Utf8类型的项，就是一个CONSTANT_Utf8_info 。除此之外， 每个info项中都有一个标志值（tag），这个标志值表明了这个常量池中的info项的类型是什么， 从上面的表格中可以看出，一个CONSTANT_Utf8_info中的tag值为1，而一个CONSTANT_Fieldref_info中的tag值为9 。 4、access_flag 保存了当前类的访问权限 5、this_cass 保存了当前类的全局限定名在常量池里的索引 6、super class 保存了当前类的父类的全局限定名在常量池里的索引 7、interfaces 保存了当前类实现的接口列表，包含两部分内容：interfaces_count 和interfaces[interfaces_count]interfaces_count 指的是当前类实现的接口数目interfaces[] 是包含interfaces_count个接口的全局限定名的索引的数组 8、fields 保存了当前类的成员列表，包含两部分的内容：fields_count 和 fields[fields_count]fields_count是类变量和实例变量的字段的数量总和。fileds[]是包含字段详细信息的列表。 9、methods 保存了当前类的方法列表，包含两部分的内容：methods_count和methods[methods_count]methods_count是该类或者接口显示定义的方法的数量。method[]是包含方法信息的一个详细列表。 10、attributes 包含了当前类的attributes列表，包含两部分内容：attributes_count 和 attributes[attributes_count]class文件的最后一部分是属性，它描述了该类或者接口所定义的一些属性信息。attributes_count指的是attributes列表中包含的attribute_info的数量。 属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；如果出现在fileds的某一项里，那么它就是对该字段额外信息的描述；如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(114) Flatten Binary Tree to Linked List]]></title>
    <url>%2F2019%2F09%2F03%2FLeetcode-114-Flatten-Binary-Tree-to-Linked-List%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \ 2 5 / \ \3 4 6 The flattened tree should look like: 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 解法刚开始没弄明白原地展开是什么鬼，意思是把树的左边往右边合并，思路是递归地解决问题，采用头递归地写法更好理解，首先对跟节点的左右子树分别递归地进行展开，得到的情况如下图所示： 1234567 1 / \2 5 \ \ 3 6 \ 4 之后在把根的左子树设为空，并找到原左子树的最下节点与右子树接上即可。 具体代码如下： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; if(root == null)&#123; return; &#125; if(root.left != null)&#123; flatten(root.left); &#125; if(root.right != null)&#123; flatten(root.right); &#125; TreeNode tmp = root.right; root.right = root.left; root.left = null; while(root.right != null)&#123; root = root.right; &#125; root.right = tmp; &#125; &#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(200) Number of Islands]]></title>
    <url>%2F2019%2F03%2F14%2FLeetcode-200-Number-of-Islands%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 1234567Input:11110110101100000000Output: 1 Example 2: 1234567Input:11000110000010000011Output: 3 解法典型的地图遍历题，这里可以通过BFS和DFS解题。 BFS: 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int numIslands(char[][] grid) &#123; int res = 0; int[] dirx = &#123;1, -1, 0, 0&#125;; int[] diry = &#123;0, 0, 1, -1&#125;; for (int i = 0; i &lt; grid.length; i++) for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == '1') &#123; Queue&lt;node&gt; q = new LinkedList(); q.offer(new node(i, j)); while (!q.isEmpty()) &#123; node now = q.poll(); grid[now.x][now.y] = '0'; for (int ii = 0; ii &lt; 4; ii++) &#123; int nextx = now.x + dirx[ii]; int nexty = now.y + diry[ii]; if (nextx &gt;= 0 &amp;&amp; nextx &lt; grid.length &amp;&amp; nexty &gt;= 0 &amp;&amp; nexty &lt; grid[0].length) &#123; if (grid[nextx][nexty] == '1') &#123; node next = new node(nextx, nexty); grid[next.x][next.y] = '0'; q.offer(next); &#125; &#125; &#125; &#125; res++; &#125; &#125; return res; &#125;&#125;class node &#123; int x; int y; node(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125; 特别注意需要再新点入队前将地图中的值置0以避免重复访问死循环！！！ DFS递归解法： 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int numIslands(char[][] grid) &#123; int res = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == '1') &#123; DFS(grid, i, j); res++; &#125; &#125; &#125; return res; &#125; void DFS(char[][] grid, int x, int y) &#123; int[] dirx = &#123;1, -1, 0, 0&#125;; int[] diry = &#123;0, 0, 1, -1&#125;; if (grid[x][y] == '1') &#123; grid[x][y] = 0; for (int i = 0; i &lt; 4; i++) &#123; int nextx = x + dirx[i]; int nexty = y + diry[i]; if (nextx &gt;= 0 &amp;&amp; nextx &lt; grid.length &amp;&amp; nexty &gt;= 0 &amp;&amp; nexty &lt; grid[0].length) &#123; if (grid[nextx][nexty] == '1') &#123; DFS(grid, nextx, nexty); &#125; &#125; &#125; &#125; return; &#125;&#125; DFS 栈解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public int numIslands(char[][] grid) &#123; int res = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == '1') &#123; DFS(grid, i, j); res++; &#125; &#125; &#125; return res; &#125; void DFS(char[][] grid, int x, int y) &#123; int[] dirx = &#123;1, -1, 0, 0&#125;; int[] diry = &#123;0, 0, 1, -1&#125;; Stack&lt;node&gt; s = new Stack&lt;&gt;(); s.push(new node(x, y)); grid[x][y] = '0'; while (!s.isEmpty()) &#123; node tmp = s.peek(); int flag = 0; for (int i = 0; i &lt; 4; i++) &#123; int nextx = tmp.x + dirx[i]; int nexty = tmp.y + diry[i]; if (nextx &gt;= 0 &amp;&amp; nextx &lt; grid.length &amp;&amp; nexty &gt;= 0 &amp;&amp; nexty &lt; grid[0].length) &#123; if (grid[nextx][nexty] == '1') &#123; grid[nextx][nexty] = '0'; s.push(new node(nextx, nexty)); flag = 1; &#125; &#125; &#125; if (flag == 0) &#123; s.pop(); &#125; &#125; return; &#125;&#125;class node &#123; int x; int y; node(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125; 同样注意标0的时机。]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的基本数据结构]]></title>
    <url>%2F2019%2F02%2F28%2FJava%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Java数组Java数组定义与初始化的几种方式:1234int[] array1 = &#123;1,2,3,4&#125;;int[][] array2 = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;int[] array3 = new int[5];int[][] array4 = new int[2][3]; 关于默认初始化： 1.基本数据类型的数组在创建之后，已经赋默认值 0 （或0L、0.0D、0.0F）；2.引用类型的数组在创建之后，已经赋默认值null.3.boolean类型默认值为false，Integer类型为null. Java获取数组各维度的长度： 12System.out.println(array1.length);System.out.println(array2[0].length); Java for-each遍历数组：123for(int x: array1)&#123; System.out.println(x);&#125; Java 数组作为函数参数: 传递的是数组的引用，相当于C中的指针 1234567891011void test(int[] a) &#123; a[1] = 5; return;&#125;//main:int[] array1 = &#123;1, 2, 3, 4&#125;;System.out.println(array1[1]);//print 2m.test(array1);System.out.println(array1[1]);//print 5 java数组的比较： 1234567891011int[] array1 = &#123;1, 2, 3, 4&#125;;int[] array2 = &#123;1, 2, 3, 4&#125;;int[] array3 = array1;System.out.println(array1 == array2);//false == 比较地址System.out.println(array1.equals(array2)); //false 基本的数据类型的数组的equals方法没有重载Object的equals方法，所以跟“==”效果一样 System.out.println(Arrays.equals(array1,array2));//此时返回者为true，Arrays重写了equalsSystem.out.println(array3 == array1);//此时返回true，二者地址一样 java数组与List的转换(并没有更好的方法)： 1234List&lt;Integer&gt; l = new ArrayList&lt;&gt;();for(int x : array1)&#123; l.add(x);&#125; java数组的排序： 12345678910111213141516171819//升序排序Arrays.sort(array2);//指定排序的index区间，左包右不包//output：[4，1，2，3]int[] array2 = &#123;4,3,2,1&#125;;Arrays.sort(array2,1,4);//自定义Comparatorpeople[] array5 = new people[4]；Arrays.sort(array5, new Comparator&lt;people&gt;() &#123; @Override public int compare(people a, people b) &#123; return Integer.compare(a.age, b.age); &#125;&#125;);//更简单的写法Arrays.sort(array5, (a, b) -&gt; Integer.compare(a.age, b.age));//降序排序//没有直接的方法，拍完倒着输出即可 Java集合框架整体结构： ArrayListList接口是Collection的子接口，用于定义线性表结构，其中ArrayList可以理解为一个动态数组，而LinkedList可以理解为一个链表。 ArrayList的基本操作： 12345678910111213141516171819202122232425262728List&lt;Integer&gt; l = new ArrayList&lt;&gt;();//插入l.add(1);l.add(2);l.add(3);l.add(4);l.add(5);//获取指定位置元素System.out.println(l.get(1));//设置指定位置元素l.set(1,11);System.out.println(l);l.set(1,2);//删除指定元素(如果是int型的一定要标明数据类型为Integer),只删除第一个找到的System.out.println(l);l.remove((Integer) 2);System.out.println(l);//删除指定位置元素(传入的值应该标名为(int)类型)l.remove(2);System.out.println(l);//获取子List,index范围同样左包右不包System.out.println(l.subList(1,3));//获取list长度System.out.println(l.size());//获取指定元素的index,没有时返回-1l.indexOf(3);//判断list是否为空l.isEmpty() ArrayList排序： 1234567891011//升序排序Collections.sort(l);//降序排序Collections.sort(l,Collections.reverseOrder());//自定义类型重写Comparator接口中的compare方法 Collections.sort(l, new Comparator&lt;people&gt;() &#123; @Override public int compare(people o1, people o2) &#123; return Integer.compare(o1.age, o2.age); &#125;&#125;); HashSetHashSet不能添加重复的元素，当调用add（Object）方法时候，首先会调用Object的hashCode方法判hashCode是否已经存在，如不存在则直接插入元素； 如果已存在则调用Object对象的equals方法判断是否返回true， 如果为true则说明元素已经存在，如为false则插入元素。 先来看看基本数据类型的HashSet实现： 1234567891011121314151617181920212223HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();//添加元素hs.add(1);hs.add(2);hs.add(3);hs.add(3);//hs: [1,2,3]，顺序随机System.out.println(hs);//是否存在某元素System.out.println(hs.contains(3));//删除元素hs.remove(2);System.out.println(hs);//获取set大小System.out.println(hs.size());//两种遍历的方式for(int xx:hs)&#123; System.out.println(xx);&#125;Iterator it = hs.iterator();while (it.hasNext())&#123; System.out.println(it.next());&#125; 对于自定义数据类型的HashSet，需要在类中重写hashCode方法和equals方法，用以判断传入集合的元素是否已经存在。 123456789101112131415161718192021222324class people&#123; public int age; public String name; people(int age,String name) &#123; this.age = age; this.name = name; &#125; @Override public int hashCode()&#123; return this.name.hashCode(); &#125; @Override public boolean equals(Object obj)&#123; if(this == obj) return true; if(obj!=null &amp;&amp; obj instanceof people)&#123; people p1 = (people) obj; if(this.name.equals(p1.name))&#123; return true; &#125; &#125; return false; &#125;&#125; HashMap存储键值对采用HashMap实现，具体的方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142HashMap&lt;Integer,String&gt; hm = new HashMap&lt;&gt;();//添加元素hm.put(1,"aa");hm.put(2,"bb");hm.put(3,"aa");//判断是否存在键或值System.out.println(hm.containsKey(4));System.out.println(hm.containsValue("aa"));System.out.println(hm);//&#123;1=aa, 2=bb, 3=aa&#125;//采用put方法如果已存在键会覆盖hm.put(3,"bb");System.out.println(hm);//&#123;1=aa, 2=bb, 3=bb&#125;//不想覆盖可采用以下方法hm.putIfAbsent(3,"aa");System.out.println(hm);//&#123;1=aa, 2=bb, 3=bb&#125;//获取键对应的值System.out.println(hm.get(3));//删除给出键的键值对hm.remove(3);System.out.println(hm);//更新键值对hm.replace(2,"cc");System.out.println(hm);//获取键的集合Set&lt;Integer&gt; ks = hm.keySet();System.out.println(ks);//第一种遍历的方法，获取键的Set，构造迭代器Iterator it = ks.iterator();while(it.hasNext())&#123; int i = (int)it.next(); System.out.println(hm.get(i));&#125;//第二种遍历的方法，获取键值对的entry集合，获取各entry的键与值Iterator it1 = hm.entrySet().iterator();while(it1.hasNext())&#123; Map.Entry entry = (Map.Entry) it1.next(); System.out.println(entry.getKey()); System.out.println(entry.getValue());&#125; Java队列与栈栈java中的栈是Vector的一个子类，它实现了一个标准的后进先出的栈 123456789101112131415//栈的定义Stack&lt;Integer&gt; s = new Stack&lt;&gt;();//入栈s.push(1);s.push(2);//获取栈顶元素,但不出栈peek = s.peek();//弹出栈顶元素，出栈peek = s.pop();//判断栈是否为空System.out.println(s.isEmpty());//获取栈中元素的个数System.out.println(s.size());//栈中的其他元素可以通过get方法使用下标访问System.out.println(s.get(0)); 队列LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。 1234567891011121314//对列的定义Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();//向队列中添加元素q.offer(1);q.offer(2);q.offer(4);//获得队首元素，但不出队int first = q.element();//获得队首元素，出队first = q.poll();//判读队列是否为空System.out.println(q.isEmpty());//获取队列中元素的个数System.out.println(q.size()); 优先队列PriorityQueue是一种基于优先级堆的优先级队列。如果不提供Comparator的话，优先队列中元素默认按自然顺序排列，也就是数字默认是小的在队列头，字符串则按字典序排列，也可以根据 Comparator 来指定，这取决于使用哪种构造方法。优先级队列不允许 null 元素。依靠自然排序的优先级队列还不允许插入不可比较的对象（这样做可能导致 ClassCastException） 123456789101112131415161718192021//定义优先队列，指定队列初始大小(可选)，并自定义排序顺序(可选)，这个例子中是按照降序排序Queue&lt;Integer&gt; qq = new PriorityQueue&lt;&gt;(3, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2-o1; &#125;&#125;);//向队列中添加元素qq.offer(3);qq.offer(4);qq.offer(2);qq.offer(1);//[4, 3, 2, 1]System.out.println(qq);//4System.out.println(qq.element());//4,但队首出队System.out.println(qq.poll());qq.offer(5);//[5, 3, 2, 1]System.out.println(qq); Java比较器Comparable接口如果一个类中已经实现了Comparable接口，可以直接使用java.util.Arrays类，Collections类，优先队列等进行数组的排序操作。 Comparable接口的定义如下：123456789public interface Comparable&lt;T&gt;&#123; public int compareTo(T o);&#125;/*此方法返回一个int类型的数据，但是此int的值只能是一下三种：1：表示大于-1：表示小于0：表示相等*/ 给出一个具体的例子: 12345678910111213141516class people implements Comparable&lt;people&gt;&#123; public int age; @Override public int compareTo(people a1) &#123; if(this.age&lt;a1.age)&#123; return -1; &#125; else if(this.age&gt;a1.age)&#123; return 1; &#125; return 0; &#125; people(int age)&#123; this.age = age; &#125;&#125; 在此例子中，我们可以根据age来定义people的大小关系，比如如果a的age小于a1的age，则定义people a小于people a1(在返回值上反应为-1)。 如果建立people的优先队列，则优先队列的内部情况如下： 123456people a = new people(1);people b = new people(2);Queue&lt;people&gt; qqq = new PriorityQueue&lt;&gt;();qqq.offer(b);qqq.offer(a);//qqq:[a,b] Comparator接口如果一个类已经开发完成，但是在此类建立的初期并没有实现Comparable接口，此时肯定是无法进行对象排序操作的，所以为了解决这一的问题，java又定义了另一个比较器的操作接口 Comparator 此接口定义在java.util包中，它的定义为： 12345678910public interface Comparator&lt;T&gt;&#123; public int compare(T o1，T o2); /* 此方法返回一个int类型的数据，但是此int的值只能是一下三种： 1：表示o1大于o2 -1：表示o1小于o2 0：表示相等 */ boolean equals(Object obj);&#125; Java字符串String字符串常量池String类是我们平常项目中使用频率非常高的一种对象类型，jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池，当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符创常量池中。 基本操作String类中使用字符数组保存字符串，因为有“final”修饰符，所以可以知道string对象是不可变的。可选的创建方式有直接赋值和new两种方式 使用String直接赋值：String str = “abc”;可能创建一个或者不创建对象，如果”abc”在字符串池中不存在，会在java字符串池中创建一个String对象（”abc”），然后str指向这个内存地址，无论以后用这种方式创建多少个值为”abc”的字符串对象，始终只有一个内存地址被分配。==判断的是对象的内存地址，而equals判断的是对象内容。通过以下代码测试： 123456789101112String str = "abc";String str1 = "abc";String str2 = "abc";System.out.println(str==str1);//trueSystem.out.println(str==str2);//trueString str = "abc";//在常量池中创建abcString str1 = "abcd";//在常量池中创建abcdString str2 = str+"d";//拼接字符串，此时会在堆中新建一个abcd的对象，因为str2编译之前是未知的String str3 = "abc"+"d";//拼接之后str3还是abcd，所以还是会指向字符串常量池的内存地址System.out.println(str1==str2);//falseSystem.out.println(str1==str3);//trueSystem.out.println(str3==str2);//false 使用new String 创建字符串: String str2 = new String(“ABC”);至少创建一个对象，也可能两个。因为用到new关键字，肯定会在heap中创建一个str2的String对象，它的value是“ABC”。同时如果这个字符串再java String池里不存在，会在java池里创建这个String对象“ABC”。 123456String str = new String("abc");String str1 = new String("abc");String str2 = new String("abc");System.out.println(str==str1);//falseSystem.out.println(str==str2);//falseSystem.out.println(str1==str2);//false 建议在平时的使用中，尽量使用String = “abcd”;这种方式来创建字符串，而不是String = new String(“abcd”);这种形式，因为使用new构造器创建字符串对象一定会开辟一个新的heap空间，而双引号则是采用了String interning(字符串驻留)进行了优化，效率比构造器高。 与其他类型的转换String转基本数据类型：一般可以直接调用各数据类型包装类的方法： 123String x = "123";int i = Integer.parseInt(x);float j = Float.parseFloat(x); 基本数据类型转String：一般也可以直接调用各数据类型包装类的方法： 1234int i = 1;String x = Integer.toString(i);String y = String.valueOf(i);//第二种更安全，可以处理null值 其他常用方法123456789101112131415String test = "123xyz";//获取字符串长度int length = test.length();//转化成char型数组char[] mystr = test.toCharArray();//获得指定字符的第一次出现的位置System.out.println(test.indexOf('3'));//获取子字符串，左包右不包String newstr = test.substring(0,3);System.out.println(newstr);//替代所有指定字符，返回替代后的新字符串用I换1System.out.println(newstr.replace('1','I'));//根据正则表达式替换所有匹配的字符串，用45替换23newstr = newstr.replaceAll("23","45");System.out.println(newstr); StringBuffer使用StringBuffer的目的在于String的内容不可更改，而它可以。 123456789101112131415//新建StringBuffer类StringBuffer sb = new StringBuffer("123xyz");//StringBuffer与String的转换System.out.println(sb.toString());//在字符串末尾添加字符sb.append("456");System.out.println(sb.toString());//获取字符串的长度System.out.println(sb.length());//在指定index后插入字符(“uvw123xyz456”)sb.insert(0,"uvw");System.out.println(sb.toString());//替换(这里替换为空就是删除)指定index间的字符(左包右不包，这里删除了w(index = 2))sb.replace(2,3,"");System.out.println(sb.toString()); 类似于StringBuffer的还有StringBuilder。 在字符缓冲区被单个线程使用时优先考虑使用StringBuilder()，效率更高。但StringBuffer对于多线程是安全的。]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(113) Path Sum II]]></title>
    <url>%2F2019%2F01%2F28%2FLeetcode-113-Path-Sum-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 Return: 1234[ [5,4,11,2], [5,8,4,5]] 解法与之前的题目类似，不过需要记录路径，同样采用递归的方法解题，注意list中元素为整型时的删除操作，这里采用index的方式删除，如果对应元素删除的话需转换成Integer类型。 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; if (root == null) return res; findpath(root, sum, 0, new ArrayList&lt;&gt;()); return res; &#125; void findpath(TreeNode root, int sum, int now, List&lt;Integer&gt; tmp) &#123; if (root == null) &#123; return; &#125; now = now + root.val; tmp.add(root.val); if (root.left == null &amp;&amp; root.right == null) &#123; if (now == sum) &#123; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); for (int node : tmp) &#123; path.add(node); &#125; res.add(path); &#125; tmp.remove(tmp.size() - 1); return; &#125; findpath(root.left, sum, now, tmp); findpath(root.right, sum, now, tmp); tmp.remove(tmp.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(112) Path Sum]]></title>
    <url>%2F2019%2F01%2F28%2FLeetcode-112-Path-Sum%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 解法递归地解这道题，注意空节点的处理。这里没有剪枝，因为值可能为负数 具体代码如下： 123456789101112131415161718class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; return pathsum(0, sum, root); &#125; Boolean pathsum(int now, int target, TreeNode node) &#123; if (node == null) return false; now = now + node.val; if (node.left == null &amp;&amp; node.right == null) &#123; if (now == target) return true; else return false; &#125; return pathsum(now, target, node.right) || pathsum(now, target, node.left); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(111) Minimum Depth of Binary Tree]]></title>
    <url>%2F2019%2F01%2F16%2FLeetcode-111-Minimum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its minimum depth = 2. 解法递归地计算最小深度，需要注意只有一个儿子的节点的节点的高度处理，根据定义，是左儿子深度或右儿子深度加1。 具体代码如下： 12345678910111213class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) return 0; if (root.left == null) return 1 + minDepth(root.right); if (root.right == null) return 1 + minDepth(root.left); int left = minDepth(root.left); int right = minDepth(root.right); return Math.min(left, right) + 1; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(110) Balanced Binary Tree]]></title>
    <url>%2F2019%2F01%2F16%2FLeetcode-110-Balanced-Binary-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 12345 3 / \9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1234567 1 / \ 2 2 / \ 3 3 / \4 4 Return false. 解法递归地求解树的高度，同时如果发现了左右子树高度差大于1的情况，直接返回高度为-1代表不平衡，节省计算时间。 具体代码如下： 123456789101112131415161718192021222324252627class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if (root == null) return true; int left = height(root.left); int right = height(root.right); if (left == -1 || right == -1) return false; if (Math.abs(left - right) &lt;= 1) &#123; return true; &#125; return false; &#125; Integer height(TreeNode root) &#123; if (root == null) return 0; int left = height(root.left); int right = height(root.right); if (left == -1 || right == -1) return -1; if (Math.abs(left - right) &lt;= 1) return Math.max(left, right) + 1; else return -1; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(109) Convert Sorted List to Binary Search Tree]]></title>
    <url>%2F2019%2F01%2F16%2FLeetcode-109-Convert-Sorted-List-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 解法 左右分别递归地建立子树即可，首先将链表转成list，其余方法与108题类似 具体代码如下： 123456789101112131415161718192021class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; List l = new ArrayList&lt;Integer&gt;(); while (head != null) &#123; l.add(head.val); head = head.next; &#125; return helper(l, 0, l.size() - 1); &#125; TreeNode helper(List nums, int start, int end) &#123; if (start &gt; end) &#123; return null; &#125; int val = (int) nums.get((start + end) / 2); TreeNode root = new TreeNode(val); root.left = helper(nums, start, (start + end) / 2 - 1); root.right = helper(nums, (start + end) / 2 + 1, end); return root; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(108) Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2019%2F01%2F16%2FLeetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 解法左右递归分别建树即可。注意终止条件的处理 具体代码如下： 123456789101112131415161718192021class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; List l = new ArrayList&lt;Integer&gt;(); for (int i : nums) &#123; l.add(i); &#125; return helper(l, 0, l.size() - 1); &#125; TreeNode helper(List nums, int start, int end) &#123; if (start &gt; end) &#123; return null; &#125; int val = (int) nums.get((start + end) / 2); TreeNode root = new TreeNode(val); root.left = helper(nums, start, (start + end) / 2 - 1); root.right = helper(nums, (start + end) / 2 + 1, end); return root; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(107) Binary Tree Level Order Traversal II]]></title>
    <url>%2F2019%2F01%2F16%2FLeetcode-107-Binary-Tree-Level-Order-Traversal-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] 解法遍历方法依然是从上往下遍历，但是存的时候需要对列表做一次翻转。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.offer(root); while (!q.isEmpty()) &#123; int size = q.size(); List&lt;Integer&gt; tmplist = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) &#123; TreeNode tmp = q.poll(); if (tmp.left != null) &#123; q.offer(tmp.left); &#125; if (tmp.right != null) &#123; q.offer(tmp.right); &#125; tmplist.add(tmp.val); &#125; res.add(tmplist); &#125; List&lt;List&lt;Integer&gt;&gt; finalres = new ArrayList&lt;&gt;(); for (int i = res.size() - 1; i &gt;= 0; i--) &#123; finalres.add(res.get(i)); &#125; return finalres; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(104) Maximum Depth of Binary Tree]]></title>
    <url>%2F2019%2F01%2F15%2FLeetcode-104-Maximum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its depth = 3. 解法我是按照按层遍历的方法解的这道题，就是利用队列size确定每层的个数，然后确定总的层数 具体代码如下： 1234567891011121314151617181920212223class Solution &#123; public int maxDepth(TreeNode root) &#123; int level = 0; if (root == null) return level; Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.offer(root); while (!q.isEmpty()) &#123; int size = q.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode tmp = q.poll(); if (tmp.left != null) &#123; q.offer(tmp.left); &#125; if (tmp.right != null) &#123; q.offer(tmp.right); &#125; &#125; level++; &#125; return level; &#125;&#125; 网上看到可以用递归解这题，确实，代码相当简洁 12345public class Solution &#123; public int maxDepth(TreeNode root) &#123; return root == null ? 0 : (1 + Math.max(maxDepth(root.left), maxDepth(root.right))); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(102) Binary Tree Level Order Traversal]]></title>
    <url>%2F2019%2F01%2F15%2FLeetcode-102-Binary-Tree-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] 解法借助队列可以实现按层遍历二叉树，对于每一层的处理，在处理每一层前记录队列的大小即可确定本层需要处理的节点的个数，这样不会让节点的插入影响处理过程。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) &#123; return res; &#125; int level = 1; Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.offer(root); List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); while (!q.isEmpty()) &#123; int size = q.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode tmpnode = q.poll(); tmp.add(tmpnode.val); if (tmpnode.left != null) &#123; q.offer(tmpnode.left); &#125; if (tmpnode.right != null) &#123; q.offer(tmpnode.right); &#125; &#125; res.add(tmp); tmp = new ArrayList&lt;&gt;(); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(101) Symmetric Tree]]></title>
    <url>%2F2019%2F01%2F14%2FLeetcode-101-Symmetric-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 / \ 2 2 / \ / \3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 / \2 2 \ \ 3 3 解法比较一棵二叉树是否为对称二叉树，即比较根节点的左右子树是否对称。在比较两棵树是否对称时，用递归的思想考虑，先比较根节点是否相等，然后再比较树1的左子树是否等于树2的右子树，树1的右子树是否等于树2的左子树。 具体代码如下： 1234567891011121314151617181920class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return helper(root.left, root.right); &#125; boolean helper(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) &#123; return true; &#125; else if (left != null &amp;&amp; right != null) &#123; if (left.val == right.val) &#123; return helper(left.left, right.right) &amp;&amp; helper(left.right, right.left); &#125; return false; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(93) Restore IP Addresses]]></title>
    <url>%2F2019%2F01%2F09%2FLeetcode-93-Restore-IP-Addresses%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string containing only digits, restore it by returning all possible valid IP address combinations. Example: 12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 解法暴力搜索三个点的位置，然后对分割后的ip进行检测即可。 注意check函数的写法 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); String ip1, ip2, ip3, ip4; if (s.length() &gt; 12) &#123; return res; &#125; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = i + 1; j &lt; s.length(); j++) &#123; for (int k = j + 1; k &lt; s.length() - 1; k++) &#123; ip1 = s.substring(0, i + 1); ip2 = s.substring(i + 1, j + 1); ip3 = s.substring(j + 1, k + 1); ip4 = s.substring(k + 1); if (check(ip1) &amp;&amp; check(ip2) &amp;&amp; check(ip3) &amp;&amp; check(ip4)) &#123; String ip = ip1 + "." + ip2 + "." + ip3 + "." + ip4; res.add(ip); &#125; &#125; &#125; &#125; return res; &#125; Boolean check(String ip) &#123; int val = Integer.parseInt(ip); if (ip.charAt(0) == '0') &#123; return ip.length() == 1; &#125; return val &lt;= 255; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(92) Reverse Linked List II]]></title>
    <url>%2F2019%2F01%2F09%2FLeetcode-92-Reverse-Linked-List-II%2F</url>
    <content type="text"><![CDATA[DescriptionReverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 解法基本的链表操作题，为解决对于链表头的处理，常在表头插入空项，即dummy指针。对于翻转链表，采用在链表头部插入的技术即可。 具体代码如下： 12345678910111213141516171819202122232425262728293031class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if (m == n || head == null) &#123; return head; &#125; ListNode dummy = new ListNode(-1); dummy.next = head; int cnt = 1; ListNode pre = dummy; ListNode next; ListNode tmp = head; ListNode inserthead; for (; cnt &lt; m; cnt++) &#123; pre = tmp; tmp = pre.next; &#125; inserthead = tmp; next = tmp.next; inserthead.next = null; ListNode tail = inserthead; for (; cnt &lt; n; cnt++) &#123; tmp = next; next = next.next; tmp.next = inserthead; inserthead = tmp; &#125; tail.next = next; pre.next = inserthead; return dummy.next; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(91) Decode Ways]]></title>
    <url>%2F2019%2F01%2F09%2FLeetcode-91-Decode-Ways%2F</url>
    <content type="text"><![CDATA[DescriptionA message containing letters from A-Z is being encoded to numbers using the following mapping: 1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: 123Input: &quot;12&quot;Output: 2Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12). Example 2: 123Input: &quot;226&quot;Output: 3Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6). 解法这道题首先考虑采用DFS解，但是发现有重叠子问题的情况，改用动态规划。数组dp[i]代表s[0,i-1]的解码个数情况。 对于到每一位为止的解码个数结果，分为4种情况考虑： 1.最后两位的结果大于等于10小于等于26（除10与20）： dp[i+1] = dp[i]+dp[i-1]（最后的两位可拆开解码） 2.最后两位为10或20 dp[i+1] = dp[i-1]（最后两位必须捆绑，等于i-2位的解码个数） 3.其他： dp[i+1] = dp[i]（最后两位必须解绑，等于i-1位的解码个数） 4.末尾为0且大于20，或为00： dp[i+1] = 0（无解） 可进行逻辑简化，具体代码如下： 12345678910111213141516171819class Solution &#123; public int numDecodings(String s) &#123; if (s.length() == 0 || s.charAt(0) == '0') &#123; return 0; &#125; int dp[] = new int[s.length() + 1]; dp[0] = dp[1] = 1; for (int i = 1; i &lt; s.length(); i++) &#123; int tmp = Integer.parseInt(s.substring(i - 1, i + 1)); if (tmp &gt;= 10 &amp;&amp; tmp &lt;= 26) &#123; dp[i + 1] += dp[i - 1]; &#125; if (tmp % 10 != 0) &#123; dp[i + 1] += dp[i]; &#125; &#125; return dp[s.length()]; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(90) Subsets II]]></title>
    <url>%2F2018%2F12%2F27%2FLeetcode-90-Subsets-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 12345678910Input: [1,2,2]Output:[ [2], [1], [1,2,2], [2,2], [1,2], []] 解法时间复杂度为O(2^n)次方，因为最多可能有2^n次方种可能的组合，所以遍历2^n次方次，每次根据对应2进制数的i位确定是否选取第i位的数，注意，list判断重复需要进行排序后再判断 具体代码如下： 12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; HashSet&lt;List&lt;Integer&gt;&gt; hs = new HashSet&lt;&gt;(); int len = nums.length; int x = (int) (Math.pow(2, len)); for (int i = 0; i &lt; x; i++) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); for (int j = i, k = 0; j &gt;= 1; j = j / 2, k++) &#123; if (j % 2 != 0) &#123; tmp.add(nums[k]); &#125; &#125; Collections.sort(tmp); if (!hs.contains(tmp)) &#123; hs.add(tmp); &#125; &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for (List&lt;Integer&gt; item : hs) &#123; res.add(item); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(89) Gray Code]]></title>
    <url>%2F2018%2F11%2F27%2FLeetcode-89-Gray-Code%2F</url>
    <content type="text"><![CDATA[DescriptionThe gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: 123456789101112131415Input: 2Output: [0,1,3,2]Explanation:00 - 001 - 111 - 310 - 2For a given n, a gray code sequence may not be uniquely defined.For example, [0,2,3,1] is also a valid gray code sequence.00 - 010 - 211 - 301 - 1 Example 2: 12345Input: 0Output: [0]Explanation: We define the gray code sequence to begin with 0. A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1. Therefore, for n = 0 the gray code sequence is [0]. 解法题意是每次只允许变动一位，根据给出的位数得到序列。我采用的是最原始的深度优先搜索算法，利用hash表不能重复的性质解这道题，每次在写深度优先搜索的时候注意回溯的处理。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;(); public List&lt;Integer&gt; grayCode(int n) &#123; int[] s = new int[n]; for (int i = 0; i &lt; n; i++) &#123; s[i] = 0; &#125; res.add(0); hs.add(0); helper(s); return res; &#125; void helper(int[] s) &#123; if (hs.size() &gt;= Math.pow(2, s.length)) &#123; return; &#125; int n = s.length; for (int i = 0; i &lt; n; i++) &#123; s[i] = 1 - s[i]; int t = trans(s); if (!hs.contains(t)) &#123; hs.add(t); res.add(t); if (hs.size() &gt;= Math.pow(2, s.length)) &#123; return; &#125; helper(s); &#125; s[i] = 1 - s[i]; &#125; &#125; int trans(int[] s) &#123; int res = 0; for (int i = 0; i &lt; s.length; i++) &#123; res += (s[i] * Math.pow(2, i)); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(82) Remove Duplicates from Sorted List II]]></title>
    <url>%2F2018%2F11%2F20%2FLeetcode-82-Remove-Duplicates-from-Sorted-List-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: 12Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5 Example 2: 12Input: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3 解法没啥好解释的，就设置三个指针值，一个指向前一个节点，一个指向当前节点，一个指向下一个节点，注意删除整个头部对head的影响。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return head; &#125; ListNode pre = head; ListNode now = head; ListNode next = head.next; while (next != null) &#123; if (now.val != next.val) &#123; pre = now; now = next; next = now.next; &#125; else &#123; while (next != null) &#123; if (now.val == next.val) &#123; now = next; next = now.next; &#125; else &#123; break; &#125; &#125; if (next != null) &#123; if (head.val == now.val) &#123; head = next; pre = head; now = head; next = head.next; &#125; else &#123; pre.next = next; now = pre.next; next = now.next; &#125; &#125; else &#123; if (head.val == now.val) &#123; head = null; &#125; else &#123; pre.next = next; &#125; &#125; &#125; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(81) Search in Rotated Sorted Array II]]></title>
    <url>%2F2018%2F11%2F20%2FLeetcode-81-Search-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[DescriptionSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: 12Input: nums = [2,5,6,0,0,1,2], target = 0Output: true Example 2: 12Input: nums = [2,5,6,0,0,1,2], target = 3Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? 解法这是之前那道在有序翻转数组中查找的加强版，唯一不同的是这里可能出现重复值，之前那题的方法为：如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的。而如果可以有重复值，就会出现来面两种情况，[3 1 1] 和 [1 1 3 1]，对于这两种情况中间值等于最右值时，目标值3既可以在左边又可以在右边，那怎么办么，对于这种情况其实处理非常简单，只要把最右值向左一位即可继续循环，如果还相同则继续移，直到移到不同值为止。其他的与之前那题完全一致。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution &#123; public boolean search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (target == nums[mid]) &#123; return true; &#125; if (nums[mid] &lt; nums[right]) &#123; if (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; else if (nums[mid] &gt; nums[right]) &#123; if (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else &#123; right--; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(80) Remove Duplicates from Sorted Array II]]></title>
    <url>%2F2018%2F11%2F20%2FLeetcode-80-Remove-Duplicates-from-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 12345Given nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 12345Given nums = [0,0,1,1,1,1,2,3,3],Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法采用多个指针解这道题，res标记下一个写入的位置，next表示下一个可能的写入的值的位置，pre标记当前已经写入的最后一个位置，cnt记录重复个数。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution &#123; public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int res = 1; int pre = 0; int next = 1; int cnt = 1; for (; next &lt; nums.length; next++) &#123; if (nums[pre] != nums[next]) &#123; pre = res; nums[res] = nums[next]; res++; cnt = 1; &#125; else &#123; if (cnt == 2) &#123; continue; &#125; else &#123; pre = res; nums[res] = nums[next]; res++; cnt++; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(79) Word Search]]></title>
    <url>%2F2018%2F11%2F20%2FLeetcode-79-Word-Search%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: 12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 解法典型的DFS搜索题，以矩阵的每一个点为起点进行搜索，知道找到匹配项或者矩阵搜索完成，注意不能重复访问点，所以采用一个数组记录是否该点被访问过，还有回溯的写法，搜索完成后重新将点标记为未访问状态。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; int[] diri = &#123;0, 0, 1, -1&#125;; int[] dirj = &#123;1, -1, 0, 0&#125;; public boolean exist(char[][] board, String word) &#123; if (board.length == 0) &#123; return false; &#125; int[][] visited = new int[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; Boolean res = DFS(board, i, j, word, 0, visited); if (res == true) &#123; return true; &#125; &#125; &#125; return false; &#125; Boolean DFS(char[][] board, int i, int j, String word, int start, int[][] visited) &#123; if (board[i][j] != word.charAt(start)) &#123; return false; &#125; if (start == word.length() - 1) &#123; return true; &#125; visited[i][j] = 1; for (int dir = 0; dir &lt; 4; dir++) &#123; int nexti = i + diri[dir]; int nextj = j + dirj[dir]; if (nexti &gt;= 0 &amp;&amp; nexti &lt; board.length &amp;&amp; nextj &gt;= 0 &amp;&amp; nextj &lt; board[0].length &amp;&amp; visited[nexti][nextj] == 0) &#123; if (DFS(board, nexti, nextj, word, start + 1, visited)) &#123; return true; &#125; &#125; &#125; visited[i][j] = 0; return false; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(78) Subsets]]></title>
    <url>%2F2018%2F11%2F20%2FLeetcode-78-Subsets%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解法这道题与之前combination那题基本解法一样，采用深度优先遍历，用开始参数向后搜索确保不重复，注意搜索完成后的回溯。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; int n = nums.length; for (int i = 0; i &lt;= n; i++) &#123; helper(nums, 0, i); &#125; return res; &#125; void helper(int[] nums, int start, int len) &#123; if (tmp.size() == len) &#123; List&lt;Integer&gt; add = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; tmp.size(); i++) &#123; add.add(tmp.get(i)); &#125; res.add(add); return; &#125; for (int i = start; i &lt; nums.length; i++) &#123; tmp.add(nums[i]); helper(nums, i + 1, len); tmp.remove((Integer) nums[i]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(77) Combinations]]></title>
    <url>%2F2018%2F11%2F19%2FLeetcode-77-Combinations%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two integers n and k, return all possible combinations of k numbers out of 1 … n. Example: 12345678910Input: n = 4, k = 2Output:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解法典型的深度优先搜索题，采用递归写就好了，start标记从start开始向后做选择，当搜索完成helper返回后注意回溯。 具体代码如下： 12345678910111213141516171819202122232425class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; helper(n, k, 1); return res; &#125; void helper(int n, int k, int start) &#123; if (tmp.size() == k) &#123; List&lt;Integer&gt; a = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; tmp.size(); i++) &#123; a.add(tmp.get(i)); &#125; res.add(a); return; &#125; for (int i = start; i &lt;= n; i++) &#123; tmp.add(i); helper(n, k, i + 1); tmp.remove((Integer) i); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(85) Maximal Rectangle]]></title>
    <url>%2F2018%2F11%2F18%2FLeetcode-85-Maximal-Rectangle%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. Example: 12345678Input:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]Output: 6 解法我们先从只有一行的矩阵来看。 ​ 1 0 1 1 1 0 0 1 1 1 1 如果我们把上面数字都理解成bar的高度，每个bar宽度为1， 那么上面这一行矩阵不就是84题么？！只有一行的矩阵，其实和84题的情况是等价的。换句话说， 84题是退化成一行矩阵情况的85题！ 那么， 既然84题是退化成一行的，我们应该有个直觉， 那就是85题可以对每一行执行一次84题的算法， 最终应该能算出最大面积来！ 对每一行计算，自然计算出的就是这一行里的最大面积。 要计算全部呢？简单， 如果当前行 j 位仍然是1，那么height[j]++。否则height[j]更新为0，只要矩形无法连续， 那之前的结果也不应参与当前行的计算。 比如上面一行， 经过84题算法， 得出最面积为4. 再来第二行： ​ 1 0 1 1 1 0 0 1 1 1 1 ​ 0 1 0 0 1 1 1 1 1 1 1 到第二行的时候， 我们的矩阵其实经过加和变为了： 0 1 0 0 2 1 1 2 2 2 2, 那么通过84题算法可以轻松算出最大面积为8。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; if (matrix.length == 0) &#123; return 0; &#125; int[] tmp = new int[matrix[0].length]; for (int i = 0; i &lt; matrix[0].length; i++) &#123; tmp[i] = matrix[0][i] - '0'; &#125; int res = largestRectangleArea(tmp); for (int i = 1; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; if (matrix[i][j] == '0') &#123; tmp[j] = 0; &#125; else &#123; tmp[j] = matrix[i][j] - '0' + tmp[j]; &#125; &#125; res = Math.max(res, largestRectangleArea(tmp)); &#125; return res; &#125; int largestRectangleArea(int[] heights) &#123; int res = 0; Stack&lt;Integer&gt; s = new Stack(); int[] h = new int[heights.length + 1]; for (int i = 0; i &lt; h.length; i++) &#123; if (i &lt; heights.length) &#123; h[i] = heights[i]; &#125; else &#123; h[i] = 0; &#125; &#125; for (int i = 0; i &lt; h.length; i++) &#123; if (s.empty() || h[i] &gt; s.peek()) &#123; s.push(h[i]); &#125; else &#123; int count = 0; while (!s.empty() &amp;&amp; s.peek() &gt; h[i]) &#123; count++; res = Math.max(res, s.peek() * count); s.pop(); &#125; while (count &gt; 0) &#123; s.push(h[i]); count--; &#125; s.push(h[i]); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(84) Largest Rectangle in Histogram]]></title>
    <url>%2F2018%2F11%2F18%2FLeetcode-84-Largest-Rectangle-in-Histogram%2F</url>
    <content type="text"><![CDATA[DescriptionGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. Example: 12Input: [2,1,5,6,2,3]Output: 10 解法貌似是一道单调栈的题目，网上看到了一个很好的解释： 1、如果已知height数组是升序的，应该怎么做？ 比如1,2,5,7,8 那么就是(1*5) vs. (2*4) vs. (5*3) vs. (7*2) vs. (8*1)（类似于从当前位置向后看） 也就是max(height[i]*(size-i)) 2、使用栈的目的就是构造这样的升序序列，按照以上方法求解。 但是height本身不一定是升序的，应该怎样构建栈？ 比如2,1,5,6,2,3 （1）2进栈。s={2}, result = 0 （2）1比2小，不满足升序条件，因此将2弹出，并记录当前结果为2*1=2。将2替换为1重新进栈。s={1,1}, result = 2 （3）5比1大，满足升序条件，进栈。s={1,1,5},result = 2 （4）6比5大，满足升序条件，进栈。s={1,1,5,6},result = 2 （5）2比6小，不满足升序条件，因此将6弹出，并记录当前结果为6*1=6。s={1,1,5},result = 6，2比5小，不满足升序条件，因此将5弹出，并记录当前结果为5*2=10（因为已经弹出的5,6是升序的）。s={1,1},result = 10，2比1大，将弹出的5,6替换为2重新进栈。s={1,1,2,2,2},result = 10 （6）3比2大，满足升序条件，进栈。s={1,1,2,2,2,3},result = 10 栈构建完成，满足升序条件，这里为了简化处理，在数组的最后加入0，使得最后的递增数组能够完成运算，综上所述，result=10 具体代码如下： 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int largestRectangleArea(int[] heights) &#123; int res = 0; Stack&lt;Integer&gt; s = new Stack(); int[] h = new int[heights.length + 1]; for (int i = 0; i &lt; h.length; i++) &#123; if (i &lt; heights.length) &#123; h[i] = heights[i]; &#125; else &#123; h[i] = 0; &#125; &#125; for (int i = 0; i &lt; h.length; i++) &#123; if (s.empty() || h[i] &gt; s.peek()) &#123; s.push(h[i]); &#125; else &#123; int count = 0; while (!s.empty() &amp;&amp; s.peek() &gt; h[i]) &#123; count++; res = Math.max(res, s.peek() * count); s.pop(); &#125; while (count &gt; 0) &#123; s.push(h[i]); count--; &#125; s.push(h[i]); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(76) Minimum Window Substring]]></title>
    <url>%2F2018%2F11%2F17%2FLeetcode-76-Minimum-Window-Substring%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: 12Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot; Note: If there is no such window in S that covers all characters in T, return the empty string &quot;&quot;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S. 解法因为时间复杂度限制在了O(n)，因此只能通过至少一次遍历字符串实现，当时想到了应该利用哈希做题，具体思路为：用一个哈希表记录t中字符剩下的需要出现的次数（对于给定范围的字符串而言即s[start,i]），为负数时说明多出现了几次，用变量num记录给定范围字符串中还缺少多少个t中的字母，那么，当num为0时即找到一个符合条件的字符串。整体思路为先把所有的Ｔ中的字符找到，然后从左端缩减这个字符串，直到不能完全包含Ｔ，是一个经典的滑动窗口题 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public String minWindow(String s, String t) &#123; HashMap&lt;Character, Integer&gt; hsmap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; t.length(); i++) &#123; if (hsmap.containsKey(t.charAt(i))) &#123; int tmp = hsmap.get(t.charAt(i)); hsmap.replace(t.charAt(i), tmp + 1); &#125; else &#123; hsmap.put(t.charAt(i), 1); &#125; &#125; int num = t.length(); int len = Integer.MAX_VALUE; int start = 0; int left = 0; for (int i = 0; i &lt; s.length(); i++) &#123; //根据左边界确定右边界，i起到了右边界的作用 if (hsmap.containsKey(s.charAt(i))) &#123; int tmp = hsmap.get(s.charAt(i)); if (tmp &gt; 0) &#123; num--; &#125; hsmap.replace(s.charAt(i), tmp - 1); &#125; //右边界确定，进入while循环，右移左边界，tmp只能为负或为0，为负数时说明可以继续右移左边界 while (num == 0) &#123; if (i - left + 1 &lt; len) &#123; len = i - left + 1; start = left; &#125; if (hsmap.containsKey(s.charAt(left))) &#123; int tmp = hsmap.get(s.charAt(left)); if (tmp == 0) &#123; num++; &#125; hsmap.replace(s.charAt(left), tmp + 1); &#125; left++; &#125; &#125; if (len == Integer.MAX_VALUE) &#123; return ""; &#125; else &#123; return s.substring(start, start + len); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(87) Scramble String]]></title>
    <url>%2F2018%2F11%2F17%2FLeetcode-87-Scramble-String%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = &quot;great&quot;: 1234567 great / \ gr eat / \ / \g r e at / \ a t To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;. 1234567 rgeat / \ rg eat / \ / \r g e at / \ a t We say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;. Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;. 1234567 rgtae / \ rg tae / \ / \r g ta e / \ t a We say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: 12Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;Output: true Example 2: 12Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;Output: false 解法很明显的一道动态规划的题，先解释一下动态规划的渊源。 一般动态规划可解的题都是分治递归可解的，我们不难发现，分治算法之所以理论复杂度很高，其原因是因为重复的进行了很多子问题的计算，这是不必要的，如果我们一旦计算出某个子问题的结果，就将其存在内存中，下次要用到的时候，我们就直接使用不再次进行计算的话，这样是不是就能够减少很多复杂度呢？ 实际上，这样的方法被称作“记忆化”，即将已经发生过的计算的结果记忆下来，以待之后使用。 特别的，由于运算过程中保证小的子问题需要先进行运算，我们可以不用递归来进行这样的计算，而是按照从小到大的顺序依次将所有的子问题计算出来，由于小的子问题先得到计算，所以我们可以确保在计算某一个之后的问题时，它需要的所有子问题都已经得到了计算。 这样的方法，被称作动态规划，这也是为什么常有人说动态规划和记忆化是非常类似的算法的原因了。 在实现中，其实就和分治算法非常类似，不过是将递归的过程改成了递推。 回到题目本身，题目的问题可以这样分析，就是s1和s2是scramble的话，那么必然存在一个在s1上的长度l1，将s1分成s11和s12两段，同样有s21和s22.那么要么s11和s21是scramble的并且s12和s22是scramble的；要么s11和s22是scramble的并且s12和s21是scramble的。 i，j，代表字符串的开始位置，len代表比较的长度，在len内按照长度k进行分割 递归式为： 1dp[i][j][len] = || (dp[i][j][k] &amp;&amp; dp[i + k][j + k][len - k]) || (dp[i + k][j][len - k] &amp;&amp; dp[i][j + len - k][k]) 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean isScramble(String s1, String s2) &#123; if (s1.length() != s2.length()) &#123; return false; &#125; if (s1.equals(s2)) &#123; return true; &#125; int n = s1.length(); Boolean[][][] res = new Boolean[n][n][n + 1]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt;= n; k++) &#123; res[i][j][k] = false; &#125; &#125; &#125; //初始化边界值： for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; res[i][j][1] = (s1.charAt(i) == s2.charAt(j)); &#125; &#125; //最外层堆len的值进行遍历 //最内层对len长度下的分割方式进行遍历 for (int len = 2; len &lt;= n; len++) &#123; for (int i = 0; i &lt;= n - len; i++) &#123; for (int j = 0; j &lt;= n - len; j++) &#123; for (int k = 1; k &lt; len; k++) &#123; if ((res[i][j][k] &amp;&amp; res[i + k][j + k][len - k]) || (res[i + k][j][len - k] &amp;&amp; res[i][j + len - k][k])) &#123; res[i][j][len] = true; &#125; &#125; &#125; &#125; &#125; return res[0][0][n]; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(97) Interleaving String]]></title>
    <url>%2F2018%2F11%2F16%2FLeetcode-97-Interleaving-String%2F</url>
    <content type="text"><![CDATA[DescriptionGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;Output: true Example 2: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;Output: false 解法首先明确，这种题用递归解肯定是超时的，那么采用动态规划优化时间，这里对于s3字符串的匹配可能出现两种情况，一种是采用s1中的字符与其匹配，一种是采用s2中的字符与之匹配。设计二维dp表格。 s1, s2只有两个字符串，因此可以展平为一个二维地图，判断是否能从左上角走到右下角。 当s1到达第i个元素，s2到达第j个元素: 地图上往右一步就是s2[j-1]匹配s3[i+j-1]。 地图上往下一步就是s1[i-1]匹配s3[i+j-1]。 示例：s1=”aa”,s2=”ab”,s3=”aaba”。标1的为可行。最终返回右下角。 ​ 0 a b 0 1 1 0 a 1 1 1 a 1 0 1 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean isInterleave(String s1, String s2, String s3) &#123; if (s1.length() + s2.length() != s3.length()) &#123; return false; &#125; if (s1.length() == 0 &amp;&amp; s2.length() == 0) &#123; if (s3.length() == 0) &#123; return true; &#125; return false; &#125; Boolean[][] dp = new Boolean[s1.length() + 1][s2.length() + 1]; for (int i = 0; i &lt; s1.length() + 1; i++) &#123; for (int j = 0; j &lt; s2.length() + 1; j++) &#123; if (i == 0 &amp;&amp; j == 0) &#123; dp[i][j] = true; &#125; else if (j == 0) &#123; if (s1.charAt(i - 1) == s3.charAt(i - 1)) &#123; dp[i][0] = dp[i - 1][0]; &#125; else &#123; dp[i][0] = false; &#125; &#125; else if (i == 0) &#123; if (s2.charAt(j - 1) == s3.charAt(j - 1)) &#123; dp[0][j] = dp[0][j - 1]; &#125; else &#123; dp[0][j] = false; &#125; &#125; else &#123; dp[i][j] = (dp[i - 1][j] &amp;&amp; (s1.charAt(i - 1) == s3.charAt(i + j - 1))) || (dp[i][j - 1] &amp;&amp; (s2.charAt(j - 1) == s3.charAt(j + i - 1))); &#125; &#125; &#125; return dp[s1.length()][s2.length()]; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode(99) Recover Binary Search Tree]]></title>
    <url>%2F2018%2F11%2F16%2Fleetcode-99-Recover-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionTwo elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解法我最终采用的是O(n)的算法，可以用O(1)实现，但是太巧妙了，不太好想，我选择放弃。对于二叉排序树，可以建立其与有序数组的联系，方便处理一些问题，而二叉排序树的中序遍历即为有序数组。对于只变换一次的数组，要达到完全有序，有两种情况： a. 1，2，4，3，5 b. 1，2，5，4，3 观察发现，出现了相邻的逆序数时，可以先假设就是交换这两个数，如果之后还是出现了相邻的逆序数，则更新待更新的数。 具体而言，采用三个指针，pre用于逆序数的探测，first，second用于记录待交换的数。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; TreeNode pre; TreeNode first; TreeNode second; public void recoverTree(TreeNode root) &#123; pre = null; first = null; second = null; inorde(root); if (second != null &amp;&amp; first != null) &#123; int tmp = second.val; second.val = first.val; first.val = tmp; &#125; &#125; void inorde(TreeNode root) &#123; if (root == null) &#123; return; &#125; inorde(root.left); if (pre == null) &#123; pre = root; &#125; else &#123; if (pre.val &gt; root.val) &#123; if (first == null) &#123; first = pre; &#125; second = root; &#125; pre = root; &#125; inorde(root.right); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(86) Partition List]]></title>
    <url>%2F2018%2F11%2F14%2FLeetcode-86-Partition-List%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: 12Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解法这道题可以将所有小于给定值的节点取出组成一个新的链表，并在原表中删除，此时原链表中剩余的节点的值都大于或等于给定值，只要将原链表直接接在新链表后即可。 对于输入 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2 ，3 此种解法链表变化顺序为： Original: 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2 New: Original: 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2 New: 1 Original: 4 -&gt; 3 -&gt; 5 -&gt; 2 New: 1 -&gt; 2 Original: 4 -&gt; 3 -&gt; 5 New: 1 -&gt; 2 -&gt; 2 Original: New: 1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5 具体代码如下： 12345678910111213141516171819202122232425262728293031class Solution &#123; public ListNode partition(ListNode head, int x) &#123; if (head == null) &#123; return head; &#125; ListNode res = new ListNode(-1); ListNode restmp = res; ListNode tmp = head; ListNode pre = head; while (tmp != null) &#123; if (tmp.val &lt; x) &#123; ListNode newnode = new ListNode(tmp.val); restmp.next = newnode; restmp = restmp.next; if (tmp == head) &#123; head = tmp.next; pre = head; tmp = head; &#125; else &#123; pre.next = tmp.next; tmp = tmp.next; &#125; &#125; else &#123; pre = tmp; tmp = tmp.next; &#125; &#125; restmp.next = head; return res.next; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(98) Validate Binary Search Tree]]></title>
    <url>%2F2018%2F11%2F14%2FLeetcode-98-Validate-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 12345Input: 2 / \ 1 3Output: true Example 2: 12345678 5 / \ 1 4 / \ 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value is 5 but its right child&apos;s value is 4. 解法 这题最开始我想得简单了，直接递归解，比较当前点与左右节点是否符合，然后递归左右节点。 代码如下： 12345678910111213class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if ((root.left == null || root.left.val &lt; root.val)&amp;&amp;(root.right == null || root.right.val &gt; root.val))&#123; return(isValidBST(root.left)&amp;&amp;isValidBST(root.right)); &#125; else&#123; return false; &#125; &#125;&#125; 显然，这种做法是错误的，考虑如下情况： 12345 10 / \5 15 / \ 6 20 它并不是一棵合法的二叉搜索树，上面的算法会误判。 所以，采用两个变量记录当前节点可能的最大最小值，在每次判断时与这两个值比较即可。 具体代码如下： 12345678910111213141516171819class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return helper(root, Long.MAX_VALUE, Long.MIN_VALUE); &#125; boolean helper(TreeNode root, long max, long min) &#123; if (root == null) &#123; return true; &#125; if (root.val &lt; max &amp;&amp; root.val &gt; min) &#123; return helper(root.left, root.val, min) &amp;&amp; helper(root.right, max, root.val); &#125; else &#123; return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(75) Sort Colors]]></title>
    <url>%2F2018%2F11%2F14%2FLeetcode-75-Sort-Colors%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: 12Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space? 解法可以采用counting sort的方法，遍历一遍数组，记录0，1，2的个数，然后按照个数覆写数组。 但题目要求一次遍历，采用类似于快速排序的双指针法，一个指向下一个0的位置，一个指向下一个1的位置，然后进行遍历交换。 具体代码如下： 123456789101112131415161718192021class Solution &#123; public void sortColors(int[] nums) &#123; int i = 0; int j = nums.length - 1; for (int k = 0; k &lt; nums.length; ) &#123; if (k &lt; j &amp;&amp; nums[k] &gt; 1) &#123; int tmp = nums[k]; nums[k] = nums[j]; nums[j] = tmp; j--; &#125; else if (k &gt; i &amp;&amp; nums[k] &lt; 1) &#123; int tmp = nums[k]; nums[k] = nums[i]; nums[i] = tmp; i++; &#125; else &#123; k++; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(88) Merge Sorted Array]]></title>
    <url>%2F2018%2F11%2F13%2FLeetcode-88-Merge-Sorted-Array%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: 12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 解法这题就是Mergesort里的merge函数，用两个指针就好啦，注意为空的判断和数组完结的处理 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; if (n == 0) &#123; return; &#125; int[] res = new int[m + n]; int i = 0; int j = 0; int k = 0; for (; k &lt; m + n; k++) &#123; if (i == m) &#123; break; &#125; if (j == n) &#123; break; &#125; if (nums1[i] &lt; nums2[j]) &#123; res[k] = nums1[i++]; &#125; else &#123; res[k] = nums2[j++]; &#125; &#125; if (i == m) &#123; while (j &lt; n) &#123; res[k++] = nums2[j++]; &#125; &#125; if (j == n) &#123; while (i &lt; m) &#123; res[k++] = nums1[i++]; &#125; &#125; for (k = 0; k &lt; m + n; k++) &#123; nums1[k] = res[k]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(83) Remove Duplicates from Sorted List]]></title>
    <url>%2F2018%2F11%2F13%2FLeetcode-83-Remove-Duplicates-from-Sorted-List%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a sorted linked list, delete all duplicates such that each element appear only once. Example 1: 12Input: 1-&gt;1-&gt;2Output: 1-&gt;2 Example 2: 12Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 解法基本的链表操作，双指针法，注意空表的处理。 具体代码如下： 12345678910111213141516171819class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return head; &#125; ListNode pre = head; ListNode tmp = head.next; while (tmp != null) &#123; if (tmp.val == pre.val) &#123; pre.next = tmp.next; tmp = tmp.next; &#125; else &#123; pre = tmp; tmp = tmp.next; &#125; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(72) Edit Distance]]></title>
    <url>%2F2018%2F11%2F13%2FLeetcode-72-Edit-Distance%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: 123456Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;) Example 2: 12345678Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;) 解法最开始的时候看到这道题是懵逼的，深呼吸，来分析以下具体情况。 假设从左往右进行字符串修改，如果A[i] == b[j]，此时此刻，因为是从左向右修改的，那么，i之前的字符串与j之间的字符串已经匹配了，又因为i和j对应的字符相等，那么需要修改的次数就是i-1修改为j-1的次数。 如果A[i]!=B[j]，此时题目中给出了三种修改方案，一种是直接删除字符，那么此时的修改次数就是修改i-1为j的次数+1（对应递归中i指针向后移一位），一种是插入新字符，那么此时的修改次数就是修改i为j-1的次数+1（对应递归中j指针向后移一位），一种是直接替换，那么此时的修改次数就是修改i-1为j-1的次数+1（对应递归中i,j指针往后移一位）。 维护一个二维的数组dp，其中dp(i,j)表示从word1的前i个字符转换到word2的前j个字符所需要的步骤。那我们可以先给这个二维数组dp的第一行第一列赋值，这个很简单，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤完全是另一个字符串的长度。我们可以举个例子来看，比如word1是“bbc”，word2是”abcd“，那么我们可以得到dp数组如下： 12345 Ø a b c dØ 0 1 2 3 4b 1 1 1 2 3b 2 2 1 2 3c 3 3 2 1 2 有递推公式： 1234if word1[i - 1] == word2[j - 1]dp[i][j] = dp[i - 1][j - 1] elsedp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1 具体代码如下： 123456789101112131415161718192021class Solution &#123; public int minDistance(String word1, String word2) &#123; int[][] dp = new int[word1.length() + 1][word2.length() + 1]; for (int i = 0; i &lt; word1.length() + 1; i++) &#123; dp[i][0] = i; &#125; for (int j = 0; j &lt; word2.length() + 1; j++) &#123; dp[0][j] = j; &#125; for (int i = 1; i &lt; word1.length() + 1; i++) &#123; for (int j = 1; j &lt; word2.length() + 1; j++) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1; &#125; &#125; &#125; return dp[word1.length()][word2.length()]; &#125;&#125; 一般动态规划的题可以用递归来解，以下网上给出的递归方法，可以帮助我们理解dp公式。当然肯定是超时的： 1234567891011121314151617181920212223242526int minDistance(string word1, string word2) &#123; if(word1 == word2) return 0; int m = word1.size(); int n = word2.size(); if(word1 == "") &#123; return n; &#125; if(word2 == "") &#123; return m; &#125; if(word1[0] == word2[0]) &#123; return minDistance(word1.substr(1), word2.substr(1)); &#125; else &#123; return min(1 + minDistance(word1, word2.substr(1)), min(1 + minDistance(word1.substr(1), word2), 1 + minDistance(word1.substr(1), word2.substr(1)))); &#125; &#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(73) Set Matrix Zeroes]]></title>
    <url>%2F2018%2F11%2F13%2FLeetcode-73-Set-Matrix-Zeroes%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: 123456789101112Input: [ [1,1,1], [1,0,1], [1,1,1]]Output: [ [1,0,1], [0,0,0], [1,0,1]] Example 2: 123456789101112Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] Follow up: A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 解法题目中要求直接替换，那么为了节省空间，可以选择将需要替换的行号和列号用list存起来，然后统一进行替换。 具体代码如下： 12345678910111213141516171819202122232425class Solution &#123; public void setZeroes(int[][] matrix) &#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); List&lt;Integer&gt; col = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; if (matrix[i][j] == 0) &#123; row.add(i); col.add(j); &#125; &#125; &#125; for (int i = 0; i &lt; row.size(); i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; matrix[row.get(i)][j] = 0; &#125; &#125; for (int j = 0; j &lt; col.size(); j++) &#123; for (int i = 0; i &lt; matrix.length; i++) &#123; matrix[i][col.get(j)] = 0; &#125; &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(71) Simplify Path]]></title>
    <url>%2F2018%2F11%2F11%2FLeetcode-71-Simplify-Path%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an absolute path for a file (Unix-style), simplify it. For example,path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot;path = &quot;/a/../../b/../c//.//&quot;, =&gt; &quot;/c&quot;path = &quot;/a//b////c/d//././/..&quot;, =&gt; &quot;/a/b/c&quot; In a UNIX-style file system, a period (‘.’) refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period (“..”) moves up a directory, so it cancels out whatever the last directory was. For more information, look here: https://en.wikipedia.org/wiki/Path_(computing)#Unix_style Corner Cases: Did you consider the case where path = &quot;/../&quot;?In this case, you should return &quot;/&quot;. Another corner case is the path might contain multiple slashes &#39;/&#39; together, such as &quot;/home//foo/&quot;.In this case, you should ignore redundant slashes and return &quot;/home/foo&quot;. 解法根据题意，可总结规律有：按’/‘号分隔路径，中间是”.”的情况直接略过，是”..”时删掉它上面挨着的一个路径，而下面的边界条件给的一些情况中可以得知，如果是空的话返回”/“，如果有多个”/“只保留一个。这道题坑在路径中可以出现’.’，意思是如果两个斜杠之间出现了大于2个点或者点与其他字符混合的情况，应该按照路径处理。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; public String simplifyPath(String path) &#123; StringBuffer res = new StringBuffer(); Stack&lt;String&gt; s = new Stack&lt;&gt;(); StringBuffer tmp = new StringBuffer(); for (int i = 0; i &lt; path.length(); i++) &#123; if (path.charAt(i) == '/') &#123; continue; &#125; else if (path.charAt(i) == '.') &#123; if (i + 1 == path.length()) &#123; continue; &#125; if (i + 1 &lt; path.length() &amp;&amp; path.charAt(i + 1) == '/') &#123; continue; &#125; if (i + 2 == path.length() &amp;&amp; path.charAt(i + 1) == '.') &#123; if (!s.empty()) &#123; s.pop(); &#125; i++; &#125; else if (i + 2 &lt; path.length() &amp;&amp; path.charAt(i + 1) == '.' &amp;&amp; path.charAt(i + 2) == '/') &#123; if (!s.empty()) &#123; s.pop(); &#125; i++; &#125; else &#123; StringBuffer strangename = new StringBuffer(); while (path.charAt(i) != '/') &#123; strangename.append(path.charAt(i)); i++; if (i &gt;= path.length()) &#123; break; &#125; &#125; s.push(strangename.toString()); strangename.delete(0, strangename.length()); &#125; &#125; else &#123; while (path.charAt(i) != '/') &#123; tmp.append(path.charAt(i)); i++; if (i &gt;= path.length()) &#123; break; &#125; &#125; s.push(tmp.toString()); tmp.delete(0, tmp.length()); &#125; &#125; if (!s.empty()) &#123; List&lt;String&gt; l = new ArrayList&lt;&gt;(); while (!s.empty()) &#123; String t = s.pop(); l.add(t); &#125; for (int i = l.size() - 1; i &gt;= 0; i--) &#123; res.append("/" + l.get(i)); &#125; return res.toString(); &#125; return "/"; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(70) Climbing Stairs]]></title>
    <url>%2F2018%2F11%2F11%2FLeetcode-70-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[DescriptionYou are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: 12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2: 123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 解法最开始的想法是DFS暴力搜索所有可能的情况，毫无疑问，超时了0.0 12345678910111213141516171819202122232425class Solution &#123; int cnt = 0; public int climbStairs(int n) &#123; if (n == 1) &#123; return 1; &#125; dfs(n); return cnt; &#125; void dfs(int n) &#123; for (int i = 1; i &lt;= 2; i++) &#123; if (n - i == 0) &#123; cnt += 1; return; &#125; if (n - i &gt; 0) &#123; dfs(n - i); &#125; else &#123; return; &#125; &#125; &#125;&#125; 仔细一想，貌似可以采用动态规划的思想，因为走到台阶n有两种可能的走法，一种是从n-1迈一步上来，一种是从n-2迈2步上来，于是有dp[n] = dp[n-1] + dp[n-2]。额，这不就是斐波那契数列吗0.0 12345678910111213class Solution &#123; public int climbStairs(int n) &#123; if(n == 1)&#123; return 1; &#125; if(n == 2)&#123; return 2; &#125; else&#123; return climbStairs(n-1)+climbStairs(n-2); &#125; &#125;&#125; 很遗憾，还是超时了0.0。问题在于重复计算。因此，采用记忆化避免重复计算，最终成功AC~(^-^) 具体代码如下： 12345678910111213141516171819202122class Solution &#123; public int climbStairs(int n) &#123; if (n &lt;= 2) &#123; return n; &#125; int[] nums = new int[n + 1]; nums[1] = 1; nums[2] = 2; return find(nums, n); &#125; int find(int[] nums, int n) &#123; if (nums[n] != 0) &#123; return nums[n]; &#125; else &#123; nums[n] = find(nums, n - 1) + find(nums, n - 2); return nums[n]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(69) Sqrt(x)]]></title>
    <url>%2F2018%2F11%2F11%2FLeetcode-69-Sqrt-x%2F</url>
    <content type="text"><![CDATA[DescriptionImplement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: 12Input: 4Output: 2 Example 2: 1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 解法这道题就是自己实现开方的函数，最开始的想法是硬碰撞，从0一直试到x/2+1，如果出现了乘积大于等于结果的情况则返回值，这里需要注意整型数范围问题，所以乘积用long型数表示 具体代码如下： 1234567891011121314class Solution &#123; public int mySqrt(int x) &#123; for (int i = 0; i &lt;= x / 2 + 1; i++) &#123; long res = (long) i * i; if (res == x) &#123; return i; &#125; if (res &gt; x) &#123; return i - 1; &#125; &#125; return -1; &#125;&#125; 然后看到网上的思路发现还可以用二分法解： 123456789101112131415161718class Solution &#123; public int mySqrt(int x) &#123; if (x &lt;= 1) &#123; return x; &#125; int left = 1; int right = x; while (left &lt; right) &#123; int mid = (right - left) / 2 + left; if (x / mid &gt;= mid) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return right - 1; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(68) Text Justification]]></title>
    <url>%2F2018%2F11%2F10%2FLeetcode-68-Text-Justification%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces &#39; &#39;when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. Note: A word is defined as a character sequence consisting of non-space characters only. Each word’s length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word. Example 1: 123456789Input:words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]maxWidth = 16Output:[ &quot;This is an&quot;, &quot;example of text&quot;, &quot;justification. &quot;] Example 2: 123456789101112Input:words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]maxWidth = 16Output:[ &quot;What must be&quot;, &quot;acknowledgment &quot;, &quot;shall be &quot;]Explanation: Note that the last line is &quot;shall be &quot; instead of &quot;shall be&quot;, because the last line must be left-justified instead of fully-justified. Note that the second line is also left-justified becase it contains only one word. Example 3: 12345678910111213Input:words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;, &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]maxWidth = 20Output:[ &quot;Science is what we&quot;, &quot;understand well&quot;, &quot;enough to explain to&quot;, &quot;a computer. Art is&quot;, &quot;everything else we&quot;, &quot;do &quot;] 解法又是一道挺麻烦的题，其实我觉得根贪心算法关系不大。按行处理，先计算每行的单词数，再得出正常情况（按一个空格分隔单词）的空格数，再用最大值减去当前（含空格）的字符个数，分配这个数目的空格到各个间隙中去。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class Solution &#123; public List&lt;String&gt; fullJustify(String[] words, int maxWidth) &#123; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); List&lt;String&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; blankcount = new ArrayList&lt;&gt;(); int lofline = 0; for (int k = 0; k &lt; words.length; k++) &#123; String s = words[k]; if (lofline == 0) &#123; lofline += s.length(); tmp.add(s); &#125; else &#123; lofline += s.length(); lofline += 1; tmp.add(s); &#125; if (lofline &gt; maxWidth) &#123; lofline -= tmp.get(tmp.size() - 1).length(); lofline -= 1; tmp.remove(tmp.size() - 1); k--; int extrablankespace = maxWidth - lofline; int blanknum = tmp.size() - 1; if (blanknum == 0) &#123; blankcount.add(extrablankespace); &#125; else &#123; for (int j = 0; j &lt; blanknum; j++) &#123; blankcount.add(1); &#125; while (extrablankespace != 0) &#123; for (int i = 0; i &lt; blanknum; i++) &#123; blankcount.set(i, blankcount.get(i) + 1); extrablankespace--; if (extrablankespace == 0) &#123; break; &#125; &#125; &#125; &#125; StringBuffer sb = new StringBuffer(); while (tmp.size() != 0) &#123; sb.append(tmp.get(0)); if (blankcount.size() != 0) &#123; for (int i = 0; i &lt; blankcount.get(0); i++) &#123; sb.append(" "); &#125; blankcount.remove(0); &#125; tmp.remove(0); &#125; res.add(sb.toString()); lofline = 0; &#125; else if (maxWidth == lofline) &#123; StringBuffer sb = new StringBuffer(); while (tmp.size() != 0) &#123; sb.append(tmp.get(0)); tmp.remove(0); if (tmp.size() != 0) &#123; sb.append(" "); &#125; &#125; res.add(sb.toString()); lofline = 0; &#125; else if (maxWidth &gt; lofline &amp;&amp; k == words.length - 1) &#123; StringBuffer sb = new StringBuffer(); while (tmp.size() != 0) &#123; sb.append(tmp.get(0)); tmp.remove(0); if (tmp.size() != 0) &#123; sb.append(" "); &#125; &#125; for (int i = 0; i &lt; maxWidth - lofline; i++) &#123; sb.append(" "); &#125; res.add(sb.toString()); lofline = 0; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(67) Add Binary]]></title>
    <url>%2F2018%2F11%2F09%2FLeetcode-67-Add-Binary%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: 12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; Example 2: 12Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot; 解法与模拟加法实现的过程相同，只不过是二进制而已，注意不同长度的字符相加和进位的处理，同时记得处理多余的前导0。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123; public String addBinary(String a, String b) &#123; StringBuffer res = new StringBuffer(); StringBuffer x = new StringBuffer(a); x.reverse(); StringBuffer y = new StringBuffer(b); y.reverse(); if (x.length() &lt; y.length()) &#123; int add0 = y.length() - x.length(); while (add0 &gt; 0) &#123; x.append('0'); add0--; &#125; &#125; else &#123; int add0 = x.length() - y.length(); while (add0 &gt; 0) &#123; y.append('0'); add0--; &#125; &#125; int tmp = 0; for (int i = 0; i &lt; x.length(); i++) &#123; if (x.charAt(i) == '0' &amp;&amp; y.charAt(i) == '1') &#123; if (tmp == 0) &#123; res.append('1'); &#125; else &#123; res.append('0'); tmp = 1; &#125; &#125; if (x.charAt(i) == '1' &amp;&amp; y.charAt(i) == '0') &#123; if (tmp == 0) &#123; res.append('1'); &#125; else &#123; res.append('0'); tmp = 1; &#125; &#125; if (x.charAt(i) == '0' &amp;&amp; y.charAt(i) == '0') &#123; if (tmp == 0) &#123; res.append('0'); &#125; else &#123; res.append('1'); tmp = 0; &#125; &#125; if (x.charAt(i) == '1' &amp;&amp; y.charAt(i) == '1') &#123; if (tmp == 0) &#123; res.append('0'); tmp = 1; &#125; else &#123; res.append('1'); tmp = 1; &#125; &#125; &#125; if (tmp == 1) &#123; res.append('1'); &#125; res.reverse(); while (res.charAt(0) == '0' &amp;&amp; res.length() &gt; 1) &#123; res.deleteCharAt(0); &#125; return res.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(65) Valid Number]]></title>
    <url>%2F2018%2F11%2F09%2FLeetcode-65-Valid-Number%2F</url>
    <content type="text"><![CDATA[DescriptionValidate if a given string can be interpreted as a decimal number. Some examples:&quot;0&quot; =&gt; true&quot; 0.1 &quot; =&gt; true&quot;abc&quot; =&gt; false&quot;1 a&quot; =&gt; false&quot;2e10&quot; =&gt; true&quot; -90e3 &quot; =&gt; true&quot; 1e&quot; =&gt; false&quot;e3&quot; =&gt; false&quot; 6e-1&quot; =&gt; true&quot; 99e2.5 &quot; =&gt; false&quot;53.5e93&quot; =&gt; true&quot; --6 &quot; =&gt; false&quot;-+3&quot; =&gt; false&quot;95a54e53&quot; =&gt; false Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number: Numbers 0-9 Exponent - “e” Positive/negative sign - “+”/“-“ Decimal point - “.” Of course, the context of these characters also matters in the input. Update (2015-02-10):The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. 解法这题是真的无聊，其实就是特别麻烦分析的情况比较多，其他真的没啥。 我们需要五个标志变量，num, dot, exp, sign分别表示数字，小数点，自然底数和符号是否出现，numAfterE表示自然底数后面是否有数字，那么我们分别来看各种情况： - 空格： 我们需要排除的情况是，当前位置是空格而后面一位不为空格，但是之前有数字，小数点，自然底数或者符号出现时返回false。 - 符号：符号前面如果有字符的话必须是空格或者是自然底数，标记sign为true。 - 数字：标记num和numAfterE为true。 - 小数点：如果之前出现过小数点或者自然底数，返回false，否则标记dot为true。 - 自然底数：如果之前出现过自然底数或者之前从未出现过数字，返回false，否则标记exp为true，numAfterE为false。 - 其他字符：返回false。 最后返回num &amp;&amp; numAfterE即可。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean isNumber(String s) &#123; int n = s.length(); Boolean num = false, numAfterE = true, dot = false, exp = false, sign = false; for (int i = 0; i &lt; n; i++) &#123; if (s.charAt(i) == ' ') &#123; if (i &lt; n - 1 &amp;&amp; s.charAt(i + 1) != ' ' &amp;&amp; (num || dot || exp || sign)) &#123; return false; &#125; &#125; else if (s.charAt(i) == '+' || s.charAt(i) == '-') &#123; if ((i &gt; 0 &amp;&amp; s.charAt(i - 1) != 'e' &amp;&amp; s.charAt(i - 1) != ' ')) &#123; return false; &#125; sign = true; &#125; else if (s.charAt(i) &gt;= '0' &amp;&amp; s.charAt(i) &lt;= '9') &#123; num = true; numAfterE = true; &#125; else if (s.charAt(i) == '.') &#123; if (dot || exp) &#123; return false; &#125; dot = true; &#125; else if (s.charAt(i) == 'e') &#123; if (exp || !num) &#123; return false; &#125; exp = true; numAfterE = false; &#125; else &#123; return false; &#125; &#125; return num &amp;&amp; numAfterE; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(52) N-Queens II]]></title>
    <url>%2F2018%2F11%2F06%2FLeetcode-52-N-Queens-II%2F</url>
    <content type="text"><![CDATA[DescriptionThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example: 1234567891011121314Input: 4Output: 2Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 解法与N皇后问题1基本一样，采用回溯法解题，只是在搜寻到一种情况之后对计数器做自加操作记录解的个数，这里就不重复描述啦。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; int res; public int totalNQueens(int n) &#123; res = 0; //jpos[i]中存第i行中皇后摆放的纵坐标 int[] jpos = new int[n]; searchline(0, n, jpos); return res; &#125; void searchline(int k, int n, int[] jpos) &#123; //终止条件 if (k == n) &#123; res++; return; &#125; //依次选择j列的位置进行当前行的摆放 for (int j = 0; j &lt; n; j++) &#123; jpos[k] = j; //合法则对下一行进行搜索 if (canplace(k, jpos)) &#123; searchline(k + 1, n, jpos); &#125; //回溯还原 jpos[k] = 0; &#125; &#125; //判断第k行的插入是否可行 Boolean canplace(int k, int[] jpos) &#123; for (int i = 0; i &lt; k; i++) &#123; if (jpos[i] == jpos[k] || Math.abs(jpos[i] - jpos[k]) == Math.abs(k - i)) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(51) N-Queens]]></title>
    <url>%2F2018%2F11%2F06%2FLeetcode-51-N-Queens%2F</url>
    <content type="text"><![CDATA[DescriptionThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively. 解法经典的算法问题：N皇后问题。先解释一下：皇后不能同时出现在同一列，同一行或在同一条斜边上。为了找出所有可能的摆放，我们按行进行搜索，每一行寻找一个可以摆放的位置，如果合法，则进行下一行的搜索，当那一行不存在合法的摆放时，回溯归位。就是典型的回溯法解题啦~此题的关键在于数据结构的设计，巧妙地使用一维数组记录每一行皇后的j坐标可以将算法的设计大大简化。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //jpos[i]中存第i行中皇后摆放的纵坐标 int[] jpos = new int[n]; searchline(0, n, jpos); return res; &#125; void searchline(int k, int n, int[] jpos) &#123; //终止条件 if (k == n) &#123; List&lt;String&gt; s = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; StringBuffer tmp = new StringBuffer(""); for (int j = 0; j &lt; n; j++) &#123; if (j == jpos[i]) &#123; tmp.append("Q"); &#125; else &#123; tmp.append("."); &#125; &#125; s.add(tmp.toString()); &#125; res.add(s); return; &#125; //依次选择j列的位置进行当前行的摆放 for (int j = 0; j &lt; n; j++) &#123; jpos[k] = j; //合法则对下一行进行搜索 if (canplace(k, jpos)) &#123; searchline(k + 1, n, jpos); &#125; //回溯还原 jpos[k] = 0; &#125; &#125; //判断第k行的插入是否可行 Boolean canplace(int k, int[] jpos) &#123; for (int i = 0; i &lt; k; i++) &#123; if (jpos[i] == jpos[k] || Math.abs(jpos[i] - jpos[k]) == Math.abs(k - i)) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(57) Insert Interval]]></title>
    <url>%2F2018%2F11%2F06%2FLeetcode-57-Insert-Interval%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: 12Input: intervals = [[1,3],[6,9]], newInterval = [2,5]Output: [[1,5],[6,9]] Example 2: 123Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]Output: [[1,2],[3,10],[12,16]]Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. 解法此题解法与merge intervals 那题的解法类似，先不管是否重合可连接，将插入的区间直接扔到list中，对整个list排序，然后按照merge的方法进行合并即可。 具体代码如下： 123456789101112131415161718192021222324class Solution &#123; public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; intervals.add(newInterval); Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return Integer.compare(o1.start, o2.start); &#125; &#125;); List&lt;Interval&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; intervals.size(); i++) &#123; res.add(intervals.get(i)); for (int j = 0; j &lt; res.size() - 1; j++) &#123; Interval p = res.get(j); Interval q = res.get(j + 1); if (q.start &lt;= p.end) &#123; p.end = Math.max(p.end, q.end); res.remove(q); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的排序]]></title>
    <url>%2F2018%2F11%2F06%2FJava%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Java中的排序这里介绍两种常用的排序对象：对数组的排序和对list的排序。 数组的排序数组的排序主要采用Arrays.sort()方法，默认为升序。常用API有： 12345678910Arrays.sort(array_name,startindex,endindex);Arrays.sort(array_name);Arrays.sort(a3, new Comparator&lt;people&gt;() &#123; @Override public int compare(people o1, people o2) &#123; return Integer.compare(o1.age, o2.age); &#125;&#125;); 若想降序，可以先将数组转换为list： 12List tmp = Arrays.asList(a1);Collections.sort(tmp, Collections.reverseOrder()); List的排序List排序主要采用Comparator类中的sort方法，主要API有： 12345678Collections.sort(Listname);Collections.sort(Listname, Collections.reverseOrder());Collections.sort(l1, new Comparator&lt;people&gt;() &#123; @Override public int compare(people o1, people o2) &#123; return Integer.compare(o1.age, o2.age); &#125;&#125;); 可以看出两者的自定义排序均为重写compare方法。 总体体的代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.util.*;class people &#123; int age; String name; people(int age, String name) &#123; this.age = age; this.name = name; &#125;&#125;public class test &#123; public static void main(String[] args) &#123; int[] a1 = &#123;5, 3, 2, 4, 1&#125;; double[] a2 = &#123;5.5, 3.3, 2.2, 4.4, 1.1&#125;; people tom = new people(18, "tom"); people jerry = new people(17, "jerry"); people jason = new people(20, "jason"); people[] a3 = &#123;tom, jerry, jason&#125;; List&lt;people&gt; l1 = new ArrayList&lt;&gt;(); l1.add(tom); l1.add(jerry); l1.add(jason); List&lt;Integer&gt; l2 = new ArrayList&lt;&gt;(); l2.add(5); l2.add(2); l2.add(3); l2.add(1); //sort升序排部分(左包右不包) Arrays.sort(a1, 2, 5); System.out.println(Arrays.toString(a1)); //sort升序排序（int数组） Arrays.sort(a1); System.out.println(Arrays.toString(a1)); //sort升序排序（double数组） Arrays.sort(a2); System.out.println(Arrays.toString(a2)); //sort自定义接口 /* int compare(Object o1, Object o2) 返回一个基本类型的整型 如果要按照升序排序， 则o1 小于o2，返回-1（负数），相等返回0，01大于02返回1（正数） 如果要按照降序排序 则o1 小于o2，返回1（正数），相等返回0，01大于02返回-1（负数） */ Arrays.sort(a3, new Comparator&lt;people&gt;() &#123; @Override public int compare(people o1, people o2) &#123; return Integer.compare(o1.age, o2.age); &#125; &#125;); System.out.println((a3[0].age) + " " + (a3[1].age) + " " + (a3[2].age)); //sort降序排序(整型）转为list再排序 List tmp = Arrays.asList(a1); Collections.sort(tmp, Collections.reverseOrder()); //list升序排序（整型） Collections.sort(l2); System.out.println(l2); //list降序排序（整型） Collections.sort(l2, Collections.reverseOrder()); System.out.println(l2); //list排序（自定义接口） Collections.sort(l1, new Comparator&lt;people&gt;() &#123; @Override public int compare(people o1, people o2) &#123; return Integer.compare(o1.age, o2.age); &#125; &#125;); System.out.println(l1.get(0).age + " " + l1.get(1).age + " " + l1.get(2).age); &#125;&#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(56) Merge Intervals]]></title>
    <url>%2F2018%2F11%2F06%2FLeetcode-56-Merge-Intervals%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a collection of intervals, merge all overlapping intervals. Example 1: 123Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: 123Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considerred overlapping. 解法这道题我最开始的思路是将输入中的区间依次加入结果list中，然后每次加入时与当前结果中所有的list相比较，结果发现比较的情况过于复杂，这个时候，如果将区间按照start排序然后再进行类似的处理，可以简化问题的处理方式。这告诉我们队一些复杂的数据进行排序可以简化处理流程。于是具体方法为，现将区间按start排序，每次先将区间加入结果list，再一一比较结果list中的相邻元素，做合并与删除操作。 具体代码如下： 1234567891011121314151617181920212223class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return Integer.compare(o1.start, o2.start); &#125; &#125;); List&lt;Interval&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; intervals.size(); i++) &#123; res.add(intervals.get(i)); for (int j = 0; j &lt; res.size() - 1; j++) &#123; Interval p = res.get(j); Interval q = res.get(j + 1); if (q.start &lt;= p.end) &#123; p.end = Math.max(q.end, p.end); res.remove(q); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(58) Length of Last Word]]></title>
    <url>%2F2018%2F11%2F05%2FLeetcode-58-Length-of-Last-Word%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: 12Input: &quot;Hello World&quot;Output: 5 解法这题看似简单，其实坑挺多的。 比如： 1.最后一个字符为空格的情况 2.最后的字符连续为空格的情况 3.多个连续空格的情况 因为采用的方法为从后往前扫描，所以只要注意前2个坑就好啦~ 具体代码如下： 12345678910111213141516class Solution &#123; public int lengthOfLastWord(String s) &#123; int res = 0; for (int i = s.length() - 1; i &gt;= 0; i--) &#123; if (s.charAt(i) == ' ') &#123; if (res != 0) &#123; break; &#125; else &#123; continue; &#125; &#125; res++; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(59) Spiral Matrix II]]></title>
    <url>%2F2018%2F11%2F05%2FLeetcode-59-Spiral-Matrix-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: 1234567Input: 3Output:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 解法之前的那道题是螺旋形遍历数组，这题是螺旋形生成数组，方法都差不多，设置边界与方向，为二维数组赋值，同样注意处理1和0输入的情况。感觉第二次写这类题思路顺畅了很多呢(^_^)~ 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] res = new int[n][n]; if (n == 1) &#123; res[0][0] = 1; return res; &#125; int max = n * n; int i = 0; int j = 0; int upbond = 0; int lowbond = n - 1; int leftbond = 0; int rightbond = n - 1; int dir = 0; res[i][j] = 1; for (int k = 2; k &lt;= max; k++) &#123; switch (dir) &#123; case 0: &#123; j++; res[i][j] = k; if (j == rightbond) &#123; dir = 1; upbond++; &#125; break; &#125; case 1: &#123; i++; res[i][j] = k; if (i == lowbond) &#123; dir = 2; rightbond--; &#125; break; &#125; case 2: &#123; j--; res[i][j] = k; if (j == leftbond) &#123; dir = 3; lowbond--; &#125; break; &#125; case 3: &#123; i--; res[i][j] = k; if (i == upbond) &#123; dir = 0; leftbond++; &#125; break; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(54) Spiral Matrix]]></title>
    <url>%2F2018%2F11%2F04%2FLeetcode-54-Spiral-Matrix%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: 1234567Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]Output: [1,2,3,6,9,8,7,4,5] Example 2: 1234567Input:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7] 解法这题就按照四个方向来进行数组的遍历，注意方向的转换与边界的处理，同时注意处理一行，一列为空的特殊情况。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (matrix.length == 0) &#123; return res; &#125; if (matrix[0].length == 1) &#123; for (int i = 0; i &lt; matrix.length; i++) &#123; res.add(matrix[i][0]); &#125; return res; &#125; if (matrix.length == 1) &#123; for (int i = 0; i &lt; matrix[0].length; i++) &#123; res.add(matrix[0][i]); &#125; return res; &#125; int size = matrix[0].length * matrix.length; int i = 0; int j = 0; int upbond = 1; int downbond = matrix.length - 1; int leftbond = 0; int rightbond = matrix[0].length - 1; int dir = 0; res.add(matrix[0][0]); for (int k = 0; k &lt; size - 1; k++) &#123; switch (dir) &#123; case 0: &#123; j++; res.add(matrix[i][j]); if (j == rightbond) &#123; dir = 1; rightbond--; &#125; break; &#125; case 1: &#123; i++; res.add(matrix[i][j]); if (i == downbond) &#123; dir = 2; downbond--; &#125; break; &#125; case 2: &#123; j--; res.add(matrix[i][j]); if (j == leftbond) &#123; dir = 3; leftbond++; &#125; break; &#125; case 3: &#123; i--; res.add(matrix[i][j]); if (i == upbond) &#123; dir = 0; upbond++; &#125; break; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(50) Pow(x, n)]]></title>
    <url>%2F2018%2F11%2F04%2FLeetcode-50-Pow-x-n%2F</url>
    <content type="text"><![CDATA[DescriptionImplement pow(x, n), which calculates x raised to the power n (xn). Example 1: 12Input: 2.00000, 10Output: 1024.00000 Example 2: 12Input: 2.10000, 3Output: 9.26100 Example 3: 123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1] 解法采用分治法提高运行效率。 可以用递归来折半计算，每次把n缩小一半，这样n最终会缩小到0，任何数的0次方都为1，这时候我们再往回乘，如果此时n是偶数，直接把上次递归得到的值算个平方返回即可，如果是奇数，则还需要乘上个x的值。还有一点需要引起我们的注意的是n有可能为负数，对于n是负数的情况，我们可以先用其绝对值计算出一个结果再取其倒数即可 具体代码如下： 123456789101112131415161718class Solution &#123; public double myPow(double x, long n) &#123; if (x == 1) &#123; return 1; &#125; if (n == 0) &#123; return 1; &#125; if (n &lt; 0) &#123; return 1 / myPow(x, -n); &#125; double half = myPow(x, n / 2); if (n % 2 == 0) &#123; return half * half; &#125; return half * half * x; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(49) Group Anagrams]]></title>
    <url>%2F2018%2F11%2F04%2FLeetcode-49-Group-Anagrams%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of strings, group anagrams together. Example: 1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lowercase. The order of your output does not matter. 解法看到这个题，第一时间想到的就是采用哈希的方法，因为同类字符串的字母组成是相同的，那么如何哈希呢？思路是：先统计一个字符串里含各个字符的个数（第一次哈希，用一个长度为26的int数组统计对应字母的个数），再将这个int数组转化为字母字符串（这一步可以把字母组成相同的字符串转化为一样的字符串），再建立哈希表（第二次哈希），key为字母组成字符串（就是上一步生成的字符串），value为list,list中存组成相同的字符串。 具体代码如下： 123456789101112131415161718192021222324252627class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); HashMap&lt;String, List&lt;String&gt;&gt; dict = new HashMap&lt;&gt;(); for (int i = 0; i &lt; strs.length; i++) &#123; int tmp[] = new int[26]; StringBuffer str = new StringBuffer(); for (int j = 0; j &lt; strs[i].length(); j++) &#123; tmp[strs[i].charAt(j) - 'a'] += 1; &#125; for (int j = 0; j &lt; 26; j++) &#123; for (int k = 0; k &lt; tmp[j]; k++) &#123; str.append((char) (j + 'a')); &#125; &#125; if (dict.containsKey(str.toString())) &#123; dict.get(str.toString()).add(strs[i]); &#125; else &#123; List&lt;String&gt; newlist = new ArrayList&lt;&gt;(); newlist.add(strs[i]); dict.put(str.toString(), newlist); &#125; &#125; res.addAll(dict.values()); return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(48) Rotate Image]]></title>
    <url>%2F2018%2F11%2F04%2FLeetcode-48-Rotate-Image%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: 12345678910111213Given input matrix = [ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2: 123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 解法根据观察，可以首先对原数组取其转置矩阵，然后把每行的数字翻转可得到结果，如下所示： 1 2 3 1 4 7 7 4 1 4 5 6 –&gt; 2 5 8 –&gt; 8 5 2 7 8 9 3 6 9 9 6 3 注意转置的时候，或者翻转的时候不要重复交换位置。所以转置的时候j从i开始，而翻转的时候到中轴线停止翻转。 具体代码如下： 1234567891011121314151617181920class Solution &#123; public void rotate(int[][] matrix) &#123; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = i; j &lt; matrix[0].length; j++) &#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; &#125; &#125; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; if (j &lt; matrix[0].length / 2) &#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[i][matrix[0].length - 1 - j]; matrix[i][matrix[0].length - 1 - j] = tmp; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(122) Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2018%2F11%2F03%2FLeetcode-122-Best-Time-to-Buy-and-Sell-Stock-II%2F</url>
    <content type="text"><![CDATA[DescriptionSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 1234Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: 12345Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. 解法这一题可以进行多次买卖，那只要第二天的值比今天的高，就可以在今天买入赚差价，若后天的更高，可以后天再抛出，以此类推，但每次赚的都是两日价格的差价。 具体代码如下： 1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int maxprofit = 0; for (int i = 0; i &lt; prices.length - 1; i++) &#123; if (prices[i] &lt; prices[i + 1]) &#123; maxprofit += (prices[i + 1] - prices[i]); &#125; &#125; return maxprofit; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(121) Best Time to Buy and Sell Stock]]></title>
    <url>%2F2018%2F11%2F03%2FLeetcode-121-Best-Time-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[DescriptionSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: 1234Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. 解法只需要遍历一次数组，用一个变量记录遍历过数中的最小值，然后每次计算当前值和这个最小值之间的差值最为利润，然后每次选较大的利润来更新。当遍历完成后当前利润即为所求。 具体代码如下： 12345678910111213class Solution &#123; public int maxProfit(int[] prices) &#123; int maxprofit = 0; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; if (min &gt; prices[i]) &#123; min = prices[i]; &#125; maxprofit = Math.max(maxprofit, prices[i] - min); &#125; return maxprofit; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(55) Jump Game]]></title>
    <url>%2F2018%2F11%2F03%2FLeetcode-55-Jump-Game%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: 123Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 解法贪心法解题，创建变量reach,记录可以到达的最远值，遍历数组，如果出现了reach不到当前i的情况，则说明终点已经不可能到达了。每次更新reach到的最大值。 具体代码如下： 123456789101112131415class Solution &#123; public boolean canJump(int[] nums) &#123; int reach = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (reach &lt; i || reach &gt;= nums.length - 1) &#123; break; &#125; reach = Math.max(reach, i + nums[i]); &#125; if (reach &gt;= nums.length - 1) &#123; return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(45) Jump Game II]]></title>
    <url>%2F2018%2F11%2F03%2FLeetcode-45-Jump-Game-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: 1234Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index. 解法贪心算法解题，设置两个指针变量，pre指向前一步跳的最远的点，cur指向这一步跳的最远的点，每一次计算cur时，都通过0到pre中的点选，选择跳的最远的距离。如果pre和cur相等，说明都是0，原地跳，失败。 具体代码如下： 1234567891011121314151617class Solution &#123; public int jump(int[] nums) &#123; int pre = 0; int cur = 0; int end = nums.length - 1; int res = 0; while (cur &lt; end) &#123; res++; pre = cur; for (int i = 0; i &lt;= pre; i++) &#123; cur = Math.max(cur, i + nums[i]); &#125; if (pre == cur) return -1; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(44) Wildcard Matching]]></title>
    <url>%2F2018%2F11%2F03%2FLeetcode-44-Wildcard-Matching%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for &#39;?&#39; and &#39;*&#39;. 12&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;*&quot;Output: trueExplanation: &apos;*&apos; matches any sequence. Example 3: 12345Input:s = &quot;cb&quot;p = &quot;?a&quot;Output: falseExplanation: &apos;?&apos; matches &apos;c&apos;, but the second letter is &apos;a&apos;, which does not match &apos;b&apos;. Example 4: 12345Input:s = &quot;adceb&quot;p = &quot;*a*b&quot;Output: trueExplanation: The first &apos;*&apos; matches the empty sequence, while the second &apos;*&apos; matches the substring &quot;dce&quot;. Example 5: 1234Input:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;Output: false 解法这道题花的时间挺久，主要是思路难理顺。算法采用的是回溯算法，由题意，？匹配任意一个字符，*匹配任意字符串，我们先考虑采取指针pcur和scur分别指向当前待匹配的字符，那么在匹配过程中，会碰到如下几种情况： 情况1：p[pcur] = s[scur] or p[cur] = ‘?’ 匹配成功，pcur和scur分别加一指向下一个字符 情况2：p[pcur] = ‘*‘ 这个时候就想着怎么在s中寻找与*配对的字符串，匹配多少个成了需要考虑的问题，那么我们不妨从匹配0个开始尝试，如果匹配0个以后后续字符串出现了无法匹配的情况，则回到星号的位置重新进行匹配，尝试匹配个数比上一次多一个的匹配。为了达到此目的，我们需要添加两个指示量:pstar指向p中*的位置，sstar指向s中下一个*可以匹配的字符位置。 于是情况的划分可变为： 情况1：p[pcur] = s[scur] or p[cur] = ‘?’ 匹配成功，pcur和scur分别加一指向下一个字符 情况2：p[pcur] = ‘*‘ 记录pstar与sstar的位置，并默认匹配0个字符，所以pcur需要+1而scur保持不变 情况3：以上两种情况都不满足，但是之前有过*号，那么说明按照之前的方法匹配出现了问题，需要重新考虑*号的匹配问题，将*号匹配的字符串长度+1,重新将pcur指向*号后的下一个字符，sstar+1,然后将s中待匹配的下一个字符设为现在的sstar值。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean isMatch(String s, String p) &#123; int scur = 0; int pcur = 0; int sstar = 0; int pstar = -1; while (scur &lt; s.length()) &#123; //相当或问号的情况 if (pcur &lt; p.length() &amp;&amp; (p.charAt(pcur) == s.charAt(scur) || p.charAt(pcur) == '?')) &#123; pcur++; scur++; &#125; //碰到了星号，pstar记录星号位置，sstar记录星号可以匹配的下一个字符的位置，初始情况星号匹配0个字符 else if (pcur &lt; p.length() &amp;&amp; p.charAt(pcur) == '*') &#123; pstar = pcur; sstar = scur; pcur++; &#125; //这个时候匹配出现问题了，因为不满足以上两种情况，所以考虑对星号的处理，星号比上一次多匹配一个字符 //将下一个待匹配的p字符设为*后的第一个字符，sstar+1（就是比上一次多匹配一个的意思)，scur设为下一个待匹配的s字符 else if (pstar != -1) &#123; pcur = pstar + 1; sstar++; scur = sstar; &#125; else &#123; return false; &#125; &#125; //处理结尾的多余*号 while (pcur &lt; p.length()) &#123; if (p.charAt(pcur) == '*') &#123; pcur++; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(43) Multiply Strings]]></title>
    <url>%2F2018%2F10%2F16%2FLeetcode-43-Multiply-Strings%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: 12Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;Output: &quot;6&quot; Example 2: 12Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;Output: &quot;56088&quot; Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. 解法其实就是大数相乘的算法，这里需要注意的是在每次做乘法运算时，不考虑进位问题，直接把结果存入结果数组的对应位上，最后统一处理进位问题。注意，计算从数组的尾部开始。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String multiply(String num1, String num2) &#123; int l1 = num1.length(); int l2 = num2.length(); int[] result = new int[l1 + l2]; int k = l1 + l2 - 1; for (int j = l2 - 1; j &gt;= 0; j--) &#123; int kk = k; for (int i = l1 - 1; i &gt;= 0; i--) &#123; result[kk] += (num2.charAt(j) - '0') * (num1.charAt(i) - '0'); kk--; &#125; k--; &#125; for (k = l1 + l2 - 1; k &gt;= 0; k--) &#123; int j = result[k] / 10; result[k] = result[k] % 10; if (k &gt;= 1) &#123; result[k - 1] += j; &#125; &#125; StringBuffer s = new StringBuffer(); int i = 0; for (; i &lt; result.length &amp;&amp; result[i] == 0; i++) ; for (; i &lt; result.length; i++) &#123; s.append(result[i]); &#125; if (s.length() == 0) &#123; return "0"; &#125; String res = new String(s); return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(42) Trapping Rain Water]]></title>
    <url>%2F2018%2F10%2F15%2FLeetcode-42-Trapping-Rain-Water%2F</url>
    <content type="text"><![CDATA[DescriptionGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: 12Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 解法遍历高度，如果此时栈为空，或者当前高度小于等于栈顶高度，则把当前高度的坐标压入栈，注意我们不直接把高度压入栈，而是把坐标压入栈，这样方便我们在后来算水平距离。当我们遇到比栈顶高度大的时候，就说明有可能会有坑存在，可以装雨水。此时我们栈里至少有一个高度，如果只有一个的话，那么不能形成坑，我们直接跳过，如果多余一个的话，那么此时把栈顶元素取出来当作坑，新的栈顶元素就是左边界，当前高度是右边界，只要取二者较小的，减去坑的高度，长度就是右边界坐标减去左边界坐标再减1，二者相乘就是盛水量啦。注意，每次碰到比栈顶高的条目，一直做坑的探查，直到碰到比栈顶高的或栈为空再将该条目入栈。每次运算，只计算了比当前条目矮的部分的水，没有计算当前条目高度以上的水。 具体代码如下： 12345678910111213141516171819202122class Solution &#123; public int trap(int[] height) &#123; Stack&lt;Integer&gt; s = new Stack(); if (height.length &lt;= 2) &#123; return 0; &#125; int result = 0; int i = 0; while (i &lt; height.length) &#123; if (s.empty() || height[i] &lt; height[s.peek()]) &#123; s.push(i++); &#125; else &#123; int con = s.pop(); if (s.empty()) &#123; continue; &#125; result += (Math.min(height[i], height[s.peek()]) - height[con]) * (i - s.peek() - 1); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之红黑树]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树为什么需要红黑树红黑树首先是一棵二叉查找树，但它并不是完全平衡的，引入红黑树的目的在于相较于二叉平衡树，他维持自身所需要的旋转次数较少，统计性能较二叉平衡树更好。 主要性质红黑树的5条性质如下：1.每个结点要么是红的要么是黑的。2.根结点是黑的。3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的，且不含数据。4.如果一个结点是红的，那么它的两个儿子都是黑的。5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 (black property) 2-4树（红黑树的另一种无色形式）2-4树又称为2-3-4 树（数字代表可能的子节点个数），树中节点和存储的元素符合如下性质要求：任一节点只能是 2 度节点、3 度节点或 4 度节点，不存在元素数为 0 的节点。2 度节点：包含 1 个元素的节点将只能有 2 个子节点；3 度节点：包含 2 个元素的节点将只能有 3 个子节点；4 度节点：包含 3 个元素的节点将只能有 4 个子节点；所有叶子节点都拥有相同的深度（depth）。元素始终保持排序顺序。 2-4树转化为红黑树： 4度节点：中间的升为黑节点，其余的变为红节点 3度节点：变为一红一黑节点，红节点为黑节点的儿子 1度节点：变为黑节点 红黑树转2-4树： 将红节点并入父亲（黑节点） 基本操作在现实实现中，节点一般包含了color,key,left,right,parent四个属性，并且将root的parent指向nil节点。 为方便理解，这里结合伪代码进行解释。 插入操作：每次在红黑树的底部进行插入操作，并将新插入的节点颜色规定设为红色，然后再维护整棵红黑树，进行对应的重新染色或旋转。 12345678910111213141516171819202122232425262728//插入函数，传入树的结构与新插入元素的引用RB-INSERT(T,z): //双指针为了找到新插入元素的父节点 y = T.nil; x = T.root; //找到插入的位置 while x!=T.nil: y = x; if(x.key&gt;z.key): x = x.left; else: x = x.right z.p = y; //树为空，作为根节点 if(y == T.nil): T.root = z; //作为左节点或右节点 else if(z.key&gt;y.key): y.right = z; else: y.left = z; //将新插入的节点左右设空并染色为红色 z.left = T.nil; z.right = T.nil; z.color = RED; //可能引发冲突，需要对红黑树进行重新染色或旋转 RB-INSERT-FIXUP(T,z); 接下来来看红黑树的维护操作。插入一个红节点后，若其父节点为黑色，则没有冲突发生，若其父节点为红色，则违反了红黑树的性质，需要进行重新染色或旋转，这里，冲突又分为了6种情况，因为对称性，其中3种是另外3种的镜像。所以这里我们只分析3种情况。 情况1：父节点为红，父节点的兄弟节点也为红 这种情况比较好处理，直接进行重新染色就好，将父节点与叔叔节点染为黑色，将爷爷节点染为红色，然后再对爷爷节点进行冲突检查与维护。 情况2：父节点为红，父节点的兄弟节点为黑或为空，其新插入节点，父节点，爷爷节点不在一条直线上。这个时候，我们需要先以父节点为旋转中心做一次旋转，将爷父孙三点先转到一条直线上，然后构成了接下来讨论的情况3。 情况3：父节点为红，父节点的兄弟节点为黑或为空，其新插入节点，父节点，爷爷节点在一条直线上。这个时候需要以爷爷节点为中心做一次旋转，使父节点成为爷孙节点的新父节点。 先来完成左旋与右旋的代码： 12345678910111213141516171819202122232425262728293031LEFT-ROTATE(T, x): y = x.right //找到新的中心节点 x.right = y.left //将y的左子树接到x上 if y.left != T.nil y.left.p = x y.p = x.p //将x的父节点作为y的父节点 if x.p == T.nil T.root =y else if x == x.p.left x.p.left = y else x.p.right = y y.left = x //将x作为新的中心节点y的子节点 x.p = yRIGHT-ROTATE(T, x): y = x.left //找到新的中心节点 x.left = y.right //将y的右子树接到x上 if y.right != T.nil y.right.p = x y.p = x.p //将x的父节点作为y的父节点 if x.p == T.nil T.root =y else if x == x.p.left x.p.left = y else x.p.right = y y.right = x //将x作为新的中心节点y的子节点 x.p = y 接下来就是维护的部分，分为6种情况来写： 12345678910111213141516171819202122232425262728293031RB-INSERT-FIXUP(T,z): while z.p.color == RED: if z.p == z.p.p.left: y = z.p.p.right; if y.color == RED: //情况1 z.p.color = BLACK; y.color = BLACK; z.p.p.color = RED; z = z.p.p; else if z == z.p.right: //情况2 z = z.p; LEFT-ROTATE(T,z); z.p.color = BLACK; //情况3，先染色再旋转 z.p.p.color = RED; RIGHT-ROTATE(T,z.p.p); else: y = z.p.p.left; if y.color == RED: //镜像情况1 z.p.color = BLACK; y.color = BLACK; z.p.p.color = RED; z = z.p.p; else: if z == z.p.left: //镜像情况2 z = z.p; RIGHT-ROTATE(T,z); z.p.color = BLACK; //镜像情况3 z.p.p.color = RED; LEFT-ROTATE(T,z.p.p); T.root.color = BLACK; //确保根节点为黑 删除操作未完待续]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之堆(Heap)]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86-Heap%2F</url>
    <content type="text"><![CDATA[堆(Heap)堆（heap）也被称为优先队列（priority queue）。队列中允许的操作是先进先出（FIFO），在队尾插入元素，在队头取出元素。而堆也是一样，在堆底插入元素（并不是直接插到堆底完事，而是从堆底往上浮到对应的位置）在堆顶取出元素，但是堆中元素的排列不是按照到来的先后顺序，而是按照一定的优先顺序排列的。这个优先顺序可以是元素的大小或者其他规则。 堆可以看成一个二叉树，所以可以考虑使用二叉树的表示方法来表示堆。但是因为堆中元素按照一定的优先顺序排列，因此可以使用更简单的方法：数组，来表示，这样可以节省子节点指针空间，并且可以快速访问每个节点。 下面以最小堆为例，给出了一些堆的基本操作的伪代码，便于理解各项操作原理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*A是数组，假设数组的index从1开始而非从0开始*///i是堆顶的index,维护堆，基于i以下已经是最小堆的假设//时间复杂度为O(logn)MIN-HEAPIFY(A,i): l = i*2; //左儿子 r = i*2+1; //右儿子 small = i; if(l &lt;= A.size() &amp;&amp; l &lt; A[i]): small = l; if(r &lt;= A.size() &amp;&amp; r &lt; A[i]): small = r; if(small != i): swap(A[i],A[small]); MIN-HEAPIFY(A,small);//取出最小堆中的最小元素,为保证结构，取出后将堆中的最后一个元素置于堆顶，然后下沉//时间复杂度为O(logn)HEAP-EXTRACT-MIN(A): if(A.size() &lt; 1): error; min = A[1]; A[1] = A[A.size()]; A.size -= 1; MIN-HEAPIFY(A,1); return min;//向堆中插入元素,先将元素置于底部，然后进行上浮//时间复杂度为O(logn)MIN-HEAP-INSERT(A,key): A.size() += 1; A[A.size()] = key; i = A.size(); // 上浮，i/2为i的父节点 while(i &gt; 1 and A[i/2] &gt; A[i]): swap(A[i/2],A[i]); i = i/2;//c从数组构造堆,思想是从第一个非叶子节点起，对于每个节点维护堆//可以证明，构建堆的时间复杂度为O(n),而非O(nlogn)BUILD-MIN-HEAP(A): for(i = A.size/2; i &gt;= 1; i--): MIN-HEAPIFY(A,i);//从小到大的堆排序,思想是构造一个最大堆，每次将堆顶元素与堆的最后一项交换位置//将堆的大小减一，往复操作，得到从小到大的数组//时间复杂度为O(nlogn)HEAP-SORT(A): BUILD-MAX-HEAP(A); for(i = A.size(); i&gt;=2; i--): swap(A[i],A[1]); A.size -= 1; MAX-HEAPIFY(A,1);]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(41) First Missing Positive]]></title>
    <url>%2F2018%2F10%2F12%2FLeetcode-41-First-Missing-Positive%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an unsorted integer array, find the smallest missing positive integer. Example 1: 12Input: [1,2,0]Output: 3 Example 2: 12Input: [3,4,-1,1]Output: 2 Example 3: 12Input: [7,8,9,11,12]Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. 解法这道题要求时间复杂度为O(n)，所以不可能先做复杂的诸如排序之类的预处理。那么可以采取巧妙的哈希方法，建立一个哈希表，首先扫描一遍数组，将元素插入到哈希表中，并记录这个数组的最大值。之后从1开始到最大值，只要出现了谁不在哈希表里，即为所需要的正数。然而这种方法需要额外的空间（哈希表）。 那么利用同样的思想，将方法做些许的改进，不开额外的空间，利用数组自身进行哈希。具体实现方法是，将x存入index为x-1的位置，即nums[i] = i+1;最后从头到尾扫描数组，若某个槽不满足这个条件，那么寻找的正整数就是index+1了。挺神奇的。为了构建这个数组，需遍历一遍数组，对每个槽，将槽中元素交换到指定位置，知道数组中没有现在槽中元素所对应的位置，处理下一个槽。 具体代码如下： 1234567891011121314151617181920class Solution &#123; public int firstMissingPositive(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[i] != nums[nums[i] - 1]) &#123; int tmp1 = nums[i]; int tmp2 = nums[nums[i] - 1]; nums[i] = tmp2; nums[tmp1 - 1] = tmp1; &#125; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != i + 1) &#123; return i + 1; &#125; &#125; return nums.length + 1; &#125;&#125; 利用哈希结构的代码： 12345678910111213141516171819class Solution &#123; public int firstMissingPositive(int[] nums) &#123; if(nums == null)&#123; return -1; &#125; HashMap&lt;Integer,Integer&gt; helper = new HashMap&lt;&gt;(); for(int i = 0;i&lt;nums.length;i++)&#123; if(nums[i]&gt;0)&#123; helper.put(nums[i],nums[i]); &#125; &#125; for(int i = 1;;i++)&#123; if(!helper.containsKey(i))&#123; return i; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(40) Combination Sum II]]></title>
    <url>%2F2018%2F10%2F12%2FLeetcode-40-Combination-Sum-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: 12345678Input: candidates = [10,1,2,7,6,1,5], target = 8,A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] Example 2: 123456Input: candidates = [2,5,2,1,2], target = 5,A solution set is:[ [1,2,2], [5]] 解法这题只需要在Leetcode(39)上做一点点的改动，这里不允许一个数重复利用，故只需要将下一次搜索的起点改为i+1即可，同时考虑去除重复输出的情况，即在start之后进行分叉搜索时，若nums[i] = nums[i-1]时，说明已经考虑过了，直接进入下一次循环。 具体代码如下： 12345678910111213141516171819202122232425262728293031class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); Arrays.sort(candidates); helper(candidates, target, tmp, 0); return res; &#125; void helper(int[] candidates, int target, List&lt;Integer&gt; tmp, int start) &#123; if (target == 0) &#123; res.add(new ArrayList&lt;&gt;(tmp)); return; &#125; else if (target &lt; 0) &#123; return; &#125; else &#123; for (int i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123; if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123; continue; &#125; target = target - candidates[i]; tmp.add(candidates[i]); helper(candidates, target, tmp, i + 1); target = target + candidates[i]; tmp.remove(tmp.size() - 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(39) Combination Sum]]></title>
    <url>%2F2018%2F10%2F12%2FLeetcode-39-Combination-Sum%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: 123456Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] Example 2: 1234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] 解法最开始想用动态规划来解这道题，但因为要输出是哪些数组成的答案，故不太方便。采用深度优先搜索的一般方法即可解题。为了进行剪枝，需对数组进行从大到小排序，如果碰到比target值大的，那么显然之后的数都不需要进行搜索了。同时，需要注意重复查找的问题，比如 input:[2,3,6,7] 7时，可能出现[[2,2,3],[2,3,2],[3,2,2],[7]]的情况，为了解决重复，需要让搜索时按一定的顺序进行，此题的解决方案是下一个加入序列搜索的数一定大于等于当前搜索的数，引入start参数，这样就保证了结果的唯一性。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); Arrays.sort(candidates); helper(candidates, target, tmp, 0); return res; &#125; void helper(int[] candidates, int target, List&lt;Integer&gt; tmp, int start) &#123; if (target == 0) &#123; res.add(new ArrayList&lt;&gt;(tmp)); return; &#125; else if (target &lt; 0) &#123; return; &#125; else &#123; for (int i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123; target = target - candidates[i]; tmp.add(candidates[i]); helper(candidates, target, tmp, i); target = target + candidates[i]; tmp.remove(tmp.size() - 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(37) Sudoku Solver]]></title>
    <url>%2F2018%2F10%2F12%2FLeetcode-37-Sudoku-Solver%2F</url>
    <content type="text"><![CDATA[DescriptionWrite a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character &#39;.&#39;. A sudoku puzzle… …and its solution numbers marked in red. Note: The given board contain only digits 1-9 and the character &#39;.&#39;. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9. 解法填表格问题，深度优先搜索。只需要对每一个插入的新元素进行合法性判断即可，因为之前插入的数一定是合法的。注意在搜索失败时需将赋值的点还原为未赋值的状态，相当于回溯。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123; public void solveSudoku(char[][] board) &#123; if (board.length != 9 || board[0].length != 9) &#123; return; &#125; dfs(board, 0, 0); &#125; boolean dfs(char[][] board, int row, int col) &#123; if (row == 9) &#123; return true; &#125; if (board[row][col] == '.') &#123; for (int i = 1; i &lt;= 9; i++) &#123; board[row][col] = (char) ('0' + i); if (isValid(board, row, col)) &#123; if (col == 8) &#123; if (dfs(board, row + 1, 0)) &#123; return true; &#125; &#125; else &#123; if (dfs(board, row, col + 1)) &#123; return true; &#125; &#125; &#125; board[row][col] = '.'; &#125; return false; &#125; else &#123; if (col == 8) &#123; return dfs(board, row + 1, 0); &#125; else &#123; return dfs(board, row, col + 1); &#125; &#125; &#125; //判读插入数组是否合法 boolean isValid(char[][] board, int row, int col) &#123; for (int i = 0; i &lt; board.length; i++) &#123; if (board[i][col] == board[row][col] &amp;&amp; i != row) &#123; return false; &#125; &#125; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[row][j] == board[row][col] &amp;&amp; j != col) &#123; return false; &#125; &#125; for (int i = row / 3 * 3; i &lt; row / 3 * 3 + 3; i++) &#123; for (int j = col / 3 * 3; j &lt; col / 3 * 3 + 3; j++) &#123; if (board[i][j] == board[row][col] &amp;&amp; (i != row || j != col)) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(53) Maximum Subarray]]></title>
    <url>%2F2018%2F10%2F11%2FLeetcode-53-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 解法先写写O(n)的算法，动态规划的思想，对于当前元素，和最大有两种情况，要么是以它开始的序列和最大，要么是将它加入之前的序列。即dp[i] = max(nums[i],dp[i-1]+nums[i]). dp代表以当前元素结尾的数组的和的最大值。 具体代码如下： 123456789101112131415161718192021class Solution &#123; public int maxSubArray(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int[] dp = new int[nums.length]; dp[0] = nums[0]; int res = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; dp[i - 1] + nums[i]) &#123; dp[i] = nums[i]; &#125; else &#123; dp[i] = dp[i - 1] + nums[i]; &#125; if (res &lt; dp[i]) &#123; res = dp[i]; &#125; &#125; return res; &#125;&#125; 下面来看O(logn)的算法，分治法： 一个子串的最大和是其左子串最大和、右子串最大和、包含中间数的最大和这三者的最大和。根据这种思路分治，关键是合并这一步，即计算包含中间那个数的最大和。这里顺带提一下终止条件，会出现start&gt;=end主要是因为传入的参数是mid-1和mid+1,导致可能大于的情况发生。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution &#123; public int maxSubArray(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; return helper(nums, 0, nums.length - 1); &#125; int helper(int[] nums, int start, int end) &#123; if (start &gt;= end) &#123; return nums[start]; &#125; int mid = (start + end) / 2; int leftmax = helper(nums, start, mid - 1); int rightmax = helper(nums, mid + 1, end); int middlemax = nums[mid]; int sum = nums[mid]; for (int i = mid - 1; i &gt;= start; i--) &#123; sum += nums[i]; middlemax = middlemax &gt; sum ? middlemax : sum; &#125; sum = middlemax; for (int i = mid + 1; i &lt;= end; i++) &#123; sum += nums[i]; middlemax = middlemax &gt; sum ? middlemax : sum; &#125; return Math.max(leftmax, Math.max(rightmax, middlemax)); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(34) Find First and Last Position of Element in Sorted Array]]></title>
    <url>%2F2018%2F10%2F11%2FLeetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: 12Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Example 2: 12Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 解法看到O(logn)的时间复杂度，就要想到每次应该把处理的范围减半，这样一来，只有二分和树形结构能达到此目的，对于这个题目，当然是二分啦。可以先用二分查找查找到target，然后以target为中心向左右查找最早和最晚出现的节点。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] res = &#123;-1, -1&#125;; if (nums.length == 0) &#123; return res; &#125; int start = 0; int end = nums.length - 1; int mid; int tmp = -1; while (start &lt;= end) &#123; mid = (start + end) / 2; if (nums[mid] == target) &#123; tmp = mid; break; &#125; if (nums[mid] &lt; target) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; if (tmp == -1) &#123; return res; &#125; int i = tmp; while (i &gt;= 0) &#123; if (nums[i] != target) &#123; break; &#125; res[0] = i; i--; &#125; i = tmp; while (i &lt; nums.length) &#123; if (nums[i] != target) &#123; break; &#125; res[1] = i; i++; &#125; return res; &#125;&#125; 当然，严格而言，以上算法的时间复杂度的最坏情况O(n)，因为当所有元素均相同且为target需要遍历整个数组，这个时候为了达到严格的时间复杂度要求，可以以找到最小和找到最大的对应坐标为终止条件，更改终止条件代码，最小的index的特征有index = 0或nums[index-1]!=target，最大的条件同理。同时，若不满足该终止条件而又是target的话，若为寻找最小index，下一次搜索应该变化end，寻找最大index，下一次搜索应向右变化start，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] res = &#123;-1, -1&#125;; if (nums.length == 0) &#123; return res; &#125; int start = 0; int end = nums.length - 1; int mid; int tmp = -1; while (start &lt;= end) &#123; mid = (start + end) / 2; if (nums[mid] == target) &#123; if (mid == 0) &#123; tmp = mid; break; &#125; if (mid - 1 &gt;= 0) &#123; if (nums[mid - 1] != target) &#123; tmp = mid; break; &#125; &#125; &#125; if (nums[mid] &lt; target) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; if (tmp == -1) &#123; return res; &#125; res[0] = tmp; start = 0; end = nums.length - 1; tmp = -1; while (start &lt;= end) &#123; mid = (start + end) / 2; if (nums[mid] == target) &#123; if (mid == nums.length - 1) &#123; tmp = mid; break; &#125; if (mid + 1 &lt;= nums.length - 1) &#123; if (nums[mid + 1] != target) &#123; tmp = mid; break; &#125; &#125; &#125; if (nums[mid] &lt;= target) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; res[1] = tmp; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(32) Longest Valid Parentheses]]></title>
    <url>%2F2018%2F10%2F11%2FLeetcode-32-Longest-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. Example 1: 123Input: &quot;(()&quot;Output: 2Explanation: The longest valid parentheses substring is &quot;()&quot; Example 2: 123Input: &quot;)()())&quot;Output: 4Explanation: The longest valid parentheses substring is &quot;()()&quot; 解法括号匹配一般采用栈来处理，需要定义个start变量来记录合法括号串的起始位置，我们遍历字符串，如果遇到左括号，则将当前下标压入栈，如果遇到右括号，如果当前栈为空，说明之前没有左括号与之匹配，则将下一个坐标位置记录到start，如果栈不为空，则成功匹配这个右括号，将栈顶元素取出，此时若栈为空，说明从start位置到该右括号的所有括号均已匹配，更新结果和i - start + 1中的较大值，否则说明从当前出栈的前一个左括号的下一个开始均完成匹配（之所以不直接用匹配的左括号位置作为被减数是为了”(()()”的情况），更新结果和i - 栈顶元素中的较大值。 具体代码如下： 12345678910111213141516171819202122232425262728293031class Solution &#123; public int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int res = 0; int start = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') &#123; stack.push(i); &#125; else &#123; if (stack.empty()) &#123; start = i + 1; &#125; else &#123; stack.pop(); if (stack.empty()) &#123; res = max(res, i - start + 1); &#125; else &#123; res = max(res, i - stack.peek()); &#125; &#125; &#125; &#125; return res; &#125; int max(int a, int b) &#123; if (a &gt; b) &#123; return a; &#125; return b; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(33) Search in Rotated Sorted Array]]></title>
    <url>%2F2018%2F10%2F10%2FLeetcode-33-Search-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[DescriptionSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1: 12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2: 12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 解法查找的题，又要求时间复杂度为O(logn)，显然是要采用二分的算法，二分可以一次将查找范围缩小一半。而二分的前提应该是查找数组为有序的，观察一下这道题的数组情况。 对于数组[0 1 2 4 5 6 7] 共有下列七种旋转方法： 0 1 2 4 5 6 7 7 0 1 2 4 5 6 6 7 0 1 2 4 5 5 6 7 0 1 2 4 4 5 6 7 0 1 2 2 4 5 6 7 0 1 1 2 4 5 6 7 0 可以发现，无论如何旋转，至少有一半的序列都是有序的，仔细想想，也很有道理。所以，可以随意选取当前查找范围的一半，如果当前无序，则另一半必有序。以右区间为例，有序的判断条件为nums[mid] &lt;= nums[right]。每次只处理有序区间，判断当前元素是否位于该有序区间之中，是，则将区间缩小为有序区间，否，则将区间缩小为无序区间，无序区间下一次循环再判断其左右子区间有序状态做进一步地缩小。这样，每次缩小的范围为当前区间的一半。 具体代码如下： 123456789101112131415161718192021222324252627class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid; while (left &lt;= right) &#123; mid = (left + right) / 2; if (nums[mid] == target) &#123; return mid; &#125; if (nums[mid] &lt;= nums[right]) &#123; if (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; else &#123; if (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(95) Unique Binary Search Trees II]]></title>
    <url>%2F2018%2F10%2F09%2FLeetcode-95-Unique-Binary-Search-Trees-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST's shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解法这道题是基于之前算有多少棵不同的树的。对于此类问题，一般采用递归解法。首先，对于一棵BST树的某节点而言，其左子树的所有节点值一定是小于其右子树的所有节点值的。故对于1到n的序列，可以选择一块范围为1到n的挡板将序列分为[1..i-1],i,[i+1,n]三部分，i为根，其他为左右子树的节点，然后对于左右子树递归地进行操作。注意，设计的函数的返回值是一个x棵子树根节点的List，每次只需将根节点插入其中即可。而对于一个根节点，可以从其左右子树的根序列中选取根节点作为左右的儿子，而以此达到遍历所有情况的目的。 具体代码如下： 123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if (n == 0) &#123; return new ArrayList&lt;&gt;(); &#125; return helper(1, n); &#125; List&lt;TreeNode&gt; helper(int start, int end) &#123; List&lt;TreeNode&gt; result = new ArrayList&lt;&gt;(); if (start &gt; end) &#123; result.add(null); return result; &#125; for (int i = start; i &lt;= end; i++) &#123; List&lt;TreeNode&gt; left = helper(start, i - 1); List&lt;TreeNode&gt; right = helper(i + 1, end); for (int j = 0; j &lt; left.size(); j++) &#123; for (int k = 0; k &lt; right.size(); k++) &#123; TreeNode root = new TreeNode(i); root.left = left.get(j); root.right = right.get(k); result.add(root); &#125; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(96) Unique Binary Search Trees]]></title>
    <url>%2F2018%2F10%2F09%2Flc96%2F</url>
    <content type="text"><![CDATA[DescriptionGiven n, how many structurally unique BST’s (binary search trees) that store values 1 … n? Example: 12345678910Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST's: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解法这道题实际上是卡塔兰数的一个例子，类似于斐波那契数。递推发现规律。 对于n = 0，此时为空树，result = 1。 对于n = 1，此时根有一种情况，result = 1。 对于n = 2，此时根有两种情况，result = 根为1的情况+根为2的情况，由于取一个数为根后，探讨一棵树的组成情况，看他的左右子树有多少种组合。对于n = 2，可以左子树放一个点，右子树放零个点，也可以相反，即result[0]*result[1] + result[1]*result[0]. 以此类推，n = 3：result[0] * result[2] + result[1]* result[1]+result[2] * result[0]. 于是有： 具体代码如下： 1234567891011121314151617class Solution &#123; public int numTrees(int n) &#123; List&lt;Integer&gt; dp = new ArrayList&lt;&gt;(); dp.add(1); dp.add(1); for (int i = 2; i &lt;= n; i++) &#123; dp.add(0); for (int j = 0; j &lt; i; j++) &#123; int tmp = dp.get(i); tmp += dp.get(j) * dp.get(i - 1 - j); dp.remove(i); dp.add(tmp); &#125; &#125; return dp.get(n); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(145) Binary Tree Postorder Traversal]]></title>
    <url>%2F2018%2F10%2F04%2Fleetcode145-binary-tree-postorder-traversal%2F</url>
    <content type="text"><![CDATA[Description:Given a binary tree, return the postorder traversal of its nodes’ values. 解法：递归解题，具体代码如下：12345678910111213141516class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; output = new ArrayList(); helper(root,output); return output; &#125; void helper(TreeNode root,List&lt;Integer&gt; output)&#123; if(root == null)&#123; return; &#125; helper(root.left,output); helper(root.right,output); output.add(root.val); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(144) Binary Tree Preorder Traversal]]></title>
    <url>%2F2018%2F10%2F04%2Fleetcode144-binary-tree-preorder-traversal%2F</url>
    <content type="text"><![CDATA[Description:Given a binary tree, return the preorder traversal of its nodes’ values. 解法：递归解题，具体代码如下：12345678910111213141516class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; output = new ArrayList(); helper(root,output); return output; &#125; void helper(TreeNode root,List&lt;Integer&gt; output)&#123; if(root == null)&#123; return; &#125; output.add(root.val); helper(root.left,output); helper(root.right,output); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(94) Binary Tree Inorder Traversal]]></title>
    <url>%2F2018%2F10%2F04%2Fleetcode94-binary-tree-inorder-traversal%2F</url>
    <content type="text"><![CDATA[Description:Given a binary tree, return the inorder traversal of its nodes’ values. Example: Input: [1,null,2,3]123451 \ 2 /3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? 解法：直接递归的方法解题，具体代码如下：123456789101112131415class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; output = new ArrayList(); helper(root,output); return output; &#125; void helper(TreeNode root,List&lt;Integer&gt; output)&#123; if(root == null)&#123; return; &#125; helper(root.left,output); output.add(root.val); helper(root.right,output); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(687) Longest Univalue Path]]></title>
    <url>%2F2018%2F10%2F01%2Fleetcode687-longest-univalue-path%2F</url>
    <content type="text"><![CDATA[Description:Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them. Example 1: Input: 5 / \ 4 5 / \ \ 1 1 5 Output: 2 Example 2: Input: 1 / \ 4 5 / \ \ 4 4 5 Output: 2 Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. 解法：这道题让我们求最长的相同值路径，对于这种树的路径问题，递归是不二之选。在递归函数中，我们首先对其左右子结点调用递归函数，得到其左右子树的最大相同值路径，下面就要来看当前结点和其左右子结点之间的关系了，如果其左子结点存在且和当前节点值相同，则left自增1，否则left重置0；同理，如果其右子结点存在且和当前节点值相同，则right自增1，否则right重置0。然后用left+right来更新结果res。而调用当前节点值的函数只能返回left和right中的较大值，因为如果还要跟父节点组path，就只能在左右子节点中选一条path，当然选值大的那个了，具体代码如下：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; int res; public int longestUnivaluePath(TreeNode root) &#123; res = 0; helper(root); return res; &#125; public int helper(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return 0; &#125; int left = helper(root.left); int right = helper(root.right); if (root.left != null &amp;&amp; root.val == root.left.val) &#123; left++; &#125; else &#123; left = 0; &#125; if (root.right != null &amp;&amp; root.val == root.right.val) &#123; right++; &#125; else &#123; right = 0; &#125; if (left + right &gt; res) &#123; res = left + right; &#125; if (left &gt; right) &#123; return left; &#125; return right; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(60) Permutation Sequence]]></title>
    <url>%2F2018%2F10%2F01%2Fleetcode60-permutation-sequence%2F</url>
    <content type="text"><![CDATA[Description:The set [1,2,3,...,_n_] contains a total of _n_! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for _n_ = 3: &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; &quot;321&quot; Given _n_ and _k_, return the _k_th permutation sequence. Note: Given _n_ will be between 1 and 9 inclusive. Given _k_ will be between 1 and _n_! inclusive. Example 1: Input: n = 3, k = 3Output: “213” Example 2: Input: n = 4, k = 9Output: “2314” 解法：这道题主要是找规律，因为不必要把所有的排列都列出来，所以以 n = 4 k = 17为例： 首先我们要知道当n = 3时，其排列组合共有3! = 6种，当n = 4时，其排列组合共有4! = 24种，所有排列组合情况如下： 12341243132413421423143221342143231423412413243131243142321432413412 &lt;— k = 173421412341324213423143124321 我们可以发现，每一位上1,2,3,4分别都出现了6次，当最高位上的数字确定了，第二高位每个数字都出现了2次，当第二高位也确定了，第三高位上的数字都只出现了1次，当第三高位确定了，那么第四高位上的数字也只能出现一次，下面我们来看k = 17这种情况的每位数字如何确定，由于k = 17是转化为数组下标为16： 最高位可取1,2,3,4中的一个，每个数字出现3！= 6次，所以k = 16的第一位数字的下标为16 / 6 = 2，在 “1234” 中即3被取出。这里我们的k是要求的坐标为k的全排列序列，我们定义 k’ 为当最高位确定后，要求的全排序列在新范围中的位置，同理，k” 为当第二高为确定后，所要求的全排列序列在新范围中的位置，以此类推，下面来具体看看： 第二位此时从1,2,4中取一个，k = 16，则此时的 k’ = 16 % (3!) = 4，如下所示，而剩下的每个数字出现2！= 2次，所以第二数字的下标为4 / 2 = 2，在 “124” 中即4被取出。 31243142321432413412 &lt;— k’ = 43421 第三位此时从1,2中去一个，k’ = 4，则此时的k” = 4 % (2!) = 0，如下所示，而剩下的每个数字出现1！= 1次，所以第三个数字的下标为 0 / 1 = 0，在 “12” 中即1被取出。 3412 &lt;— k” = 03421 第四位是从2中取一个，k” = 0，则此时的k”’ = 0 % (1!) = 0，如下所示，而剩下的每个数字出现0！= 1次，所以第四个数字的下标为0 / 1= 0，在 “2” 中即2被取出。 3412 &lt;— k”’ = 0 那么我们就可以找出规律了a1 = k / (n – 1)!k1 = k a2 = k1 / (n – 2)!k2 = k1 % (n – 2)!… an-1 = kn-2 / 1!kn-1 = kn-2 % 1! an = kn-1 / 0!kn = kn-1 % 0! 实现代码如下：12345678910111213141516171819202122class Solution &#123; public String getPermutation(int n, int k) &#123; StringBuilder nums = new StringBuilder("123456789"); StringBuilder res = new StringBuilder(); int[] array = new int[n + 1]; array[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; array[i] = array[i - 1] * i; &#125; k -= 1; n -= 1; while (n &gt;= 1) &#123; int s = k / array[n]; res.append(nums.charAt(s)); nums.deleteCharAt(s); k = k % array[n]; n--; &#125; res.append(nums.charAt(0)); return res.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(47) Permutations II]]></title>
    <url>%2F2018%2F09%2F30%2Fleetcode47-permutations-ii%2F</url>
    <content type="text"><![CDATA[Description:Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 解法：同样是排列问题，这道题去掉了一个限制条件，即可以有重复的元素。考虑例子{1,2,2}，在某次结果得到1，2，2后，在选择第二个元素时，由于2已经被选过，所以第三个2不用放在第二个位置上了，此时的条件为第三个二与第二个二相等，而第二个二还没有被选中，所以，为了避免重复，有限制条件即： nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 0 注意，这仅仅适用于num中的数是排好序的情况。具体实现代码如下：12345678910111213141516171819202122232425262728293031class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; if (nums.length == 0) &#123; return result; &#125; int[] used = new int[nums.length]; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); Arrays.sort(nums); dfs(nums, used, tmp); return result; &#125; void dfs(int[] nums, int[] used, List&lt;Integer&gt; tmp) &#123; if (tmp.size() == nums.length) &#123; result.add(new ArrayList&lt;&gt;(tmp)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (used[i] == 1 || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 0)) &#123; continue; &#125; tmp.add(nums[i]); used[i] = 1; dfs(nums, used, tmp); used[i] = 0; tmp.remove(tmp.size() - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode(46) Permutations]]></title>
    <url>%2F2018%2F09%2F27%2Fleetcode46-permutations%2F</url>
    <content type="text"><![CDATA[Description:Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解法：以A{a,b,c}为例，来说明全排列的生成方法，对于这个集合，其包含3个元素，所有的排列情况有3!=6种，对于每一种排列，其第一个元素有3种选择a,b,c，对于第一个元素为a的排列，其第二个元素有2种选择b,c；第一个元素为b的排列，第二个元素也有2种选择a，c，……，依次类推，我们可以将集合的全排列与一棵多叉树对应。如下图所示 因为没有重复项，可以各位交换模拟选择的过程。在此树中，每一个从树根到叶子节点的路径，就对应了集合A的一个排列。通过递归算法，可以避免多叉树的构建过程，直接生成集合A的全排列，具体代码如下：12345678910111213141516171819202122232425262728293031323334class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (nums.length == 0) &#123; return result; &#125; get_permutation(nums, 0, nums.length); return result; &#125; void get_permutation(int[] num, int i, int len) &#123; if (i == len - 1) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); for (int j = 0; j &lt; len; j++) &#123; tmp.add(num[j]); &#125; result.add(tmp); return; &#125; for (int j = i; j &lt; len; j++) &#123; swap(num, i, j); get_permutation(num, i + 1, num.length); swap(num, i, j); &#125; &#125; void swap(int[] array, int i, int j) &#123; int tmp = array[i]; array[i] = array[j]; array[j] = tmp; &#125;&#125; 另一种DFS的方法，其实更好理解：123456789101112131415161718192021222324252627282930class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (nums.length == 0) &#123; return result; &#125; int[] used = new int[nums.length]; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); dfs(nums, used, tmp); return result; &#125; void dfs(int[] nums, int[] used, List&lt;Integer&gt; tmp) &#123; if (tmp.size() == nums.length) &#123; result.add(new ArrayList&lt;&gt;(tmp)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (used[i] == 1) &#123; continue; &#125; tmp.add(nums[i]); used[i] = 1; dfs(nums, used, tmp); used[i] = 0; tmp.remove(tmp.size() - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(31) Next Permutation]]></title>
    <url>%2F2018%2F09%2F17%2Fleetcode31-next-permutation%2F</url>
    <content type="text"><![CDATA[Description: Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 解法： 简而言之，这道题的意思就是寻找下一个字典序的全排列，所谓字典序，就是从小到大的顺序。算法思路如下： 以1，2，4，3，1为例： 因为是找递增的下一个排列，所以从后往前找到第一个升序对的位置，如1,2,4,3,1， 从后向前找就是2,4,3,1，因为2比前一个数4小，所以就锁定2这个数。之后就是在4,3,1中找到比2大的最小的那个数3，将3与2对换得到降序排列4,2,1.然后就是将4,2,1反序得到1,2,4.最终结果就是1,3,1,2,4。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public void nextPermutation(int[] nums) &#123; int rear = nums.length - 1; if (rear == -1) &#123; return; &#125; for (int i = rear - 1; i &gt;= 0; i--) &#123; int j = i + 1; if (nums[i] &lt; nums[j]) &#123; int min = 999999999; int exchangeindex = i; for (int ii = j; ii &lt;= rear; ii++) &#123; int minus = nums[ii] - nums[i]; if (min &gt; minus &amp;&amp; minus &gt; 0) &#123; min = minus; exchangeindex = ii; &#125; &#125; int l = nums[i]; nums[i] = nums[exchangeindex]; nums[exchangeindex] = l; sort(nums, j, rear); return; &#125; &#125; for (int i = 0; i &lt;= rear; i++) &#123; int j = rear - i; if (i &gt;= j) &#123; break; &#125; int l = nums[i]; nums[i] = nums[j]; nums[j] = l; &#125; return; &#125; void sort(int[] array, int start, int end) &#123; for (int i = start; i &lt;= end; i++) &#123; int x = array[i]; int j = i - 1; while (j &gt;= start) &#123; if (array[j] &gt; x) &#123; array[j + 1] = array[j]; j -= 1; &#125; else &#123; break; &#125; &#125; array[j + 1] = x; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(64) Minimum Path Sum]]></title>
    <url>%2F2018%2F09%2F10%2Fleetcode64-minimum-path-sum%2F</url>
    <content type="text"><![CDATA[Description: Given a _m_ x _n_ grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input:[ [1,3,1], [1,5,1], [4,2,1]]Output: 7Explanation: Because the path 1→3→1→1→1 minimizes the sum. 解法： 经典的动态规划题，这里给出状态转移公式：12345678//起点dp[0][0] = grid[0][0];//第一行dp[i][j] = dp[i][j - 1] + grid[i][j];//第一列dp[i][j] = dp[i - 1][j] + grid[i][j];//其他dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; 具体的代码如下：1234567891011121314151617181920212223242526class Solution &#123; public int minPathSum(int[][] grid) &#123; int[][] dp = new int[grid.length][grid[0].length]; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (i == 0 &amp;&amp; j != 0) &#123; dp[i][j] = dp[i][j - 1] + grid[i][j]; &#125; else if (j == 0 &amp;&amp; i != 0) &#123; dp[i][j] = dp[i - 1][j] + grid[i][j]; &#125; else if (i != 0 &amp;&amp; j != 0) &#123; dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; &#125; else &#123; dp[i][j] = grid[i][j]; &#125; &#125; &#125; return dp[grid.length - 1][grid[0].length - 1]; &#125; public int min(int a, int b) &#123; if (a &gt; b) &#123; return b; &#125; return a; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之归并排序]]></title>
    <url>%2F2018%2F09%2F10%2Fe6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-e4-b9-8b-e5-bd-92-e5-b9-b6-e6-8e-92-e5-ba-8f%2F</url>
    <content type="text"><![CDATA[归并排序基本思想归并排序是分治的典型例子(divide-conquer)。总体的步骤为采用分的思想，将问题小化递归求解（分的阶段），然后将小化后的子问题合并得到最终大问题的解。对于排序而言，若细化为两个只有一个数字的数列时对齐合并处理可以很简单地得到有序的数列，归并排序运用的就是这种思想。 算法设计：整体设计上，算法主要包括分与治这两个过程， 分的设计：分是递归地解决问题，所以要充分考虑好参数的问题。 参数1：为了节省空间，不会在递归的函数中为分产生的数组分配新的空间，故分的数组是基于原数组空间的，所以需要一个参数为原数组的地址。 参数2与3：另外分主要依靠的是待分数组的左起点和右终点，同时这两个参数也可作为递归终止条件的判断。（这里顺便聊一下递归终止条件的书写，为了使递归有出口，终止条件应当尽量严格，比如在可以写right &lt;= left 和 right == left 的情况下，前者更好，这里相当于偷了个懒，因为不确定分到最后right和left的具体情况） 参数4：考虑到合的过程中需要将结果临时存在一个辅助数组里再赋值到原数组中，故在这里设置一个已经分配好空间的数组指针作为参数。 分析好参数之后，递归就按照宏观思想来写就可以了。即先写终止条件，然后写递归体。 治的设计：合并数组变得相对简单了。因为合并是在一个数组中的前后两部分进行，所以只需要知道开始点，中点，结束点就可以了。注意，因为采用了递归的设计，最终的结果应当保留到原数组中覆盖之前的结果，别只留在临时数组里。 具体代码如下： （这里为了调用方便包装了一下，所以其实两个函数是够了的）1234567891011121314151617181920212223242526272829303132333435363738394041class solution &#123; public void merge(int[] a, int left, int mid, int right, int[] b) &#123; int i = left, j = mid + 1, k = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (a[i] &lt; a[j]) &#123; b[k++] = a[i++]; &#125; else &#123; b[k++] = a[j++]; &#125; &#125; while (i &lt;= mid) &#123; b[k++] = a[i++]; &#125; while (j &lt;= right) &#123; b[k++] = a[j++]; &#125; k = 0; while(left &lt;= right)&#123; a[left++] = b[k++]; &#125; &#125; public int[] merge_sort(int[] input) &#123; if(input.length == 1)&#123; return input; &#125; int[] result = new int[input.length]; sort(input, 0, input.length - 1, result); return result; &#125; private void sort(int[] input, int left, int right, int[] result) &#123; if (left &lt; right) &#123; int mid = (right + left) / 2; sort(input, left, mid, result); sort(input, mid+1, right, result); merge(input, left, mid, right, result); &#125; &#125;&#125;]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试常见问题总结]]></title>
    <url>%2F2018%2F09%2F01%2F%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文来源于自己和了解到的常见的国内的面试问题，在此汇总与收集 Java有关问题1. final的使用？final在修饰变量、方法、类时的不同？根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。 final类不能被继承，没有子类，final类中的方法默认是final的。 在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。 final方法不能被子类的方法覆盖，但可以被继承。（注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。） 如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法，把方法锁定，防止任何继承类修改它的意义和实现。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。 final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 基本数据类型（int、double、char…）运用final时，使数值恒定不变；对象引用运用final时，final使得引用恒定不变，引用内部的数据若不是final型，可以进行修改。数组类型运用final时，final使得数组引用恒定不变，数组内部的数据若不是final型，可以进行修改。 final不能用于修饰构造方法。 扩展： final 与static： final指明数据为一个常量，恒定无法修改； static指明数据只占用一份存储区域； 关于static关键字： static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。 static方法 static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。static方法不能被重写（意思是语法上不会报错，但达不到重写所希望达到的多态的效果） static变量 static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 static成员变量的初始化顺序按照定义的顺序进行初始化。 static代码块 static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 易错点： Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字 在Java中切记：static是不允许用来修饰局部变量 静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。 2. finally关键字?一般是用于异常处理中，提供finally块来执行任何的清理操作，try{} catch(){} finally{}。finally关键字是对java异常处理模型的最佳补充。finally结构使代码总会执行，无论有无异常发生。使得finally可以维护对象的内部状态，并可以清理非内存资源。 finally在try,catch中可以有，可以没有。如果trycatch中有finally则必须执行finally快中的操作。一般情况下，用于关闭文件的读写操作，或者是关闭数据库的连接等等。 扩展： 关于finalize方法：finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。Java中的finalize的调用具有不确定性。 3. Object类中的hashcode()和equals()的联系和区别？equals() 的作用是用来判断两个对象是否相等。但是使用默认的“equals()”方法，等价于“==”方法（比较对象的地址）。因此，我们通常会重写equals()方法：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。仅仅当创建并某个“类的散列表”(关于“散列表”见下面说明)时，该类的hashCode() 才有用(作用是：确定该类的每一个对象在散列表中的位置；其它情况下(例如，创建类的单个对象，或者创建类的对象数组等等)，类的hashCode() 没有作用。 两者的关系： 第一种情况 没有创建“类对应的散列表： 这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。 这种情况下，该类的“hashCode() 和 equals() ”没有关系的！这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。（即p1和p2相等的情况下，hashCode()也不一定相等） 第二种情况 创建了“类对应的散列表”“： 如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。（所以要求必须重写hashcode方法，否则使用哈希表之类的数据结构时会出现重复的元素） 如果两个对象hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突（碰撞）。 4. Java的访问权限修饰符？ default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 对于protected关键字，需要注意： 基类的protected成员是包内可见的，并且对子类可见； 若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。 123456789101112131415161718//示例package p2;class MyObject2 &#123; protected Object clone() throws CloneNotSupportedException&#123; return super.clone(); &#125;&#125;package p22;public class Test2 extends MyObject2 &#123; public static void main(String args[]) &#123; MyObject2 obj = new MyObject2(); obj.clone(); // Compile Error ----（1） Test2 tobj = new Test2(); tobj.clone(); // Complie OK ----（2） &#125;&#125; 对于(1)而言，clone()方法来自于类MyObject2本身，因此其可见性为包p2及MyObject2的子类，虽然Test2是MyObject2的子类，但在Test2中不能访问基类MyObject2的protected方法clone()，因此编译不通过;对于(2)而言，由于在Test2中访问的是其本身实例的从基类MyObject2继承来的的clone()，因此编译通过。 5. 重写与重载的区别？重写（override）: 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有以下三个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件 方法的调用顺序：在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有查找到再到父类中查看，看是否有继承来的方法。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为： this.func(this) super.func(this) this.func(super) super.func(super) 重载（Overload）： 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 6. Java中的抽象类与接口？抽象类：抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类 接口： 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。 接口的字段默认都是 static 和 final 的。（为什么呢？对于static，因为接口是可以多继承的。如果一个类实现了两个接口，且两个接口都具有相同名字的变量，此时这个变量可以被实现类使用，那么如果不是static的，这个变量来自哪一个接口就会产生歧义，所以实现类使用接口中的变量必须通过接口名指定，也就只能定为static的。对于final, 一个子类修改了值会影响到其他所有子类，因此就不应该允许子类修改这个值，所以定义为final） 比较： 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 使用接口： 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；需要使用多重继承。 使用抽象类： 需要在几个相关的类中共享代码。需要能控制继承来的成员的访问权限，而不是都为 public。需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。 里氏替换原则： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 7. Super的用法？ 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super 函数。 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。 8. Java的深拷贝与浅拷贝？首先了解一下clone()方法。 clone() 是 Object 的 protected 方法，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 深拷贝与浅拷贝： 浅拷贝：拷贝对象和原始对象的引用类型引用同一个对象（两者指向同一个空间，其中一个的改变会导致另一个跟着改变） 深拷贝：拷贝对象和原始对象的引用类型引用不同对象（拷贝之后为新拷贝的对象单独开了一块空间，其中一个的改变不会导致另一个的改变） 9. Java的反射？通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 Java 反射主要提供以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法 运用反射时注意事项： 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 10. 为什么有了基本的数据类型还需要包装类？ 包装类里面有一些很有用的方法和属性，如HashCode,ParseInt 基本类型不能赋null值，某些场合需要 很多地方不能直接用基本类型，比如集合，范型 包装类的缓存提高了存取效率 11. 向上转型与向下转型？向上转型：将子类对象用父类的引用来引用使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Animal &#123; public void eat() &#123; System.out.println("父类的 eating..."); &#125;&#125;class Bird extends Animal&#123; @Override public void eat() &#123; System.out.println("子类重写的父类的 eatting..."); &#125; public void fly() &#123; System.out.println("子类新方法 flying..."); &#125;&#125;public class Sys&#123; //输出： //子类重写的父类的 eatting... //男人 sleep.. //女人 sleep.. public static void main(String[] args) &#123; Animal b=new Bird(); //向上转型 // 会调用子类重写父类的方法 b.eat(); // b.fly(); b虽指向子类对象，但此时子类作为向上的代价丢失和父类不同的fly()方法 //传入的参数是子类-----！！ sleep(new Male()); sleep(new Female()); &#125; //这里就体现了向上转型的好处了，只用写一个父类的引用方法就可以了 //方法的参数是父类------！！！ public static void sleep(Human h) &#123; h.sleep(); &#125;&#125; 向下转型：用子类的引用指向原来父类的引用 1234567891011121314151617181920212223242526272829303132333435363738394041class Fruit &#123; public void myName() &#123; System.out.println("我是父类 水果..."); &#125;&#125;class Apple extends Fruit &#123; @Override public void myName() &#123; System.out.println("我是子类 苹果..."); &#125; public void myMore() &#123; System.out.println("我是你的小呀小苹果~~~~~~"); &#125;&#125;public class test &#123; public static void main(String[] args) &#123; Fruit a = new Apple(); //向上转型 a.myName(); Apple aa = (Apple) a; //向下转型,编译和运行皆不会出错(正确的) aa.myName();//向下转型时调用的是子类的 aa.myMore(); Fruit f = new Fruit(); Apple aaa = (Apple) f; //-不安全的---向下转型,编译无错但会运行会出错 aaa.myName(); aaa.myMore(); &#125;&#125;/*输出:我是子类 苹果...我是子类 苹果...我是你的小呀小苹果~~~~~~Exception in thread "main" java.lang.ClassCastException: Fruit cannot be cast to Apple at test.main(test.java:29)*/ 向下转型后因为都是指向子类对象，所以调用的当然全是子类的方法~~ 12. Java中的泛型？泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 泛型通配符 如果只指定了&lt;?&gt;，而没有extends，则默认是允许Object及其下的任何Java类了。也就是任意类。 通配符泛型不单可以向下限制，如&lt;? extends Collection&gt;，还可以向上限制，如&lt;? super Double&gt;，表示类型只能接受Double及其上层父类类型，如Number、Object类型的实例。 （&lt;? extends Collection&gt; 与 \的区别在于T只能指定一个继承于Collection的类型，而?可以代表所有的继承于Collection的类型） 易错点： 1234List&lt;Object&gt; objectList;List&lt;String&gt; stringList;objectList = stringList; //compilation error incompatible types//若要正确，需要使用List&lt;?&gt; objectList 13. Java的引用类型？强引用： Java中的强引用，类似C语言中最难的指针。通过引用，可以对堆中的对象进行操作。 强引用的特点： 强引用可以直接访问目标对象。 强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。 强引用可能导致内存泄漏。 软引用： 软引用是除了强引用外，最强的引用类型。可以通过java.lang.ref.SoftReference使用软引用。一个持有软引用的对象，不会被JVM很快回收，JVM会根据当前堆的使用情况来判断何时回收。当堆使用率临近阈值时，才会去回收软引用的对象。因此，软引用可以用于实现对内存敏感的高速缓存。 12345678910 @Test public void test3()&#123; MyObject obj = new myObject(); SoftReference sf = new SoftReference&lt;&gt;(obj); obj = null; System.gc();// byte[] bytes = new byte[1024*100];// System.gc(); System.out.println("是否被回收"+sf.get()); &#125; 运行结果： 1是否被回收cn.zyzpp.MyObject@42110406 打开被注释掉的new byte[1024*100]语句，这条语句请求一块大的堆空间，使堆内存使用紧张。并显式的再调用一次GC，结果如下： 1是否被回收null 说明在系统内存紧张的情况下，软引用被回收。 弱引用： 弱引用是一种比软引用较弱的引用类型。在系统GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。在java中，可以用java.lang.ref.WeakReference实例来保存对一个Java对象的弱引用。 12345678public void test3()&#123; MyObject obj = new MyObject(); WeakReference sf = new WeakReference(obj); obj = null; System.out.println("是否被回收"+sf.get()); System.gc(); System.out.println("是否被回收"+sf.get());&#125; 运行结果： 12是否被回收cn.zyzpp.MyObject@42110406是否被回收null 软引用，弱引用都非常适合来保存那些可有可无的缓存数据，如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。 虚引用： 虚引用是所有类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一样的，随时可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 14. Java中的堆空间与栈空间在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。 堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。 引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的。 15. HashTable与HashMap的区别？ 继承不同，Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。 Hashtable 中的方法是同步的，而HashMap中的方法在默认情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 Hashtable中，key和value都不允许出现null值，否则会抛出NullPointerException异常。而在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 遍历方式不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 哈希值的使用不同。HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 HashTable中的hash数组初始大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 16. HashMap实现原理整体上看，是采用拉链法实现的（即链表的数组） 两个重要的参数： 在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor)。简单的说，Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket填充的数目（即hashmap中元素的个数）大于capacity*load factor时就需要调整buckets的数目为当前的2倍。 Hash值的计算（即index的计算）： 计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示： put函数的大致思路： 对key的hashCode()做hash，然后再计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。 get函数的大致思路： bucket里的第一个节点，直接命中； 如果有冲突，则通过key.equals(k)去查找对应的entry若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。 扩容的实现： 当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。扩容后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。 怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示： 因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。 拓展问题：ConcurrentHashMap的实现原理 同样是并发，我们把ConcurrentHashMap跟HashTable对比一下。 HashTable的并发简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁“思想。 17. JVM的垃圾回收Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。 堆的结构： JDK1.8之前的堆内存示意图： 从上图可以看出堆内存的分为新生代、老年代和永久代。新生代又被进一步分为：Eden 区＋Survior1 区＋Survior2 区。值得注意的是，在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。 Survior区存在的原因：如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC，浪费时间 两个Survior区的原因：防止碎片化，https://blog.csdn.net/antony9118/article/details/51425581。 堆内存分配策略： 对像优先在eden区分配目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC. Minor Gc和Full GC 有什么不同呢？ 新生代GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。 老年代GC（Major GC/Full GC）:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。 分配担保机制： 场景：allocation1已经分入了eden空间，现在需要分配allocation2。 因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.GC期间虚拟机又发现allocation1无法存入Survior空间，所以只好通过 分配担保机制把新生代的对象提前转移到老年代中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。 大对象直接进入老年代原因: 为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。 长期存活的对象进入老年代虚拟机给每个对象一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold来设置。 动态的年龄判定为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。 对象死亡的判定： 常见算法：引用计数法（并未在实际中使用，因为有循环引用的问题），可达性分析达（即通过一系列的起点对象进行搜索，到达不了的对象为死亡） 需要注意的是，不可达的对象并非“非死不可”。即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。 垃圾回收算法： 1.标记清除算法：先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，但是会带来两个明显的问题：效率问题（两次扫描），空间问题（标记清除后会产生大量不连续的碎片） 2.复制收集算法：将内存分为两块空间，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 3.标记整理算法：根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 主要参考：https://juejin.im/post/5b85ea54e51d4538dd08f601 18. Java的内存泄漏 Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。 内存泄漏常见的情况：如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。(在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）) 简单的例子： 12345678public class Simple &#123; Object object; public void method1()&#123; object = new Object(); //...其他代码 &#125;&#125; 这里的object实例，其实我们期望它只作用于method1()方法中，且其他地方不会再用到它，但是，当method1()方法执行完成后，object对象所分配的内存不会马上被认为是可以被释放的对象，只有在Simple类创建的对象被释放后才会被释放，严格的说，这就是一种内存泄露。解决方法就是将object作为method1()方法中的局部变量。 19. Java实现多线程的方法？（1）实现Runnable接口 1234567891011public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125;//---------------------------------------------------public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; （2）实现Callable接口 与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 12345678910111213public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125;//---------------------------------------------------public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; （3）继承Thread类 同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 12345678910public class MyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125;//-----------------------------------------------------public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start();&#125; . Java中线程的6种状态及切换？6种状态： 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 阻塞(BLOCKED)：表示线程阻塞于锁。 阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。 终止(TERMINATED)：表示该线程已经执行完毕。 当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 阻塞与等待的区别： Thread如果是在等待获取锁，此时Thread的状态就是Blocked；其他调用Object.wait,Thread.join,LockSupport.park等都是WAITING或者TIMED_WAITING状态 这里有个博客很好地说明了，生动形象：https://segmentfault.com/a/1190000010973341 这里附上源码的注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public enum State &#123; /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * &#123;@link Object#wait() Object.wait&#125;. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt; * &lt;/ul&gt; */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; &#125; 21. Java线程池？使用线程池的原因：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。线程池使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务。 线程池的状态： 当创建线程池后，初始时，线程池处于RUNNING状态； 如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕； 如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务； 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。 线程池的主要变量： 12345678910111213141516171819private final BlockingQueue&lt;Runnable&gt; workQueue; //任务缓存队列，用来存放等待执行的任务private final ReentrantLock mainLock = new ReentrantLock(); //线程池的主要状态锁，对线程池状态（比如线程池大小 //、runState等）的改变都要使用这个锁private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); //用来存放工作集 private volatile long keepAliveTime; //线程存活时间 private volatile boolean allowCoreThreadTimeOut; //是否允许为核心线程设置存活时间private volatile int corePoolSize; //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）private volatile int maximumPoolSize; //线程池最大能容忍的线程数 private volatile int poolSize; //线程池中当前的线程数 private volatile RejectedExecutionHandler handler; //任务拒绝策略 private volatile ThreadFactory threadFactory; //线程工厂，用来创建线程 private int largestPoolSize; //用来记录线程池中曾经出现过的最大线程数 private long completedTaskCount; //用来记录已经执行完毕的任务个数 每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。 corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子： 假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。 因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做； 当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待； 如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来； 然后就将任务也分配给这4个临时工人做； 如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。 当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。 这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。 也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。 largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。 执行策略： 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务； 如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务； 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理； 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。 参考博客：https://www.cnblogs.com/dolphin0520/p/3932921.html 22. synchronized关键字？synchronized是Java中的关键字，synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。Java中的每个对象都有一个锁（lock），或者叫做监视器（monitor），这是synchronized实现同步的基础。 它修饰的对象有以下几种： 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 拓展：Java中的Wait() 和notify() 方法为什么要在synchronized块中使用？ 从语义角度来讲， 一个线程调用了wait()之后， 必然需要由另外一个线程调用notify()来唤醒该线程， 所以本质上， wait()与notify()的成对使用， 是一种线程间的通信手段。在使用 wait() 和 notify() 这种会挂起线程的操作时， 我们需要一种同步机制保证， condition 的检查与 wait() 操作， 以及 condition 的更新与 notify() 是互斥的。否则会出现信号量的丢失倒置wait()的进程永远等待丢失notify信号 具体来看： 123456789101112// 线程A 的代码while(!condition)&#123; // 不能使用 if , 因为存在一些特殊情况， 使得线程没有收到 notify 时也能退出等待状态 wait();&#125;// do something// 线程 B 的代码if(!condition)&#123; // do something ... condition = true; notify();&#125; 【线程A】 进入了 while 循环后（通过了 !condition 判断条件， 但尚未执行 wait 方法）, CPU 时间片耗尽， CPU 开始执行线程B的代码【线程B】 执行完毕了 condition = true; notify(); 的操作， 此时【线程A】的 wait() 操作尚未被执行， notify() 操作没有产生任何效果【线程A】执行wait() 操作， 进入等待状态，如果没有额外的 notify() 操作， 该线程将持续在 condition = true 的情形下， 持续处于等待状态得不到执行。 拓展：synchronized与Lock的区别： 用法上： synchronized：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。 lock：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。 计算机网络有关问题1. TCP协议（三次握手与四次挥手） TCP 提供一种面向连接的、可靠的字节流服务 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP TCP 使用校验和，确认和重传机制来保证可靠传输 TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复 TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知 TCP的6种标志位的分别代表： SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) Sequence number(顺序号码) Acknowledge number(确认号码) 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 三次握手： 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。 第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号（ISN Initial Sequence Number） X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 序列号的作用： 防止出现以相同的四元组建立新的tcp连接（也就是说A和B两次建立tcp连接都是使用了相同的ip地址和端口），就会出现数据乱序的问题。初始化序号的方式（通过算法来随机生成序号）就会使序号难以猜出，也就不容易利用这种缺点来进行一些恶意攻击行为。 为什么不能用两次握手进行连接？ 3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 四次挥手： 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 为什么连接的时候是三次握手，关闭的时候却是四次握手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 2. HTTP协议 HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 URL： HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：123456789http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URL；如果URL中没有给出abs_path，那么当它作为请求URL时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。HTTP请求报文：HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：请求行、消息报头、请求正文。类似于下面这样：请求行：其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445请求方法（所有方法全为大写）有多种，各个方法的解释如下：GET 请求获取Request-URL所标识的资源POST 在Request-URL所标识的资源后附加新的数据（重复提交相同请求不覆盖）HEAD 请求获取由Request-URL所标识的资源的响应消息报头PUT 请求服务器存储一个资源，并用Request-URL作为其标识（重复提交相同请求覆盖）DELETE 请求服务器删除Request-URL所标识的资源TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT 保留将来使用OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求GET与POST区别：GET产生一个TCP数据包；POST产生两个TCP数据包。长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。HTTP响应报文:HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文状态行格式：HTTP-Version Status-Code Reason-Phrase状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受3xx：重定向--要完成请求必须进行更进一步的操作4xx：客户端错误--请求有语法错误或请求无法实现5xx：服务器端错误--服务器未能实现合法的请求消息报头详解请求报头：请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常见请求报头： AcceptAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。Accept-CharsetAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。Accept-EncodingAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。Accept-LanguageAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。AuthorizationAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。Host（发送请求时，该报头域是必需的）Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：我们在浏览器中输入：http://www.guet.edu.cn/index.html浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.guet.edu.cn此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号User-Agent我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。1234响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是Server响应报头域的一个例子：Server：Apache-Coyote/1.1WWW-AuthenticateWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。eg：WWW-Authenticate:Basic realm=”Basic Auth Test!” //可以看出服务器对请求资源采用的是基本验证机制。1234实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。 常用的实体报头Content-EncodingContent-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzipContent-LanguageContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:daContent-LengthContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。Content-TypeContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：Content-Type:text/html;charset=ISO-8859-1Content-Type:text/html;charset=GB2312Last-ModifiedLast-Modified实体报头域用于指示资源的最后修改日期和时间。ExpiresExpires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMTHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(“Expires”,”0”);` 3. 会话跟踪常用方法： URL 重写 URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。 隐藏表单域 将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示 Cookie Cookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,以便下次使用。 客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。 Cookie 是可以被客户端禁用的。 Session: 每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。 在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。 Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。 数据库有关问题1. 关于索引为什么使用索引？ 使用索引的全部意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。 什么是索引？ 一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。 索引的常用实现的方法？ B-Tree 是最常用的用于索引的数据结构。因为它们是时间复杂度低， 查找、删除、插入操作都可以可以在对数时间内完成。另外一个重要原因存储在B-Tree中的数据是有序的。数据库管理系统（RDBMS）通常决定索引应该用哪些数据结构。但是，在某些情况下，你在创建索引时可以指定索引要使用的数据结构。 哈希索引 哈系索引的工作方式是将列的值作为索引的键值（key），和键值相对应实际的值（value）是指向该表中相应行的指针。因为哈希表基本上可以看作是关联数组，一个典型的数据项就像“Jesus =&gt; 0x28939″，而0x28939是对内存中表中包含Jesus这一行的引用。缺点在于哈希表是无顺序的数据结构 使用索引的代价？ 那么，使用数据库索引有什么缺点呢？其一，索引会占用空间 - 你的表越大，索引占用的空间越大。其二，性能损失（主要值更新操作），当你在表中添加、删除或者更新行数据的时候， 在索引中也会有相同的操作。基本原则是只如果表中某列在查询过程中使用的非常频繁，那就在该列上创建索引。 2. 关于事务什么是事务？ 数据库事务是指作为单个逻辑单元执行的一系列操作，是并发控制的基本单位，要么完全执行，要么完全地不执行。事务的四个特性(ACID):原子性、一致性、隔离性和持久性。 可能存在的并发问题？ 脏读：对于两个事务T1，T2，T1读取了已经被T2更新但还没有提交的字段，之后，若T2回滚，T1读取到的内容就是临时无效的内容。 不可重复读：对于事务T1，T2，T1需要读取一个字段两次，在第一次和第二次读取之间，T2更新了该字段，导致T1第二次读取到的内容值不同。 幻读： 事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。 幻读与不可重复读之间的区别是幻读强调的是新增或删除,而不可重复读强调的是修改。比如Mary两次查工资，中间有人改过工资，则两次结果不一样，这就是不可重复读。Mary要查工资一千的人数，第一次查到了10个，中间有人增加了一条工资为一千的人，下次查的时候就变成了11个，好像第一次查询的是幻觉一样。 关于隔离级别？ 读未提交（Read Uncommitted）另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）。只在同一数据上写事务时禁止其他写事务。 情况举例： 事务1读取某行记录时，事务2也能对这行记录进行读取、更新 当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本，即使该修改尚未被提交。 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。 读提交（Read Committed）读已提交（Read Committed） 本事务读取到的是最新的数据（其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不可重复读）。同一在数据写事务时禁止其它读写事务。 可重复读（Repeatable Read）可重复读（Repeatable Read） 在同一个事务里，SELECT的结果是事务开始时间点的状态，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象。同一数据写事务时禁止其他读写事务，读事务时禁止其它写事务(允许读) 序列化（Serializable）提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。 3. 关于锁共享锁（Share Locks，简记为S）又被称为读锁，其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。 共享锁(S锁)又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 排它锁（(Exclusive lock,简记为X锁)）又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。 操作系统有关问题]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(329) Longest Increasing Path in a Matrix]]></title>
    <url>%2F2018%2F08%2F30%2Fleetcode329-longest-increasing-path-in-a-matrix%2F</url>
    <content type="text"><![CDATA[Description:Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: Input: nums =[ [9,9,4], [6,6,8], [2,1,1]]Output: 4Explanation: The longest increasing path is [1, 2, 6, 9]. Example 2: Input: nums =[ [3,4,5], [3,2,6], [2,2,1]]Output: 4Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. 解法：首先自然而然地想到了对于每一个点采用深度优先的搜索算法，得到以该点为起点的最长路径，然而在这个过程中，其实存在重复搜索的问题而影响了程序的效率。代码跑出来果然超时了。以下为DFS代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Solution &#123; public int longestIncreasingPath(int[][] matrix) &#123; if (matrix.length == 0) &#123; return 0; &#125; int row = matrix.length; int col = matrix[0].length; int max = 0; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; int cnt = dfs(i, j, matrix, row, col); if (cnt &gt; max) &#123; max = cnt; &#125; &#125; &#125; return max; &#125; private int dfs(int i, int j, int[][] matrix, int row, int col) &#123; Stack s = new Stack(); node start = new node(i, j, matrix[i][j],1); s.push(start); node now = start; int[][] direction = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int cnt = 0; while (!s.isEmpty()) &#123; now = (node) s.pop(); int flag = 0; for (int ii = 0; ii &lt; 4; ii++) &#123; node next = new node(now.i+ direction[ii][0], now.j + direction[ii][1], -1,1); if (isvalid(next, row, col) &amp;&amp; matrix[next.i][next.j] &gt; now.value) &#123; next.value = matrix[next.i][next.j]; next.step = now.step + 1; s.push(next); flag = 1; &#125; &#125; if(flag == 0)&#123; if(now.step &gt; cnt)&#123; cnt = now.step; &#125; &#125; &#125; return cnt; &#125; private boolean isvalid(node n, int row, int col) &#123; if (n.i &gt;= 0 &amp;&amp; n.i &lt; row &amp;&amp; n.j &gt;= 0 &amp;&amp; n.j &lt; col ) &#123; return true; &#125; return false; &#125;&#125;class node &#123; int i; int j; int value; int step = 1; node(int i, int j, int value,int step) &#123; this.i = i; this.j = j; this.value = value; this.step = step; &#125;&#125; 为解决重复搜索问题，引入动态规划思想，以空间换时间。引入记忆矩阵，改写DFS搜索方法，采用递归的方式进行搜索。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Solution &#123; public int longestIncreasingPath(int[][] matrix) &#123; if (matrix.length == 0) &#123; return 0; &#125; int row = matrix.length; int col = matrix[0].length; int memory[][] = new int[row][col]; int max = 0; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; int cnt = dfs(i, j, matrix, row, col,memory); if (cnt &gt; max) &#123; max = cnt; &#125; &#125; &#125; return max; &#125; private int dfs(int i, int j, int[][] matrix, int row, int col,int[][] memory) &#123; int maxstep = 1; if(memory[i][j]&gt;0)&#123; return memory[i][j]; &#125; node now = new node(i,j,matrix[i][j],0); int[][] direction = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int ii = 0; ii &lt; 4; ii++)&#123; node next = new node(now.i+ direction[ii][0], now.j + direction[ii][1], -1,1); if (isvalid(next, row, col) &amp;&amp; matrix[next.i][next.j] &gt; now.value)&#123; next.value = matrix[next.i][next.j]; int cal = dfs(next.i,next.j,matrix,row,col,memory) + 1; if(maxstep &lt; cal)&#123; maxstep = cal; &#125; &#125; &#125; memory[i][j] = maxstep; return memory[i][j]; &#125; private boolean isvalid(node n, int row, int col) &#123; if (n.i &gt;= 0 &amp;&amp; n.i &lt; row &amp;&amp; n.j &gt;= 0 &amp;&amp; n.j &lt; col ) &#123; return true; &#125; return false; &#125;&#125;class node &#123; int i; int j; int value; int step = 1; node(int i, int j, int value,int step) &#123; this.i = i; this.j = j; this.value = value; this.step = step; &#125;&#125; 又重写了一遍，这次顺多了 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; int[] dirx = &#123;-1, 1, 0, 0&#125;; int[] diry = &#123;0, 0, 1, -1&#125;; public int longestIncreasingPath(int[][] matrix) &#123; if (matrix.length == 0) &#123; return 0; &#125; int[][] dp = new int[matrix.length][matrix[0].length]; int res = 0; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; DFS(i, j, matrix, dp, 1); &#125; &#125; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; if (res &lt; dp[i][j]) &#123; res = dp[i][j]; &#125; &#125; &#125; return res; &#125; void DFS(int x, int y, int[][] matrix, int[][] dp, int step) &#123; if (dp[x][y] &gt; step &amp;&amp; step != 0) &#123; return; &#125; dp[x][y] = step; for (int i = 0; i &lt; 4; i++) &#123; int nextx = x + dirx[i]; int nexty = y + diry[i]; if (nextx &gt;= 0 &amp;&amp; nextx &lt; matrix.length &amp;&amp; nexty &gt;= 0 &amp;&amp; nexty &lt; matrix[0].length &amp;&amp; dp[nextx][nexty] &lt; step + 1 &amp;&amp; matrix[nextx][nexty] &gt; matrix[x][y]) &#123; DFS(nextx, nexty, matrix, dp, step + 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(173) Binary Search Tree Iterator]]></title>
    <url>%2F2018%2F07%2F28%2Fleetcode173-binary-search-tree-iterator%2F</url>
    <content type="text"><![CDATA[Description:Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(_h_) memory, where _h_ is the height of the tree. 解法：首先来复习一下二叉搜索树的概念。二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 这样一来，相当于给一棵搜索树，按从小到大的顺序输出排序结果。由搜索树的性质可知，采用二叉树的中序遍历可以得到该序列。借助栈的帮助可以完成遍历。具体代码如下：1234567891011121314151617181920212223242526272829303132333435public class BSTIterator &#123; private Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;(); public BSTIterator(TreeNode root) &#123; TreeNode cur = root; while (cur != null) &#123; s.push(cur); cur = cur.left; &#125; &#125; /** * @return whether we have a next smallest number */ public boolean hasNext() &#123; if (!s.empty()) &#123; return true; &#125; return false; &#125; /** * @return the next smallest number */ public int next() &#123; TreeNode cur = s.pop(); int result = cur.val; cur = cur.right; while (cur != null) &#123; s.push(cur); cur = cur.left; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(401) Binary Watch]]></title>
    <url>%2F2018%2F07%2F27%2Fleetcode401-binary-watch%2F</url>
    <content type="text"><![CDATA[Description:A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the above binary watch reads “3:25”. Given a non-negative integer _n_ which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: Input: n = 1Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”] Note: The order of output does not matter. The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”. The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”. 解法：这是我在Easy上花的时间最久的一道题。解法采用回溯法，即深度优先搜索，设计一个数组模拟10个小灯泡，初始为全0的状态，每次从头到尾找一个为0的点，置1点亮，继续进行下一层的搜索，搜索终止条件为需要点亮的灯泡数为0。注意回溯的精髓在于在搜索完成或失败的回退处理，具体来说，就是在递归调用之后需将状态还原。实现过程中还利用对称性进行了剪枝。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); public List&lt;String&gt; readBinaryWatch(int num) &#123; int[] led = &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;; if (num &lt;= 5) &#123; dfs(num, led); List&lt;String&gt; tmpresult = new ArrayList&lt;String&gt;(); for (String s : result) &#123; String[] tmp = s.split(":"); int hours = Integer.parseInt(tmp[0]); int minute = Integer.parseInt(tmp[1]); if (minute &gt;= 60 || hours &gt;= 12) &#123; continue; &#125; String h = Integer.toString(hours); String m = Integer.toString(minute); if (minute &lt; 10) &#123; m = '0' + m; &#125; if (!tmpresult.contains(h + ":" + m)) &#123; tmpresult.add(h + ":" + m); &#125; &#125; result = tmpresult; &#125; else &#123; dfs(10 - num, led); List&lt;String&gt; tmpresult = new ArrayList&lt;String&gt;(); for (String s : result) &#123; String[] tmp = s.split(":"); int hours = Integer.parseInt(tmp[0]); int minute = Integer.parseInt(tmp[1]); hours = 15 - hours; minute = 63 - minute; if (minute &gt;= 60 || hours &gt;= 12) &#123; continue; &#125; String h = Integer.toString(hours); String m = Integer.toString(minute); if (minute &lt; 10) &#123; m = '0' + m; &#125; if (!tmpresult.contains(h + ":" + m)) &#123; tmpresult.add(h + ":" + m); &#125; &#125; result = tmpresult; &#125; return result; &#125; void dfs(int num, int[] led) &#123; if (num == 0) &#123; int hour = 0; int minute = 0; for (int i = 0; i &lt; 10; i++) &#123; if (i &lt; 4) &#123; hour = (int) (hour + led[i] * Math.pow(2, i)); &#125; else &#123; minute = (int) (minute + led[i] * Math.pow(2, i - 4)); &#125; &#125; String h = Integer.toString(hour); String m = Integer.toString(minute); if (minute &lt; 10) &#123; m = '0' + m; &#125; if (!result.contains(h + ":" + m)) &#123; result.add(h + ":" + m); &#125; return; &#125; for (int i = 0; i &lt; 10; i++) &#123; if (led[i] == 0) &#123; led[i] = 1; dfs(num - 1, led); led[i] = 0; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(103) Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2018%2F07%2F25%2Fleetcode103-binary-tree-zigzag-level-order-traversal%2F</url>
    <content type="text"><![CDATA[Description:Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 return its zigzag level order traversal as:12345[ [3], [20,9], [15,7]] 解法：这道题需要仔细一点，虽然思路很简单，但是有点绕。要实现之字形走位，因为相邻行的方向不同，考虑使用两个栈进行操作，并且两个栈的进栈顺序也不同，一个先进右节点，一个先进左节点，具体代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if (root == null) &#123; return result; &#125; Stack&lt;TreeNode&gt; s1 = new Stack&lt;TreeNode&gt;(); Stack&lt;TreeNode&gt; s2 = new Stack&lt;TreeNode&gt;(); s1.push(root); while (!s1.empty() || !s2.empty()) &#123; if (s2.empty()) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); while (!s1.empty()) &#123; TreeNode now = s1.pop(); if (now.left != null) &#123; s2.push(now.left); &#125; if (now.right != null) &#123; s2.push(now.right); &#125; tmp.add(now.val); &#125; result.add(tmp); &#125; else &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); while (!s2.empty()) &#123; TreeNode now = s2.pop(); if (now.right != null) &#123; s1.push(now.right); &#125; if (now.left != null) &#123; s1.push(now.left); &#125; tmp.add(now.val); &#125; result.add(tmp); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(61) Rotate List]]></title>
    <url>%2F2018%2F07%2F22%2Fleetcode61-rotate-list%2F</url>
    <content type="text"><![CDATA[Description:Given a linked list, rotate the list to the right by _k_ places, where _k_ is non-negative. Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Explanation: rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4 Output: 2-&gt;0-&gt;1-&gt;NULL Explanation: rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL 解法：考虑到是移动链表题，而单向链表不太好进行回退操作，故考虑将其先变为循环链表，然后根据原链表的长度与移动的次数确定在哪个位置进行断开和指定谁为右移后的头指针。经过分析可得，从原始链表头指针往后走n- 1 - k % n个节点就到达新链表的头结点前一个点（n为链表长度）。具体实现代码如下：123456789101112131415161718192021class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if (head == null || k == 0) &#123; return head; &#125; int count = 0; ListNode tmp = head; while (tmp.next != null) &#123; tmp = tmp.next; count++; &#125; tmp.next = head; tmp = head; for (int i = 1; i &lt;= count - k % (count + 1); i++) &#123; tmp = tmp.next; &#125; head = tmp.next; tmp.next = null; return head; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(74) Search a 2D Matrix]]></title>
    <url>%2F2018%2F07%2F22%2Fleetcode74-search-a-2d-matrix%2F</url>
    <content type="text"><![CDATA[Description:Write an efficient algorithm that searches for a value in an _m_ x _n_ matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1:12345678Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3Output: true Example 2:12345678Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13Output: false 解法：搜索题，如果遍历整个矩阵一定是超时的，不过因为矩阵的排列存在大小规律，可以根据这一特点调整搜索策略，先根据大小关系定位目标可能在的行，然后再遍历该行查找目标。值得注意的是需要考虑边界条件。具体实现的代码如下：12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean searchMatrix(int\[\]\[\] matrix, int target) &#123; if (matrix.length == 0 || matrix\[0\].length == 0) &#123; return false; &#125; int resulti = 0; boolean result = false; for (int i = 0; i &lt; matrix.length; i++) &#123; if (target &lt; matrix\[i\]\[0\]) &#123; resulti = i - 1; result = true; break; &#125; else if (target == matrix\[i\]\[0\]) &#123; return true; &#125; if (i == matrix.length - 1) &#123; resulti = i; result = true; &#125; &#125; if (!result) &#123; return result; &#125; if (resulti == -1) &#123; return false; &#125; for (int j = 0; j &lt; matrix\[resulti\].length; j++) &#123; if (matrix\[resulti\]\[j\] == target) &#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(106) Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2F2018%2F07%2F21%2Fleetcode106-construct-binary-tree-from-inorder-and-postorder-traversal%2F</url>
    <content type="text"><![CDATA[Description:Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7]postorder = [9,15,7,20,3] Return the following binary tree:12345 3 / \9 20 / \ 15 7 解法：根据后序和中序遍历还原二叉树，解法与Leetcode(105) Construct Binary Tree from Preorder and Inorder Traversal类似。 代码如下：1234567891011121314151617181920class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; TreeNode res = mybuild(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1); return res; &#125; private TreeNode mybuild(int[] inorder, int startin, int endin, int[] postorder, int startpost, int endpost) &#123; if (startin &gt; endin || startpost &gt; endpost) &#123; return null; &#125; TreeNode root = new TreeNode(postorder[endpost]); for (int i = startin; i &lt;= endin; i++) &#123; if (inorder[i] == root.val) &#123; root.left = mybuild(inorder, startin, i - 1, postorder, startpost, startpost + i - startin - 1); root.right = mybuild(inorder, i + 1, endin, postorder, startpost + i - startin, endpost - 1); &#125; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(105) Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2F2018%2F07%2F21%2Fleetcode105-construct-binary-tree-from-preorder-and-inorder-traversal%2F</url>
    <content type="text"><![CDATA[Description:Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree:12345 3 / \9 20 / \ 15 7 解法:题意简洁明了，即根据二叉树的前序遍历结果与中序遍历结果还原二叉树。（倒吸一口凉气啊，我真的对递归有阴影）。首先分析各顺序遍历的特点，具体如下： 特性A，对于前序遍历，第一个肯定是根节点； 特性B，对于后序遍历，最后一个肯定是根节点； 特性C，利用前序或后序遍历，确定根节点，在中序遍历中，根节点的两边就可以分出左子树和右子树； 特性D，对左子树和右子树分别做前面3点的分析和拆分，相当于做递归，我们就可以重建出完整的二叉树； 我们以一个例子做一下这个过程，假设： 前序遍历的顺序是: CABGHEDF 中序遍历的顺序是: GHBACDEF 第一步，我们根据特性A，可以得知根节点是C，然后，根据特性C，我们知道左子树是：GHBA，右子树是：DEF。 123 C / \GHBA DEF 第二步，取出左子树，左子树的前序遍历是：ABGH，中序遍历是：GHBA，根据特性A和C，得出左子树的父节点是A，并且A没有右子树。 123456 C / \ A DEF / GBH 第三步，使用同样的方法，前序是BGH，中序是GBH，得出父节点是B，G和H分别是左右节点。 12345678 C / \ A DEF / B / \ G H 第四步，回到右子树，它的前序是EDF，中序是DEF，依然根据特性A和C，得出父节点是E，左右节点是D和F。1234567 C / \ A E / / \ B D F / \ G H 到此，我们得到了这棵完整的二叉树，因此，它的后序遍历就是：GHBADFEC。 那么，思路变得简单了（0.0），即对于现有的序列，先确定根节点，根节点的左子树，根节点的右子树序列，然后在各子树中递归建树。递归的终止条件为序列为空（体现在起始值与终止值上）。 具体实现如下：1234567891011121314151617181920class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; TreeNode res = mybuild(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); return res; &#125; private TreeNode mybuild(int[] preorder, int startpre, int endpre, int[] inorder, int startin, int endin) &#123; if (startpre &gt; endpre || startin &gt; endin) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[startpre]); for (int i = startin; i &lt;= endin; i++) &#123; if (inorder[i] == root.val) &#123; root.left = mybuild(preorder, startpre + 1, startpre + i - startin, inorder, startin, i - 1); root.right = mybuild(preorder, startpre - startin + i + 1, endpre, inorder, i + 1, endin); &#125; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(36) Valid Sudoku]]></title>
    <url>%2F2018%2F07%2F20%2Fleetcode36-valid-sudoku%2F</url>
    <content type="text"><![CDATA[Description: Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character &#39;.&#39;. Example 1: Input:[ [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”], [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”], [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”], [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”], [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”], [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”], [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”], [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”], [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]Output: true Example 2: Input:[ [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”], [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”], [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”], [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”], [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”], [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”], [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”], [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”], [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner beingmodified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character &#39;.&#39;. The given board size is always 9x9. 解法： 此题无需判断数独是否有解，只需要保证3个基本条件，即每一行的元素不重复，每一列的元素不重复，每一个子格的元素不重复。对于重复的判断，借用数据结构Map（因为Map的Key不允许重复）。 整体上来看，判断是否重复的对象为9行，9列，9个子格，故外层需循环9次。而内层循环针对外层循环的内部元素进行循环。对于行，列，子格，其内部都有9个最小单位元素。 对于行而言，第i行对应的元素为1board[i][j] 对于列而言，第i列对应的元素为1board[j][i] 对于子格元素的对应 观察行号规律： 第0个九宫格：000111222; 第1个九宫格：000111222; 第2个九宫格：000111222; 第3个九宫格：333444555; 第4个九宫格：333444555; 第5个九宫格：333444555; 第6个九宫格：666777888; 第7个九宫格：666777888; 第8个九宫格：666777888; 可见对于每三个九宫格行号增3；对于单个九宫格，每三个格点行号增1。 因此第i个九宫格的第j个格点的行号可表示为i/3*3+j/3 观察列号规律： 第0个九宫格：012012012; 第1个九宫格：345345345; 第2个九宫格：678678678; 第3个九宫格：012012012; 第4个九宫格：345345345; 第5个九宫格：678678678; 第6个九宫格：012012012; 第7个九宫格：345345345; 第8个九宫格：678678678; 可见对于下个九宫格列号增3，循环周期为3；对于单个九宫格，每个格点行号增1，周期也为3。 周期的数学表示就是取模运算mod。 因此第i个九宫格的第j个格点的列号可表示为i%3*3+j%3 故为：1board[i/3*3 + j/3][i%3*3 + j%3] 具体代码如下：123456789101112131415161718192021222324252627282930class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for (int i = 0; i &lt; 9; i++) &#123; Map&lt;Character, Boolean&gt; judge_row = new HashMap&lt;Character, Boolean&gt;(); Map&lt;Character, Boolean&gt; judge_col = new HashMap&lt;Character, Boolean&gt;(); Map&lt;Character, Boolean&gt; judge_sub = new HashMap&lt;Character, Boolean&gt;(); for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != '.') &#123; if (judge_row.containsKey(board[i][j])) &#123; return false; &#125; judge_row.put(board[i][j], true); &#125; if (board[j][i] != '.') &#123; if (judge_col.containsKey(board[j][i])) &#123; return false; &#125; judge_col.put(board[j][i], true); &#125; if (board[i / 3 * 3 + j / 3][i % 3 * 3 + j % 3] != '.') &#123; if (judge_sub.containsKey(board[i / 3 * 3 + j / 3][i % 3 * 3 + j % 3])) &#123; return false; &#125; judge_sub.put(board[i / 3 * 3 + j / 3][i % 3 * 3 + j % 3], true); &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(100) Same Tree]]></title>
    <url>%2F2018%2F07%2F20%2Fleetcode100-same-tree%2F</url>
    <content type="text"><![CDATA[Description:Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 123456 1 1 / \ / \ 2 3 2 3[1,2,3], [1,2,3] Output: true Example 2:123456Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3: Input:12345 1 1 / \ / \ 2 1 1 2[1,2,1], [1,1,2] Output: false 解法：相对而言比较简单的题，对于树做遍历，我这里采用的是按层遍历，对比每一个元素判断是否相同。采用的Java的队列，因为队列为空不好判断（下回用Stack可能会好一点），这里采用了虚拟节点（也算是撞对了吧0.0）。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; Queue&lt;TreeNode&gt; queuep = new LinkedList&lt;TreeNode&gt;(); Queue&lt;TreeNode&gt; queueq = new LinkedList&lt;TreeNode&gt;(); queuep.offer(p); queueq.offer(q); while (queuep.peek() != null &amp;&amp; queueq.peek() != null) &#123; TreeNode tmp1 = queuep.poll(); TreeNode tmp2 = queueq.poll(); if (tmp1.val == tmp2.val) &#123; if (tmp1.val == -32767) &#123; continue; &#125; else &#123; if (tmp1.left != null) &#123; queuep.offer(tmp1.left); &#125; else &#123; queuep.offer(new TreeNode(-32767)); &#125; if (tmp1.right != null) &#123; queuep.offer(tmp1.right); &#125; else &#123; queuep.offer(new TreeNode(-32767)); &#125; if (tmp2.left != null) &#123; queueq.offer(tmp2.left); &#125; else &#123; queueq.offer(new TreeNode(-32767)); &#125; if (tmp2.right != null) &#123; queueq.offer(tmp2.right); &#125; else &#123; queueq.offer(new TreeNode(-32767)); &#125; &#125; &#125; else &#123; return false; &#125; &#125; if (queuep.peek() == null &amp;&amp; queueq.peek() != null) &#123; return false; &#125; else if (queueq.peek() == null &amp;&amp; queuep.peek() != null) &#123; return false; &#125; else &#123; return true; &#125; &#125;&#125; 除了借用队列以外，其实还可以采用深度优先搜索的递归方法进行比较，代码如下：12345678class Solution &#123;public: bool isSameTree(TreeNode \*p, TreeNode \*q) &#123; if (!p &amp;&amp; !q) return true; if ((p &amp;&amp; !q) || (!p &amp;&amp; q) || (p-&gt;val != q-&gt;val)) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(66) Plus One]]></title>
    <url>%2F2018%2F07%2F20%2Fleetcode66-plus-one%2F</url>
    <content type="text"><![CDATA[Description:Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123. Example 2: Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 解法：模拟加法运算题，注意进位问题，尤其是从如99到100的问题。实现起来还是比较简单的，具体代码如下：123456789101112131415161718192021222324class Solution &#123; public int[] plusOne(int[] digits) &#123; int[] tmp = new int[digits.length + 1]; int jinwei = 1; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; int d = digits[i] + jinwei; if (d == 10) &#123; jinwei = 1; d = 0; &#125; else &#123; jinwei = 0; &#125; tmp[i] = d; &#125; if (jinwei == 1) &#123; tmp[0] = 1; return tmp; &#125; for (int i = 0; i &lt; digits.length; i++) &#123; digits[i] = tmp[i]; &#125; return digits; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(38) Count and Say]]></title>
    <url>%2F2018%2F07%2F20%2Fleetcode38-count-and-say%2F</url>
    <content type="text"><![CDATA[Description:The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 12. 113. 214. 12115. 111221 1 is read off as &quot;one 1&quot; or 11. 11 is read off as &quot;two 1s&quot; or 21. 21 is read off as &quot;one 2, then one 1&quot; or 1211. Given an integer _n_, generate the _n_th term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: Input: 1Output: “1” Example 2: Input: 4Output: “1211” 解法：首先理解题意。简而言之，就是这一个数对应字符串的生成由前一个数的字符串决定。具体来说，从前一个字符串的第一个字符数起，数相同字符的个数，然后将个数与该字符存入本数对应的字符串，再继续扫描计数。比如，对于4而言，前一个数3的字符串为21，则4为1个2一个1，即1211。可以发现，每一个数与前一个数的结果有关，采用递归实现，代码如下：123456789101112131415161718192021class Solution &#123; public String countAndSay(int n) &#123; if(n == 1)&#123; return "1"; &#125; String str = countAndSay(n-1) +'*'; //防止越界，方便计数 char[] cstr = str.toCharArray(); String result = ""; int count = 1; for(int i = 0;i&lt;cstr.length - 1;i++)&#123; if(cstr[i] == cstr[i+1])&#123; count +=1; &#125; else&#123; result += (String.valueOf(count) + cstr[i]) ; count = 1; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(62) Unique Paths]]></title>
    <url>%2F2018%2F07%2F17%2Fleetcode62-unique-paths%2F</url>
    <content type="text"><![CDATA[Description:A robot is located at the top-left corner of a _m_ x _n_ grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: _m_ and _n_ will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -&gt; Right -&gt; Down 2. Right -&gt; Down -&gt; Right 3. Down -&gt; Right -&gt; Right Example 2: Input: m = 7, n = 3 Output: 28 解法：此题同样用动态规划法，思路同Leetcode(63) Unique Paths II。代码如下：12345678910111213141516171819202122232425class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] tmp = new int[m][n]; if(m == 1 || n == 1)&#123; return 1; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if(i == 0 &amp;&amp; j == 0)&#123; tmp[i][j] = 1; &#125; else if (i == 0 &amp;&amp; j &gt; 0) &#123; tmp[i][j] = tmp[i][j - 1]; &#125; else if (j == 0 &amp;&amp; i &gt; 0) &#123; tmp[i][j] = tmp[i - 1][j]; &#125; else &#123; tmp[i][j] = tmp[i - 1][j] + tmp[i][j - 1]; &#125; &#125; &#125; return tmp[m-1][n-1]; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(63) Unique Paths II]]></title>
    <url>%2F2018%2F07%2F17%2Fleetcode63-unique-paths-ii%2F</url>
    <content type="text"><![CDATA[Description:A robot is located at the top-left corner of a _m_ x _n_ grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: _m_ and _n_ will be at most 100. Example 1: Input: [ [0,0,0], [0,1,0], [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -&gt; Right -&gt; Down -&gt; Down 2. Down -&gt; Down -&gt; Right -&gt; Right 解法：首先考虑采用队列进行解题（毕竟迷宫地图类常用套路0.0），然而在矩阵较小时挺好，遇上大矩阵就超时了。以下为该方法代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; Queue&lt;pointposition&gt; queue = new LinkedList&lt;pointposition&gt;(); int row = obstacleGrid.length; int col = obstacleGrid[0].length; if (obstacleGrid[0][0] == 1) &#123; return 0; &#125; if (row == 1 &amp;&amp; col == 1) &#123; return 1; &#125; int result = 0; pointposition start = new pointposition(0, 0); pointposition end = new pointposition(row - 1, col - 1); queue.offer(start); while (queue.peek() != null) &#123; pointposition now = queue.poll(); if (now.equal(end)) &#123; result += 1; continue; &#125; pointposition next1 = new pointposition(now.posx + 1, now.posy); pointposition next2 = new pointposition(now.posx, now.posy + 1); if (judge(next1, row, col) &amp;&amp; obstacleGrid[next1.posx][next1.posy] != 1) &#123; queue.offer(next1); &#125; if (judge(next2, row, col) &amp;&amp; obstacleGrid[next2.posx][next2.posy] != 1) &#123; queue.offer(next2); &#125; &#125; return result; &#125; Boolean judge(pointposition x, int row, int col) &#123; if (x.posx &gt;= 0 &amp;&amp; x.posx &lt; row &amp;&amp; x.posy &gt;= 0 &amp;&amp; x.posy &lt; col) &#123; return true; &#125; return false; &#125;&#125;class pointposition &#123; public int posx; public int posy; pointposition(int x, int y) &#123; this.posx = x; this.posy = y; &#125; boolean equal(pointposition x) &#123; if (this.posx == x.posx &amp;&amp; this.posy == x.posy) &#123; return true; &#125; return false; &#125;&#125; 考虑到在这种情形下，无论从起点到终点还是从终点到起点，路径的数目是一样的。我们可以按照每一个点到起点的路径数逆推得到终点到起点的路径数。对于起点，起点到起点的路径数为1.对于其他点，它们到起点的路径数一定等于在它上方的点到起点的路径数与在它左方的点到起点的路径数之和，因为这个点只能通过它的上方和左方两个方向到达起点。简而言之，采用动态规划的方法解题，该问题的状态转移函数为：1nums(i , j) = nums(i , j-1) + nums(i-1 , j) 需要注意的是，本题中存在障碍物，对于障碍物的点，显然，它到起点的路径数为0。AC动态规划代码如下：1234567891011121314151617181920212223242526272829class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int row = obstacleGrid.length; int col = obstacleGrid[0].length; if (obstacleGrid[0][0] == 1) &#123; return 0; &#125; if (row == 1 &amp;&amp; col == 1) &#123; return 1; &#125; int[][] tmp = new int[row][col]; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (obstacleGrid[i][j] == 1) &#123; tmp[i][j] = 0; &#125; else if (i == 0 &amp;&amp; j == 0) &#123; tmp[i][j] = 1; &#125; else if (i == 0 &amp;&amp; j &gt; 0) &#123; tmp[i][j] = tmp[i][j - 1]; &#125; else if (j == 0 &amp;&amp; i &gt; 0) &#123; tmp[i][j] = tmp[i - 1][j]; &#125; else &#123; tmp[i][j] = tmp[i - 1][j] + tmp[i][j - 1]; &#125; &#125; &#125; return tmp[row - 1][col - 1]; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(35) Search Insert Position]]></title>
    <url>%2F2018%2F07%2F17%2Fleetcode35-search-insert-position%2F</url>
    <content type="text"><![CDATA[Description:Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1:Input: [1,3,5,6], 5 Output: 2 Example 2:Input: [1,3,5,6], 2 Output: 1 Example 3:Input: [1,3,5,6], 7 Output: 4 Example 4:Input: [1,3,5,6], 0 Output: 0 解法：这题简单，从前往后扫描一遍数组，遇见大于或等于目标值的条目直接返回索引值即可，代码如下：12345678910class Solution &#123; public int searchInsert(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt;= target) &#123; return i; &#125; &#125; return nums.length; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(30) Substring with Concatenation of All Words]]></title>
    <url>%2F2018%2F07%2F11%2Fleetcode30-substring-with-concatenation-of-all-words%2F</url>
    <content type="text"><![CDATA[Description:You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1:Input: s = “barfoothefoobarman”, words = [“foo”,”bar”] Output: [0,9] Example 2:Input: s = “wordgoodstudentgoodword”, words = [“word”,”student”] Output: [] 解法：题意有点绕，意思是是给你一个字符串，和一个字符串的数组，需要返回一个该字符串的索引组成的数组，其中字符串数组中各成员长度要求一致，返回的索引有如下性质： 从每个索引开始，长度为L的字串需要精确包含字符串数组中的所有字符串（不多不少）。L 为字符串数组中所有字符串长度之和。 思路是：先用一个Map结构，记录字符串数组中各个字符串出现的个数，用于之后判断子串中各字符串是否出现够数，之后，从头开始遍历字符串，找和字符串数组中的字符串相同的字串，找到后map中的值减一，否则重新初始化map，从下一个字符开始遍历。如果map中所有的值都为0，则找到了一个符合条件的子串，索引压入数组。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; Map&lt;String, Integer&gt; wordcount = new HashMap&lt;String, Integer&gt;(); List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(s == "" || words.length == 0)&#123; return result; &#125; int wordlen = words[0].length(); int word_count = words.length; for (String word : words) &#123; if(word.length()!=wordlen)&#123; return result; &#125; if (!wordcount.containsKey(word)) &#123; wordcount.put(word, 1); &#125; else &#123; wordcount.put(word, wordcount.get(word) + 1); &#125; &#125; for (int i = 0; i &lt;= s.length() - wordlen; i++) &#123; String tmpsub = s.substring(i, i + wordlen); Map&lt;String, Integer&gt; tmpmap = new HashMap&lt;&gt;(); tmpmap.putAll(wordcount); if (!tmpmap.containsKey(tmpsub)) &#123; continue; &#125; else &#123; int remain_word_count = word_count; int j = i; while (remain_word_count &gt; 0) &#123; if (tmpmap.get(tmpsub) &gt; 0) &#123; tmpmap.put(tmpsub, tmpmap.get(tmpsub) - 1); j += wordlen; remain_word_count -= 1; if(j&gt;s.length() - wordlen)&#123; break; &#125; tmpsub = s.substring(j, j + wordlen); if (!tmpmap.containsKey(tmpsub))&#123; break; &#125; &#125; else &#123; break; &#125; &#125; if(remain_word_count == 0)&#123; result.add(i); &#125; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(29) Divide Two Integers]]></title>
    <url>%2F2018%2F07%2F11%2Fleetcode29-divide-two-integers%2F</url>
    <content type="text"><![CDATA[Description:Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1:Input: dividend = 10, divisor = 3 Output: 3 Example 2:Input: dividend = 7, divisor = -3 Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. 解法：除法可以采用减法实现，未避免减法次数过多，采用二分法可减少运算次数。 不难想到用除数的2^31,2^30,…,2^2,2^1,2^0倍尝试去减被除数，如果减得动，则把相应的倍数加到商中；如果减不动，则依次尝试更小的倍数。这样就可以快速逼近最终的结果。 2的i次方其实就相当于左移i位，为什么从31位开始呢？因为int型数据最大值就是2^31啊。 注：左移x位相当于乘2的x次方，右移x位相当于除2的x次方 代码如下：123456789101112131415161718192021class Solution &#123; public int divide(int dividend, int divisor) &#123; if (divisor == 0 || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1)) return Integer.MAX_VALUE; long a = dividend &gt; 0 ? dividend : -(long) dividend; long b = divisor &gt; 0 ? divisor : -(long) divisor; if (b == 1) &#123; return divisor == 1 ? dividend : -dividend; &#125; int result = 0; for (int i = 31; i &gt;= 0; i--) &#123; if ((a &gt;&gt; i) &gt;= b) &#123; result += (1 &lt;&lt; i); a = a - (b &lt;&lt; i); &#125; &#125; if ((dividend ^ divisor) &lt; 0) &#123; result = -result; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式语法]]></title>
    <url>%2F2018%2F04%2F03%2Fe6-ad-a3-e5-88-99-e8-a1-a8-e8-be-be-e5-bc-8f-e8-af-ad-e6-b3-95%2F</url>
    <content type="text"><![CDATA[正则表达式单个字符的正则匹配： 字符 匹配 . 匹配除了‘\n’以外的任意单个字符 […] 匹配字符集中的任意字符（即两个中括号表示字符集）.如[a-z]匹配任意一个小写字母，[ab]匹配a或b，[a-zA-Z]匹配任意字母 \d 匹配任意一个数字 \D 匹配任意一个非数字 \s 匹配空白字符 \S 匹配非空白字符 \w 匹配一个单词字符，即[a-zA-Z0-9] \W 匹配一个非单词字符 多个字符的匹配（与单个字符相结合使用）： 字符 匹配 * 匹配前一个字符0到无限次 + 匹配前一个字符1到无限次 ? 匹配前一个字符0次或1次 {m} 匹配前一个字符m次 {m,n} 匹配前一个字符m次到n次 *? 非贪婪地进行匹配，对于则最少匹配0次，如1[a-z]?匹配1a时只匹配到1 +? 非贪婪地进行匹配，对+则最少匹配一次 ?? 非贪婪地进行匹配，对?则最少匹配0次 边界匹配： 字符 匹配 ^ 匹配字符串的开头 $ 匹配字符串的结尾 \A 指定的字符串必须出现在开头，如\Ahzh[\w]*匹配以hzh开头的任意字符串 \Z 指定的字符串必须出现在结尾 分组匹配： 字符 匹配 \ 匹配左右任意一个表达式，相当与或]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(28) Implement strStr()]]></title>
    <url>%2F2018%2F03%2F29%2Fleetcode28-implement-strstr%2F</url>
    <content type="text"><![CDATA[Description:Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1:Input: haystack = “hello”, needle = “ll” Output: 2 Example 2:Input: haystack = “aaaaa”, needle = “bba” Output: -1 解法：首先做特别判断，如果needle的长度大于haystack，不可能匹配，返回-1，如果needle为空，返回0。然后我们开始遍历母字符串，我们并不需要遍历整个母字符串，而是遍历到剩下的长度和子字符串相等的位置即可，这样可以提高运算效率。然后对于每一个字符，我们都遍历一遍子字符串，一个一个字符的对应比较，如果对应位置有不等的，则跳出循环，如果一直都没有跳出循环，则说明子字符串出现了，则返回起始位置即可，代码如下：123456789101112131415161718192021222324252627class Solution: def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ p = 0; q = 0; if(len(needle)&gt;len(haystack)): return -1; if(len(needle) == 0): return 0; while(p&lt;len(haystack)-len(needle)+1): if(haystack[p] == needle[0]): q = p; flag = 1; for x in needle: if(x == haystack[q]): q+=1; else: flag = 0; break; if(flag == 1): return p; p+=1; return -1; 更好写的递归的算法： 判断节点的数量是否构成一组，如果不够，直接返回head，如果够，则将当前组反转，之后的链表变为当前问题的子问题，递归即可，然后再把这两部分连接起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if(head == null || head.next == null || k == 1)&#123; return head; &#125; ListNode tmp = head; int step = 1; while(tmp != null &amp;&amp; step &lt; k) &#123; tmp = tmp.next; step++; &#125; if(tmp == null) &#123; return head; &#125; else&#123; ListNode t2 = tmp.next; tmp.next = null; ListNode newhead = reverseList(head); ListNode newtmp = reverseKGroup(t2,k); head.next = newtmp; return newhead; &#125; &#125; ListNode reverseList(ListNode head) &#123; if (head == null) &#123; return head; &#125; if (head.next == null) &#123; return head; &#125; ListNode res = reverseList(head.next); head.next.next = head; head.next = null; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(27) Remove Element]]></title>
    <url>%2F2018%2F03%2F29%2Fleetcode27-remove-element%2F</url>
    <content type="text"><![CDATA[Description:Given an array and a value, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. 解法：此题与26题类似，同样两个指针，快指针用于遍历数组，慢指针用于覆盖指定值，当快指针的值和给定值不同，我们就把慢指针处的值用快指针的值覆盖，并将慢指针加1，快指针加1。代码如下：12345678910111213141516171819class Solution: def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if(len(nums) == 0): return 0; p = 0; q = 0; while(q&lt;len(nums)): if(nums[q] != val): nums[p] = nums[q]; p+=1; q+=1; else: q+=1; return p;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(26) Remove Duplicates from Sorted Array]]></title>
    <url>%2F2018%2F03%2F29%2Fleetcode26-remove-duplicates-from-sorted-array%2F</url>
    <content type="text"><![CDATA[Description:Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example:Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 解法：采用双指针法，最开始时两个指针都指向第一个数字，如果两个指针指的数字相同，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数，代码如下：12345678910111213141516class Solution: def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if(len(nums) == 0): return 0; p = q = 0; while(p&lt;len(nums) and q &lt; len(nums)): if(nums[p] == nums[q]): q+=1; else: p+=1; nums[p] = nums[q]; return p+1;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(25) Reverse Nodes in k-Group]]></title>
    <url>%2F2018%2F03%2F28%2Fleetcode25-reverse-nodes-in-k-group%2F</url>
    <content type="text"><![CDATA[Description:Given a linked list, reverse the nodes of a linked list _k_ at a time and return its modified list. _k_ is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of _k_ then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. For example, Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For _k_ = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For _k_ = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 解法：一般在处理链表问题时，我们大多时候都会在开头再加一个dummy node，因为翻转链表时头结点可能会变化，为了记录当前最新的头结点的位置而引入的dummy node。具体到思路，每次以k为分段，翻转这k个节点，整体需要翻转的数减去k，如果剩余翻转点小于k无需继续进行翻转。翻转的过程中从前往后扫描，需要pre,last,tmp和cur四个指针。具体代码如下：1234567891011121314151617181920212223242526272829303132333435363738# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def reverseKGroup(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if(head == None or k == 1): return head; dummy = ListNode(-1); dummy.next = head; pre = dummy; cur = head; num = 0; while(cur): cur = cur.next; num+=1; while(num&gt;=k): cur = pre.next; last = cur; for i in range(k): last = last.next; for i in range(k): t = cur.next; cur.next = last; last = cur; cur = t; tmp = pre.next; pre.next = last; pre = tmp; num -= k; return dummy.next;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(24) Swap Nodes in Pairs]]></title>
    <url>%2F2018%2F03%2F28%2Fleetcode24-swap-nodes-in-pairs%2F</url>
    <content type="text"><![CDATA[Description:iven a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解法：需要建立dummy节点，（即头指针前的虚拟节点），注意在连接节点的时候，最好画个图，以免把自己搞晕了，代码如下：123456789101112131415161718192021222324# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if(head == None): return None; dummy = ListNode(-1); pre = dummy; dummy.next = head; while(pre.next and pre.next.next): tmp = pre.next; pre.next = tmp.next; tmp.next = pre.next.next; pre.next.next = tmp; pre = tmp; return dummy.next;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(23) Merge k Sorted Lists]]></title>
    <url>%2F2018%2F03%2F28%2Fleetcode23-merge-k-sorted-lists%2F</url>
    <content type="text"><![CDATA[Description:Merge _k_ sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 解法：利用了最小堆这种数据结构，我们首先把k个链表的首元素都加入最小堆中，它们会自动排好序。然后我们每次取出最小的那个元素加入我们最终结果的链表中，然后把取出元素的下一个元素再加入堆中，下次仍从堆中取出最小的元素做相同的操作，以此类推，直到堆中没有元素了，此时k个链表也合并为了一个链表，返回首节点即可，代码如下：123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; PriorityQueue&lt;ListNode&gt; q = new PriorityQueue&lt;&gt;(new Comparator&lt;ListNode&gt;() &#123; @Override public int compare(ListNode a, ListNode b) &#123; return a.val - b.val; &#125; &#125;); for (int i = 0; i &lt; lists.length; i++) &#123; if (lists[i] != null) &#123; q.offer(lists[i]); &#125; &#125; ListNode res = null; ListNode tail = null; while (!q.isEmpty()) &#123; ListNode tmp = q.poll(); if (res == null) &#123; res = tmp; tail = tmp; &#125; else &#123; tail.next = tmp; tail = tmp; &#125; if (tmp.next != null) &#123; q.offer(tmp.next); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(22) Generate Parentheses]]></title>
    <url>%2F2018%2F03%2F27%2Fleetcode22-generate-parentheses%2F</url>
    <content type="text"><![CDATA[Description:Given _n_ pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given _n_ = 3, a solution set is: [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()” ] 解法：看到这道题首先想到了DFS，递归可以解决这个问题。 对于递归类问题，解题思路大体是：在当前局面下，你有若干种选择。那么尝试每一种选择。如果已经发现某种选择肯定不行（因为违反了某些限定条件），就返回；如果某种选择试到最后发现是正确解，就将其加入解集。简而言之，只要明确三点就行：选择 (Options)，限制 (Restraints)，结束条件 (Termination)。结束条件与限制均返回，两者的区别在于结束条件是合法搜索完了返回，而限制是遇上了非法情况返回的。 对于这道题，在任何时刻，你都有两种选择： 加左括号。 加右括号。 这部分构成了递归体 结束条件也很明确： 左右括号都已经用完了 这部分构成了合法完成搜索的递归出口 而限制则考虑搜索过程中的非法情况，即出现了这种情况不再进行递归搜索而返回： 对于该题，从左括号与右括号的数量入手，两者数目相同，显然合法；如果剩余的右括号数量大于左括号数量，说明之前存在没有与右括号匹配的左括号，这种情况是合法有效的；若出现左括号数目大于右括号的情况，则对于之后添加的左括号，一定会存在没有右括号与之匹配的情况，这种情况非法，不用再继续进行搜索了。简而言之： 如果左括号剩余量大于右括号，会出现非法情况，返回 代码如下：1234567891011121314151617181920class Solution: def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ res = []; Solution.dfs(n,n,"",res); return res; def dfs(left,right,nowstr,res): if(left&gt;right): return; if(left == 0 and right == 0): res.append(nowstr); return; if(left &gt; 0): Solution.dfs(left - 1, right ,nowstr + '(',res); if(right &gt; 0): Solution.dfs(left,right - 1,nowstr + ')', res);]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(21) Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F03%2F21%2Fleetcode21-merge-two-sorted-lists%2F</url>
    <content type="text"><![CDATA[Description:Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解法：新建一个链表，然后比较两个链表中的元素值，把较小的那个链到新链表中，由于两个输入链表的长度可能不同，所以最终会有一个链表先完成插入所有元素，则直接另一个未完成的链表直接链入新链表的末尾。代码如下：12345678910111213141516171819202122232425262728293031323334# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ p = l1; q = l2; result = ListNode(-1); x = result; while(p!= None and q != None): if(p.val &lt; q.val): tmp = ListNode(p.val); x.next = tmp; p = p.next; x = x.next; else: tmp = ListNode(q.val); x.next = tmp; q = q.next; x = x.next; if(p != None): x.next = p; else: x.next = q; result = result.next; return result;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(20) Valid Parentheses]]></title>
    <url>%2F2018%2F03%2F21%2Fleetcode20-valid-parentheses%2F</url>
    <content type="text"><![CDATA[Description:Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not. 解法：利用栈做匹配，正括号都入栈，反括号入栈时查看有无匹配，有则对应正括号出栈，否则匹配失败，字符串不合法。当最终栈空时匹配成功，否则失败。特别注意“( [ ) ]”的情况，是不合法的。代码如下：12345678910111213141516171819202122232425262728class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ l = []; for c in s: if(c == '(' or c == '[' or c == '&#123;'): l.append(c); elif(c == ')'): if(len(l) != 0 and l[-1] == '('): l = l[:-1]; else: return False; elif(c == ']'): if(len(l) != 0 and l[-1] == '['): l = l[:-1]; else: return False; elif(c == '&#125;'): if(len(l) != 0 and l[-1] == '&#123;'): l = l[:-1]; else: return False; if(len(l) == 0): return True; return False;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(19) Remove Nth Node From End of List]]></title>
    <url>%2F2018%2F03%2F20%2Fleetcode19-remove-nth-node-from-end-of-list%2F</url>
    <content type="text"><![CDATA[Description:Given a linked list, remove the _n_th node from the end of list and return its head. For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Try to do this in one pass. 解法：由于只允许一次遍历，所以我们不能用一次完整的遍历来统计链表中元素的个数，而是遍历到对应位置就应该移除了。那么我们需要用两个指针来帮助我们解题，pre和cur指针。首先cur指针先向前走N步，如果此时cur指向空，说明N为链表的长度，则需要移除的为首元素，那么此时我们返回head-&gt;next即可，如果cur存在，我们再继续往下走，此时pre指针也跟着走，直到cur为最后一个元素时停止，此时pre指向要移除元素的前一个元素，我们再修改指针跳过需要移除的元素即可。代码如下：123456789101112131415161718192021class Solution: def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ p = head; tmp = p; for i in range(n): q = tmp.next; tmp = q; if(q == None): return head.next; while(q.next != None): p = p.next; q = q.next; tmp = p.next; if(tmp != None): p.next = tmp.next; return head;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(18) 4Sum]]></title>
    <url>%2F2018%2F03%2F19%2Fleetcode18-4sum%2F</url>
    <content type="text"><![CDATA[Description:Given an array _S_ of _n_ integers, are there elements _a_, _b_, _c_, and _d_ in _S_ such that _a_ + _b_ + _c_ + _d_ = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 解法：虽然难度在递增，但是整体的套路都是一样的，在于如何去除重复项，由于Python中list不可哈希，利用set或dict进行去重时需要先把list转化为tuple，此题的解法和3 Sum基本没啥区别，就是多加了一层for循环，其他的都一样，代码如下：123456789101112131415161718192021222324252627282930313233class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ nums.sort(); result = []; for i in range(len(nums) - 3): for j in range(i +1,len(nums) - 2): p = j+1;q = len(nums) - 1; while(p&lt;q): sum = nums[i] + nums[j] + nums[p] + nums[q]; if(sum == target): tmp = [nums[i],nums[j],nums[p],nums[q]]; result.append(tmp); p+=1; q-=1; elif(sum &lt; target): p+=1; else: q-=1; r = []; for x in result: tmp = tuple(x); r.append(tmp); r = list(set(tuple(r))); result =[]; for x in r: tmp = list(x); result.append(tmp); return result;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(17) Letter Combinations of a Phone Number]]></title>
    <url>%2F2018%2F03%2F19%2Fleetcode17-letter-combinations-of-a-phone-number%2F</url>
    <content type="text"><![CDATA[Description:Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Input:Digit string “23” Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 解法：迭代法解题，即依次读取字符串中的每位数字，然后把数字对应的字母依次加到当前的所有结果中，然后进入下一次迭代。代码如下：1234567891011121314151617181920212223class Solution: def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ d = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]; result = []; if(len(digits) == 0): return []; di = int(digits[0]); for j in range(len(d[di])): result.append(d[di][j]); i = 1; while(i&lt; len(digits)): di = int(digits[i]); tmp = []; for x in result: for j in d[di]: tmp.append(x + j); result = tmp; i+=1; return result;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(16) 3Sum Closest]]></title>
    <url>%2F2018%2F03%2F19%2Fleetcode16-3sum-closest%2F</url>
    <content type="text"><![CDATA[Description:Given an array _S_ of _n_ integers, find three integers in _S_ such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 解法：同三数和的解法，用三个指针移动遍历各种可能性。代码如下：1234567891011121314151617181920212223242526class Solution: def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ nums.sort(); i = 0; dis = 233333333; while(i &lt; len(nums) - 2): p = i + 1; q = len(nums) - 1; remain = target - nums[i]; while(p&lt;q): if(abs(remain - nums[p] - nums[q]) &lt; dis): dis = abs(remain - nums[p] - nums[q]); result = nums[i] + nums[p] + nums[q]; if(nums[p] + nums[q] == remain): return target; elif(nums[p] + nums[q] &lt; remain): p+=1; else: q-=1; i+=1; return result;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(15) 3Sum]]></title>
    <url>%2F2018%2F03%2F08%2Fleetcode15-3sum%2F</url>
    <content type="text"><![CDATA[Description:Given an array _S_ of _n_ integers, are there elements _a_, _b_, _c_ in _S_ such that _a_ + _b_ + _c_ = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 解法：参考：http://blog.csdn.net/u010656539/article/details/52204607 首先，两数和问题这样做。先对数组中的数进行排序，再设置两个指针，一个指向头，一个指向尾。判断两数和是否等于想要的数，如果是则在结果集添加这个数组；如果小了说明左边指针指向的数小了，因此左指针右移；反之如果大了则右指针左移。 尝试把三数和问题转化为两数和问题：同样先对数组排序，设置三个指针p,q,r，p指针指向第一个数x，则q,r要指向数组中剩余数中的两个，并且指向的两数和为-x，从而转化为两数和问题。对p指向第一个数的情况分析完毕后，不可能再有满足题意且包含x的情况，于是p右移。这样一直分析到p指向数组中倒数第三个数的情况。注意跳过所有重复的情况。 代码如下： 123456789101112131415161718192021222324252627282930313233343536class Solution: def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ nums.sort(); res = []; i = 0; while(i&lt;len(nums)-2): r = []; r.append(nums[i]); sum = 0 - nums[i]; p = i + 1; q = len(nums) - 1; while(p&lt;q): if(nums[p] + nums[q] == sum): r.append(nums[p]); r.append(nums[q]); res.append(r); r = []; r.append(nums[i]); p+=1; q-=1; while(p&lt;q and nums[p] ==nums[p-1]): p+=1; while(p&lt;q and nums[q] == nums[q+1]): q-=1; elif(nums[p] + nums[q] &lt; sum): p+=1; else: q-=1; while(i&lt;len(nums)-2 and nums[i+1] == nums[i]): i+=1; i+=1; return res;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(14) Longest Common Prefix]]></title>
    <url>%2F2018%2F03%2F06%2Fleetcode14-longest-common-prefix%2F</url>
    <content type="text"><![CDATA[Description: Write a function to find the longest common prefix string amongst an array of strings. 解法：暴力查找字符串集合中的相同前缀，将单词上下排好，相当于一个各行长度有可能不相等的二维数组，采用纵向逐列遍历，在遍历的过程中，如果某一行没有了，说明其为最短的单词，因为共同前缀的长度不能长于最短单词，所以此时返回已经找出的共同前缀。我们每次取出第一个字符串的某一个位置的单词，然后遍历其他所有字符串的对应位置看是否相等，如果有不满足的直接返回res，如果都相同，则将当前字符存入结果，继续检查下一个位置的字符，代码如下：123456789101112131415class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; output = new ArrayList(); helper(root,output); return output; &#125; void helper(TreeNode root,List&lt;Integer&gt; output)&#123; if(root == null)&#123; return; &#125; helper(root.left,output); helper(root.right,output); output.add(root.val); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(13) Roman to Integer]]></title>
    <url>%2F2018%2F03%2F06%2Fleetcode13-roman-to-integer%2F</url>
    <content type="text"><![CDATA[Description:Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 解法：我们只要考虑两种情况即可： 第一，如果当前数字是最后一个数字，或者之后的数字比它小的话，则加上当前数字 第二，其他情况则减去这个数字 代码如下：123456789101112131415class Solution: def romanToInt(self, s): """ :type s: str :rtype: int """ d = &#123;'I': 1 , 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D' : 500, 'M': 1000&#125;; res = 0; for i in range(len(s)): val = d[s[i]]; if(i == len(s) - 1 or d[s[i]]&gt;=d[s[i+1]]): res += val; else: res-=val; return res;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(12) Integer to Roman]]></title>
    <url>%2F2018%2F03%2F06%2Fleetcode12-integer-to-roman%2F</url>
    <content type="text"><![CDATA[Description:Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 解法：参考：http://www.cnblogs.com/grandyang/p/4123374.html 转换法则如下： 基本字符 I V X L C D M 相应的阿拉伯数字表示为 1 5 10 50 100 500 1000 例如整数 1437 的罗马数字为 MCDXXXVII， 我们不难发现，千位，百位，十位和个位上的数分别用罗马数字表示了。 1000 – M, 400 – CD, 30 – XXX, 7 – VII。 所以我们要做的就是用取商法分别提取各个位上的数字，然后分别表示出来： 100 – C 200 – CC 300 – CCC 400 – CD 500 – D 600 – DC 700 – DCC 800 – DCCC 900 – CM 我们可以分为四类，100到300一类，400一类，500到800一类，900最后一类。每一位上的情况都是类似的，代码如下：1234567891011121314151617181920212223242526class Solution: def intToRoman(self, num): """ :type num: int :rtype: str """ roman = ['M', 'D', 'C', 'L', 'X', 'V', 'I']; value = [1000, 500, 100, 50, 10, 5, 1]; i = 0; res = ""; while(i&lt;=6): x = int(num /value[i]); if(x &lt; 4): for j in range(x): res += roman[i]; elif(x == 4): res += (roman[i] +roman[i-1]); elif( x &gt; 4 and x &lt; 9): res += roman[i - 1]; for j in range(x - 5): res += roman[i]; else: res += roman[i] + roman[i-2]; num %= value[i]; i+=2; return res;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(11) Container With Most Water]]></title>
    <url>%2F2018%2F03%2F06%2Fleetcode11-container-with-most-water%2F</url>
    <content type="text"><![CDATA[Description:Given _n_ non-negative integers _a1_, _a2_, …, _an_, where each represents a point at coordinate (_i_, _ai_). _n_ vertical lines are drawn such that the two endpoints of line _i_ is at (_i_, _ai_) and (_i_, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and _n_ is at least 2. 解法：参考：http://blog.csdn.net/a83610312/article/details/8548519 贪心法，证明过程如下： 1.首先假设我们找到能取最大容积的纵线为 i , j (假定i&lt;j)，那么得到的最大容积 C = min( ai , aj ) * ( j- i) ； 2.下面我们看这么些性质： ①: 在 j 的右端没有一条线会比它高！ 假设存在 k |( j aj) ，那么 由 ak&gt; aj，所以 min( ai,aj, ak) =min(ai,aj) ，所以由i, k构成的容器的容积C’ = min(ai,aj ) * ( k-i) &gt; C，与C是最值矛盾，所以得证j的后边不会有比它还高的线； ②:同理，在i的左边也不会有比它高的线； 这说明什么呢？如果我们目前得到的候选： 设为 x, y两条线（x&lt; y)，那么能够得到比它更大容积的新的两条边必然在 [x,y]区间内并且 ax’ &gt; =ax , ay’&gt;= ay; ③：所以我们从两头向中间靠拢，同时更新候选值；在收缩区间的时候优先从 x, y中较小的边开始收缩； 直观的解释是：容积即面积，它受长和高的影响，当长度减小时候，高必须增长才有可能提升面积，所以我们从长度最长时开始递减，然后寻找更高的线来更新候补； 代码如下：12345678910111213141516171819202122class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ i = 0; j = len(height) - 1; res = 0; while(i&lt;j): res = max(res,min(height[i],height[j])*(j - i)); if(height[i]&lt;height[j]): k = i; while(k&lt;j and height[k]&lt;=height[i]): k+=1; i = k; else: k = j; while(k&gt;i and height[k]&lt;=height[j]): k-=1; j = k; return res;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(10) Regular Expression Matching]]></title>
    <url>%2F2018%2F03%2F04%2Fleetcode10-regular-expression-matching%2F</url>
    <content type="text"><![CDATA[Description:Implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;. ‘.’ Matches any single character. ‘‘ Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char \s, const char *p)Some examples: isMatch(“aa”,”a”) → false isMatch(“aa”,”aa”) → true isMatch(“aaa”,”aa”) → false isMatch(“aa”, “a“) → true isMatch(“aa”, “.“) → true isMatch(“ab”, “.“) → true isMatch(“aab”, “c\a*b”) → true 解法：此题的关键在于对‘’号的处理，因为不知道到底会匹配多少个字符，但是有一点，‘’不会单独出现，它一定是和前面一个字母或”.”配成一对。看成一对”X*”，它的性质就是：要不匹配0个，要不匹配连续的“X”，关键在于匹配正确个数的字符。 考虑一个特殊的问题：情况1：“aaaaaaaaaaaaaaaa”“aaa” 情况2：“aaaaaaaaaaaaaaaa”“aab” 最长匹配？显然不合适，这样后面的a就无法匹配上了 匹配到和后面长度一样的位置，比如情况1，就是留3个a不匹配，让后面3个字母尝试去匹配？这样看似合适，但是遇到情况2就不行了。 回溯，每种匹配个数的情况，看哪种情况能成功，如果其中出现了问题，马上回溯，换下一种情况 因此，采用递归的方法解决该问题，用p去与s做匹配（即代码中判定以p为准），实际上也是深度优先搜索，对该问题的分解如下： 递归出口： 若p为空，对s而言： 若s也为空，返回true，反之返回false 若p的长度为1，对s而言： 若此时若s长度也为1，且s与p相同或是p为’.’，则返回true，反之返回false 递归体： 考虑该问题还未进行最小划分的情况，即此时p的长度大于1，对两串从左至右进行匹配。 情况1：若此时 p[1] !=’*’ 1.1 如果s的长度为0，匹配失败，则返回false 1.2如果s[0] == p[0] 或 p[0] == ‘*’，匹配暂时成功，递归看看s与p的头指针向右移一位之后的串匹配是否成功 1.3否则匹配失败，返回false 情况2：此时的 p[1] == ‘*’ 2.1当s的长度不为0且s[0] == p[0] 或 p[0] == ‘’时，暂时地匹配成功了，将s的头指针右移一位，进入下一次循环判断，值得注意的是，当匹配至p中’’后的串与此时遗留的s串相匹配时，不需要进行进一步的匹配了，两串完全匹配成功，返回true。 2.2剩下的情况即，s[0] != p[0] 且 p[0] ！= ‘’，则考虑此时X组合匹配0次，递归看看p中’*’后的串与此时遗留的s串是否匹配 我的代码：1234567891011121314151617181920212223242526272829class Solution: def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if(len(p) == 0): if(len(s) == 0): return True; return False; if(len(p) == 1): if(len(s) == 1): if(p[0] == '.' or s[0] == p[0]): return True; return False; if(p[1] != '*'): if(len(s) == 0): return False; if(p[0] == s[0] or p[0] == '.'): return Solution.isMatch(Solution,s[1:],p[1:]); return False; #p[1] == '*'的情况 while(len(s)!=0 and (s[0] == p[0] or p[0] == '.')): if(Solution.isMatch(Solution,s,p[2:])): return True; l = list(s[1:]); s = "".join(l); return Solution.isMatch(Solution,s,p[2:]);]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(9) Palindrome Number]]></title>
    <url>%2F2018%2F03%2F02%2Fleetcode9-palindrome-number%2F</url>
    <content type="text"><![CDATA[Description:Determine whether an integer is a palindrome. Do this without extra space. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 解法主要掌握从一个数中取一部分的方法： 求除数的方法12while(x/div&gt;=10): div*=10; 取最右边的数1x = x % 10 取最左边的数1x = x/div; 取左部分1x = x /10 取右部分1x = x % div 我的代码1234567891011121314151617181920212223import math;class Solution: def isPalindrome(self, x): """ :type x: int :rtype: bool """ div = 1; if(x&lt;0): return False; while(x/div&gt;=10): div*=10; while(x&gt;0): right = x%10; left = x/div; left = math.floor(left); if(right != left): return False; x = (x%div)/10; x = math.floor(x); div/=100; div = math.floor(div); return True;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(8) String to Integer (atoi)]]></title>
    <url>%2F2018%2F03%2F02%2Fleetcode8-string-to-integer-atoi%2F</url>
    <content type="text"><![CDATA[Description:Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 解法：没啥好说的，输入为空格，+，- 或数字，出现 +，-后直接计数，如果已经非法则返回0. 字符串转数字的公式为：12x = int(str[i]);result = result * 10 + x; 我的代码：12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def myAtoi(self, str): """ :type str: str :rtype: int """ i = 0; flag = 1; if(str == ""): return 0; while(str[i]==" "): i+=1; if(i == len(str)): return 0; result = 0; if(str[i]=="-" and i!=len(str)-1): if(str[i+1]!=" " and str[i+1] !="+" and str[i+1]!="-"): flag = -1; i+=1; else: return 0; if(str[i]=="+"and i!=len(str)-1): if(str[i+1]!=" " and str[i+1] !="+" and str[i+1]!="-"): flag = 1; i+=1; else: return 0; while(ord(str[i])&gt;=48 and ord(str[i])&lt;=57): x = int(str[i]); result = result * 10 + x; i+=1; if(i == len(str)): break; if(flag == -1): result = -result; if(result&lt;-2147483648): return -2147483648; if(result &gt;2147483647): return 2147483647 return result;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(6) ZigZag Conversion]]></title>
    <url>%2F2018%2F02%2F28%2Fleetcode6-zigzag-conversion%2F</url>
    <content type="text"><![CDATA[Description:The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows); convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. 解法：python 创建二维列表，将需要的参数写入 cols 和 rows 即可1list_2d = [[0 for col in range(cols)] for row in range(rows)] 此外，此题中还需要注意的是python中list与str的互相转换：str-&gt;list:12str = &apos;abcde&apos;list = list(str) list-&gt;str:12list = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]str_convert = &apos;&apos;.join(list) 我对此题的解法为模拟，设计一个flag变量，为-1时方向向下，为+1时方向向上，将string填入二维的list中：123456789101112131415161718192021222324252627282930class Solution: def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ if(numRows == 1 or numRows &gt;= len(s)): return s; L = [[] for row in range(numRows)]; r = 0;i = 0;flag = -1; while(i&lt; len(s)): if(flag == -1): L[r].append(s[i]); r+=1; if(r == numRows): flag = 1; r = numRows - 2; else: L[r].append(s[i]); r-=1; if(r == -1): flag = -1; r = 1; i+=1; result = "" for i in range(numRows): r = ''.join(L[i]); result += r; return result]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(5) Longest Palindromic Substring]]></title>
    <url>%2F2018%2F01%2F30%2Fleetcode5-longest-palindromic-substring%2F</url>
    <content type="text"><![CDATA[Description:Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example:Input: “babad” Output: “bab” Note: “aba” is also a valid answer. Example:Input: “cbbd” Output: “bb” 解法：Manacher’s Algorithm 马拉车算法 这个算法是求解回文字符串的常见方法，时间复杂度是O(n)，他的本质是在常规的回文字符串的查找算法上进行优化，利用回文字符串的对称性减少计算时间。下面是算法的主要步骤： 首先，Manacher算法提供了一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑，具体做法是，在原字符串的每个相邻两个字符中间插入一个分隔符，同时在首尾也要添加一个分隔符，分隔符的要求是不在原串中出现，一般情况下可以用#号。下面举一个例子： Manacher算法用一个辅助数组Len[i]表示以字符T[i]为中心的最长回文字串的最右字符到T[i]的长度，比如以T[i]为中心的最长回文字串是T[l,r],那么Len[i]=r-i+1。 对于上面的例子，可以得出Len[i]数组为: 这个数组有一个重要的性质：Len[i]-1就是该回文子串在原字符串S中的长度，证明如下： 首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以T[i]为中心的最长回文字串，其长度就为2*Len[i]-1,经过观察可知，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是有Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]-1。 故计算Len数组即可求得原字符串中最长回文子串，Len计算过程如下： 从右往左计算Len数组。Manacher算法的优化之处在于利用之前已经求得的Len数组的部分值减少计算新值的循环次数。即： 当计算Len[i]时，Lenj已经计算完毕。设P为之前计算的Len数组中的最大值所对应的右端点（即当前已找到的最长回文子串的右端点），并且设取得这个最大值的位置为po（即Len取得当前已知的最大值的数组序号，即中心点的位置），分两种情况： 第一种情况：i&lt;=P 考虑回文字符串的对称性，找到i相对于po的对称位置，设为j，又分为两种子情况： 1.1 如果Len[j]&lt;P-i，如下图： 那么说明以j为中心的回文串一定在以po为中心的回文串的内部，且j和i关于位置po对称，由回文串的定义可知，一个回文串反过来还是一个回文串，所以以i为中心的回文串的长度至少和以j为中心的回文串一样，即Len[i]&gt;=Len[j]。由对称性可知Len[i]=Len[j]。 1.2 如果Len[j]&gt;=P-i，如下图： 由对称性，说明以i为中心的回文串可能会延伸到P之外，而大于P的部分我们还没有进行匹配，所以要从P+1位置开始一个一个进行匹配，直到发生失配，从而更新P和对应的po以及Len[i]。 第二种情况：i&gt;P 如果i比P还要大，说明对于中点为i的回文串还一点都没有匹配，这个时候，就只能老老实实地使用常规算法进行一个一个匹配了，匹配完成后要更新P的位置和对应的po以及Len[i]。 总而言之： 计算Len数组时考虑对称性减少匹配次数，新增两个辅助变量mx和id，其中id为当前已知的最大回文子串中心的位置（Len(j)取最大值时的j值），mx是Len取最大值时回文串能延伸到的最右端的位置，这个算法的最核心的一行如下： 1p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; 我的代码：12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def longestPalindrome(self, s): """ :type s: str :rtype: str """ t = "#"; i = 0 # 预处理 while(i&lt;len(s)): t+=s[i]; t+="#"; i+=1; # 计算 rmax = 0; center = 0; i = 0; rescenter = 0; reslen = 0;p = [0]*len(t); while(i&lt;len(t)): if(rmax&gt;i): x = rmax-i; y = p[int(2*center-i)]; if(x&lt;y): p[i] = x; else: p[i] = y; else: p[i] = 1; # 向两边查找对称字符串（常规方法） if(i-p[i]&gt;=0 and i+p[i]&lt;len(t)): while(t[i+p[i]] == t[i-p[i]]): p[i]+=1; if(i-p[i]&lt;0 or i+p[i]&gt;=len(t)): break; if(i+p[i]-1&gt;rmax): rmax = i + p[i] - 1; center = i; if(p[i]&gt;reslen): reslen = p[i]; rescenter = i; i+=1; r = t[rescenter-reslen+1:rescenter+reslen-1].replace('#',''); return r;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(4) Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F01%2F28%2Fleetcode4-median-of-two-sorted-arrays%2F</url>
    <content type="text"><![CDATA[Description：There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: nums1 = [1, 3]nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 解法：我采用的解法是用2个变量分别指向两个数组，每次取较小的一个，然后将其指针后移动，直至找到中位数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution: def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ if(len(nums1) == 0): if(len(nums2)%2 != 0): return nums2[int(len(nums2)/2)]; else: result1 = nums2[int(len(nums2)/2-1)]; result = nums2[int(len(nums2)/2)]; result = (result+result1)/2; return result; if (len(nums2) == 0): if (len(nums1) % 2 != 0): return nums1[int(len(nums1) / 2)]; else: result1 = nums1[int(len(nums1) / 2 - 1)]; result = nums1[int(len(nums1) / 2)]; result = (result + result1) / 2; return result; t = len(nums1) + len(nums2); if (t % 2 != 0): pos = t / 2; flag = 0; else: pos1 = t / 2 - 1; pos2 = t / 2; flag = 1; i = 0; j = 0; k = 0; result = -1; while (i &lt; len(nums1) or j &lt; len(nums2)): if(i == len(nums1)): result = nums2[j]; j+=1;k+=1; elif(j == len(nums2)): result = nums1[i]; i += 1; k += 1; elif (nums1[i] &lt; nums2[j]): result = nums1[i]; i += 1; k += 1; elif (nums1[i] &gt; nums2[j]): result = nums2[j]; j += 1; k += 1; else: result = nums1[i]; i += 1; k += 2; j += 1; if (flag == 0 and k &gt; pos): return result; if (flag == 1 and k &gt; pos1): if(i == len(nums1) and j == len(nums2)): return result; if(i == len(nums1)): result1 = nums2[j]; result = (result + result1) / 2.0; return result; if(j == len(nums2)): result1 = nums1[i]; result = (result + result1) / 2.0; return result; if (nums1[i] &lt; nums2[j]): result1 = nums1[i]; else: result1 = nums2[j]; result = (result + result1) / 2.0; return result; 还可以采用分治法解决该问题 参考链接：http://blog.csdn.net/hk2291976/article/details/51107778]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode(3) Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F01%2F23%2Fleetcode3-longest-substring-without-repeating-characters%2F</url>
    <content type="text"><![CDATA[Description:Given a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 解法：最开始采用暴力法，毫无疑问超时了：123456789101112131415161718192021222324class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ count = []; for i in range(len(s)): r = s[i]; cnt = 1; j = i + 1; while (j &lt; len(s)): if (s[j] not in r): r += s[j]; cnt+=1; j+=1; else: break; count.append(cnt); if(len(count) == 0): return 0; maxcnt = max(count); index = count.index(maxcnt); return maxcnt; 采用滑动窗格法： 用一个数据结构记录序列中存在的字符，考虑i与j两个指针之间的子串长度，若[i,j)为序列且s[j]不存在于此序列中，则s[j]加入字符集，j指针右移；否则i指针右移，且将s[i]移出字符集（此处存在优化，即i不必一次次右移，直接移至序列中与s[j]相同的字母的下一个即可），给出未优化的滑动窗格法代码： 12345678910111213141516class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ i = 0;j = 0; ans = 0;list = []; while(i&lt;len(s) and j &lt;len(s)): if(s[j] not in list): list.append(s[j]); ans = max(ans,j - i + 1); j+=1; else: list.remove(s[i]); i+=1; return ans;]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之冒泡排序]]></title>
    <url>%2F2017%2F06%2F05%2Fe6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-e4-b9-8b-e5-86-92-e6-b3-a1-e6-8e-92-e5-ba-8f%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序算法的流程如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码实现： 1234567891011//外层循环表示待排序的数组长度//内层循环表示每一轮往上浮动的元素for (i = length - 1; i &gt; 0 ; i--) &#123; for (j = 0; j &lt; i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125;]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监督学习之朴素贝叶斯分类]]></title>
    <url>%2F2017%2F05%2F24%2Fe7-9b-91-e7-9d-a3-e5-ad-a6-e4-b9-a0-e4-b9-8b-e6-9c-b4-e7-b4-a0-e8-b4-9d-e5-8f-b6-e6-96-af-e5-88-86-e7-b1-bb%2F</url>
    <content type="text"><![CDATA[朴素贝叶斯分类参考：http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html 基本概念： P(A|B) 表示事件B已经发生的前提下，事件A发生的概率，叫做事件B发生下事件A的条件概率。其基本求解公式为：P(A|B) = P(AB)/P(B)。贝叶斯定理： 原理与流程： 流程如下： 那么现在的关键就是如何计算第3步中的各个条件概率。我们可以这么做： 图示： 实例： 这个问题是这样的，对于SNS社区来说，不真实账号（使用虚假身份或用户的小号）是一个普遍存在的问题，作为SNS社区的运营商，希望可以检测出这些不真实账号，从而在一些运营分析报告中避免这些账号的干扰，亦可以加强对SNS社区的了解与监管。 如果通过纯人工检测，需要耗费大量的人力，效率也十分低下，如能引入自动检测机制，必将大大提升工作效率。这个问题说白了，就是要将社区中所有账号在真实账号和不真实账号两个类别上进行分类，下面我们一步一步实现这个过程。 首先设C=0表示真实账号，C=1表示不真实账号。 1、确定特征属性及划分 这一步要找出可以帮助我们区分真实账号与不真实账号的特征属性，在实际应用中，特征属性的数量是很多的，划分也会比较细致，但这里为了简单起见，我们用少量的特征属性以及较粗的划分，并对数据做了修改。 我们选择三个特征属性：a1：日志数量/注册天数，a2：好友数量/注册天数，a3：是否使用真实头像。在SNS社区中这三项都是可以直接从数据库里得到或计算出来的。 下面给出划分：a1：{a&lt;=0.05, 0.05&lt;a&lt;0.2, a&gt;=0.2}，a1：{a&lt;=0.1, 0.1&lt;a&lt;0.8, a&gt;=0.8}，a3：{a=0（不是）,a=1（是）}。 2、获取训练样本 这里使用运维人员曾经人工检测过的1万个账号作为训练样本。 3、计算训练样本中每个类别的频率 4、计算每个类别条件下各个特征属性划分的频率 使用分类器进行鉴别 下面我们使用上面训练得到的分类器鉴别一个账号，这个账号使用非真实头像，日志数量与注册天数的比率为0.1，好友数与注册天数的比率为0.2。 可以看到，虽然这个用户没有使用真实头像，但是通过分类器的鉴别，更倾向于将此账号归入真实账号类别。这个例子也展示了当特征属性充分多时，朴素贝叶斯分类对个别属性的抗干扰性。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之插入排序]]></title>
    <url>%2F2017%2F05%2F24%2Fe6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-e4-b9-8b-e6-8f-92-e5-85-a5-e6-8e-92-e5-ba-8f%2F</url>
    <content type="text"><![CDATA[插入排序基本思想1.从第一个元素开始，该元素可以认为已经被排序2.取出下一个元素，在已经排序的元素序列中从后向前扫描3.如果该元素（已排序）大于新元素，将该元素移到下一位置4.重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置5.将新元素插入到该位置后6.重复步骤 2~5 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;void Insertsort(int a[],int n) &#123; for (int i = 0; i &lt; n; i++) //总共需要查找n个元素的位置 &#123; int j; for (j = i - 1; j &gt;= 0; j--)//对每一个元素，向前查找到小于它的第一个元素 &#123; if (a[j] &lt; a[i]) &#123; break; &#125; &#125; if (j != i - 1) //如果不是它之前的第一个，就将j之后的元素向后移一个，并插入自己 &#123; int tmp = a[i]; int k; for (k = i - 1; k &gt; j; k--) &#123; a[k + 1] = a[k]; &#125; a[k + 1] = tmp; &#125; &#125;&#125;int main(void) &#123; int a[8] = &#123; 2,1,4,5,3,7,8,6 &#125;; cout &lt;&lt; "before:" &lt;&lt; endl; for (int i = 0; i &lt; 8; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ","; &#125; cout &lt;&lt; endl; Insertsort(a, 8); cout &lt;&lt; "after:" &lt;&lt; endl; for (int i = 0; i &lt; 8; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ","; &#125; cout &lt;&lt; endl; system("pause");&#125; 更加简短的代码 12345678910111213public class Solution &#123; void insert_sort(int a[]) &#123; for (int i = 1; i &lt; a.length; i++) &#123; int j = i - 1; int tmp = a[i]; while (j &gt;= 0 &amp;&amp; a[j] &gt; tmp) &#123; a[j + 1] = a[j]; j -= 1; &#125; a[j + 1] = tmp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之快速排序]]></title>
    <url>%2F2017%2F05%2F23%2Fe6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-e4-b9-8b-e5-bf-ab-e9-80-9f-e6-8e-92-e5-ba-8f%2F</url>
    <content type="text"><![CDATA[快速排序时间复杂度：O(NlogN)，最坏为O(N\N)(逆序的情况) 基本思想：1．先从数列中取出一个数作为基准数。 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 3．再对左右区间重复第二步，直到各区间只有一个数 本质上是分治算法 关键步骤：算法的关键在于实现对于数组的左右分割，即实现将比pivot小的置于其左侧，比pivot大的置于其右侧。 具体实现步骤如下： 1.选取数组的最后一项为pivot； 2.令i指向第一个比pivot大的数，即对于input[start:i-1]，都小于pivot，input[i:end-1]都大于pivot;这个过程用循环实现 3.将pivot于i指向的元素互换位置，使得比pivot小的在其左侧，比pivot大的在其右侧。 4.对pivot两边的子序列递归，进行同样的操作，直至操作序列为一个数。 下面给出一个分割的例子 假设用户输入了如下数组： 下标 0 1 2 3 4 5 数据 6 2 7 9 8 3 此时i = 0; j =0,因为input[0]&gt;pivot,故比pivot小的数没有，不需要改变i的指向，结果如下： 下标 0 1 2 3 4 5 数据 6 2 7 9 8 3 此时i = 1; j = 1,因为j指向的元素2比pivot小（这里的input在这句话上面），故需要交换位置，并将i+1,结果如下： 下标 0 1 2 3 4 5 数据 2 6 7 9 8 3 ……… 最终将pivot于i的指向的值交换位置，得到如下结果： 下标 0 1 2 3 4 5 数据 2 3 7 9 8 6 然后，对pivot两边的数据，再分组分别进行上述的过程，直到不能再分组为止。 注意：第一遍快速排序不会直接得到最终结果，只会把比k大和比k小的数分到k的两边。为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，然后再分解数组，直到数组不能再分解为止（只有一个数据），才能得到正确结果。 代码实现：123456789101112131415161718192021222324252627282930313233class Solution &#123; void quicksort(int[] input) &#123; helper(input, 0, input.length - 1); &#125; void helper(int[] input, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int pivot = input[end]; int i = start; //在循环中中，每次都保证如下条件 //对于input[start:i-1],都小于pivot //对于input[i:j],都大于pivot for (int j = start; j &lt; end; j++) &#123; if (input[j] &lt; pivot) &#123; swap(input, i, j); i++; &#125; j //分类完成，将pivot与i指向的元素互换 //因为i指向的是比pivot大的元素，互换不影响分割 swap(input, i, end); helper(input, start, i - 1); helper(input, i + 1, end); &#125; void swap(int[] x, int a, int b) &#123; int tmp = x[a]; x[a] = x[b]; x[b] = tmp; &#125;&#125;]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列模式挖掘之PrefixSpan算法]]></title>
    <url>%2F2017%2F05%2F23%2Fe5-ba-8f-e5-88-97-e6-a8-a1-e5-bc-8f-e6-8c-96-e6-8e-98-e4-b9-8bprefixspan-e7-ae-97-e6-b3-95%2F</url>
    <content type="text"><![CDATA[PrefixSpan算法原理总结参考：http://www.cnblogs.com/pinard/p/6323182.html 基本概念项集数据和序列数据： 左边的数据集就是项集数据，每个项集数据由若干项组成，这些项没有时间上的先后关系。而右边的序列数据则不一样，它是由若干数据项集组成的序列。比如第一个序列&lt;a(abc)(ac)d(cf)&gt;,它由a,abc,ac,d,cf共5个项集数据组成，并且这些项有时间上的先后关系。对于多于一个项的项集我们要加上括号，以便和其他的项集分开。同时由于项集内部是不区分先后顺序的，为了方便数据处理，我们一般将序列数据内所有的项集内部按字母顺序排序。 子序列与频繁序列：了解了序列数据的概念，我们再来看看上面是子序列。子序列和我们数学上的子集的概念很类似，也就是说，如果某个序列A所有的项集在序列B中的项集都可以找到，则A就是B的子序列。当然，如果用严格的数学描述，子序列是这样的： 对于序列A={a1,a2,…ana1,a2,…an}和序列B={b1,b2,…bmb1,b2,…bm},n≤mn≤m，如果存在数字序列1≤j1≤j2≤…≤jn≤m1≤j1≤j2≤…≤jn≤m, 满足a1⊆bj1,a2⊆bj2…an⊆bjn，则称A是B的子序列。当然反过来说， B就是A的超序列。 而频繁序列则和我们的频繁项集很类似，也就是频繁出现的子序列。比如对于下图，支持度阈值定义为50%，也就是需要出现两次的子序列才是频繁序列。而子序列&lt;(ab)c&gt;是频繁序列，因为它是图中的第一条数据和第三条序列数据的子序列，对应的位置用蓝色标示: 前缀与前缀投影：在PrefixSpan算法中的前缀prefix通俗意义讲就是序列数据前面部分的子序列。比如对于序列数据B=&lt;a(abc)(ac)d(cf)&gt;，A=&lt;a(abc)a&gt;,则A是B的前缀。当然B的前缀不止一个，比如, , &lt;a(ab)&gt; 也都是B的前缀。 我们再来看前缀投影，其实前缀投影这儿就是我们的后缀，有前缀就有后缀嘛。前缀加上后缀就可以构成一个我们的序列。下面给出前缀和后缀的例子。对于某一个前缀，序列里前缀后面剩下的子序列即为我们的后缀。如果前缀最后的项是项集的一部分，则用一个“_”来占位表示。在PrefixSpan算法中，相同前缀对应的所有后缀的结合我们称为前缀对应的投影数据库。 算法流程PrefixSpan算法类似Aprior，它从长度为1的前缀开始挖掘序列模式，搜索对应的投影数据库得到长度为1的前缀对应的频繁序列，然后递归的挖掘长度为2的前缀所对应的频繁序列，以此类推，一直递归到不能挖掘到更长的前缀挖掘为止。流程如下： 1）找出所有长度为1的前缀和对应的投影数据库 2）对长度为1的前缀进行计数，将支持度低于阈值αα的前缀对应的项从数据集S删除，同时得到所有的频繁1项序列，i=1. 3）对于每个长度为i满足支持度要求的前缀进行递归挖掘： 找出前缀所对应的投影数据库。如果投影数据库为空，则递归返回。 统计对应投影数据库中各项的支持度计数。如果所有项的支持度计数都低于阈值αα，则递归返回。 将满足支持度计数的各个单项和当前的前缀进行合并，得到若干新的前缀。 令i=i+1，前缀为合并单项后的各个前缀，分别递归执行第3步。 实例：设支持度阈值为50%。下图长度为1的前缀包括, , , , , ,我们需要对这6个前缀分别递归搜索找各个前缀对应的频繁序列。如下图所示，每个前缀对应的后缀也标出来了。由于g只在序列4出现，支持度计数只有1，因此无法继续挖掘。我们的长度为1的频繁序列为, , , , ，。去除所有序列中的g，即第4条记录变成&lt;e(af)cbc&gt; 现在我们开始挖掘频繁序列,分别从长度为1的前缀开始。这里我们以d为例子来递归挖掘，其他的节点递归挖掘方法和Ｄ一样。方法如下图，首先我们对ｄ的后缀进行计数，得到{a:1, b:2, c:3, d:0, e:1, f:1，_f:1}。注意f和_f是不一样的，因为前者是在和前缀d不同的项集，而后者是和前缀d同项集。由于此时a,d,e,f,_f都达不到支持度阈值，因此我们递归得到的前缀为d的2项频繁序列为和。接着我们分别递归db和dc为前缀所对应的投影序列。首先看db前缀，此时对应的投影后缀只有&lt;_c(ae)&gt;,此时_c,a,e支持度均达不到阈值，因此无法找到以db为前缀的频繁序列。现在我们来递归另外一个前缀dc。以dc为前缀的投影序列为&lt;_f&gt;, &lt;(bc)(ae)&gt;, ，此时我们进行支持度计数，结果为{b:2, a:1, c:1, e:1, _f:1}，只有b满足支持度阈值，因此我们得到前缀为dc的三项频繁序列为。我们继续递归以为前缀的频繁序列。由于前缀对应的投影序列&lt;(_c)ae&gt;支持度全部不达标，因此不能产生4项频繁序列。至此以d为前缀的频繁序列挖掘结束，产生的频繁序列为。同样的方法可以得到其他以, , , , 为前缀的频繁序列。]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关联规则之Apriori算法]]></title>
    <url>%2F2017%2F05%2F22%2Fe5-85-b3-e8-81-94-e8-a7-84-e5-88-99-e4-b9-8bapriori-e7-ae-97-e6-b3-95%2F</url>
    <content type="text"><![CDATA[关联规则之Apriori&amp;Ms-Apriori算法Apriori参考：http://blog.csdn.net/u011067360/article/details/24810415 基本概念 1、支持度 关联规则A-&gt;B的支持度support=P(AB)，指的是事件A和事件B同时发生的概率。 2、置信度 置信度confidence=P(B|A)=P(AB)/P(A),指的是发生事件A的基础上发生事件B的概率。比如说在规则Computer =&gt; antivirus_software , 其中 support=2%, confidence=60%中，就表示的意思是所有的商品交易中有2%的顾客同时买了电脑和杀毒软件，并且购买电脑的顾客中有60%也购买了杀毒软件。 3、k项集 如果事件A中包含k个元素，那么称这个事件A为k项集，并且事件A满足最小支持度阈值的事件称为频繁k项集。 4、由频繁项集产生强关联规则 1）K维数据项集LK是频繁项集的必要条件是它所有K-1维子项集也为频繁项集，记为LK-1 2）如果K维数据项集LK的任意一个K-1维子集Lk-1，不是频繁项集，则K维数据项集LK本身也不是最大数据项集 3）同时满足最小支持度阀值和最小置信度阀值的规则称为强规则。 基本思想 第一步通过迭代，检索出事务数据库中的所有频繁项集，即支持度不低于用户设定的阈值的项集； 第二步利用频繁项集构造出满足用户最小信任度的规则。 实例： Ms-Apriori参考：http://blog.csdn.net/androidlushangderen/article/details/45082337 Ms-Apriori算法采用另外一种办法，既然统一的支持度值不能兼顾所有的情况，那我可以设置多个支持度值啊，每个种类项都有一个最小支持度阈值，然后一个频繁项的最小支持度阈值取其中项集元素中的最小支持度值作为该项集的最小支持度值。这样的话，如果一个频繁项中出现了稀有项集，则这个项集的最小支持度值就会被拉低，如果又有某个项都是出现频率很高的项构成的话，则支持度阈值又会被拉高。当然，如果出现了一个比较难变态的情况就是，频繁项中同时出现了稀有项和普通项，我们可以通过设置SDC支持度差别限制来限制这种情况的发生，使之挖掘的频繁项更加的合理。通过这里的描述，你就可以发现，当mis最小支持度阈值数组的个数只有1个的时候，ms-apriori算法就退化成了Apriori算法了。]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式总结]]></title>
    <url>%2F2017%2F05%2F20%2Fhello-world-1%2F</url>
    <content type="text"><![CDATA[组合模式 需求：将层次结构尽可能简单地表示 抽象构件（Component）：定义参加组合的对象的共有方法和属性，可以定义一些默认的行为或属性，比如getInfo 叶子构件（Leaf）：叶子对象，其下没有分支。 树枝构件（Composit）：树枝对象，它的作用是组合树枝节点和叶子节点。 相当于写一个接口component，代表一课树种的任意节点，实现分两种，一种叶子节点，一种分支节点。 代码：http://chenjumin.iteye.com/blog/580582 策略模式 需求：解决同一类问题的算法封装起来，可以更换解决问题的算法 Context: 环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 相当于Context是基于某一问题的场景，包括一个实现函数algorithm，但它的算法不确定，它有一个函数指针（strategy类型）指定采用哪一种策略中的算法，strategy类是父类，它的子类为具体实现方法 代码：http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html ppt中代码也可 桥模式 需求：抽象部与实现部分离实现二者的独立变化 Abstraction：抽象类 RefinedAbstraction：扩充抽象类 Implementor：实现类接口 ConcreteImplementor：具体实现类 长的和策略模式差不多，不同在于策略模式的context不可变，而桥模式的abstraction可以更改（operation函数功能可变，只要实现这个operation接口即可）因此可以实现不同operation()和不同operationImp()的组合（operation内部通常调用了operationImp） 而策略模式没有包含关系： ppt中排序的实现： 上两句为桥模式，下两句为策略模式 代码：http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html Ppt中的图更好讲述了它与策略模式的区别于联系： 适配器模式 需求：解决接口不兼容问题，把无法直接调用的系统库进行包装实现接口与当前统一 Target：目标抽象类 Adapter：适配器类 Adaptee：适配者类 Client：客户类 Adapter的实现：对象适配器使用关联方法实现，二类适配器使用多继承方法实现 代码：http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html 迭代器模式 需求：不了解表的结构的情况下实现表的遍历访问（相当于Iterator的实现） 迭代器角色（Iterator）：迭代器角色负责定义访问和遍历元素的接口。 具体迭代器角色（Concrete Iterator）：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。 容器角色（Container）：容器角色负责提供创建具体迭代器角色的接口。 具体容器角色（Concrete Container）：具体容器角色实现创建具体迭代器角色的接口——这个具体迭代器角色于该容器的结构相关。 左边为表，右边为迭代器 抽象工厂模式 需求：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 代码：http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html 观察者模式 需求：定义一个对象和多个对象直接的1vsn的依赖关系，使其依赖者依其状态的变化做出更新 Subject: 目标 ConcreteSubject: 具体目标 Observer: 观察者 ConcreteObserver: 具体观察者 在被观察者中有一个状态量，setstate()对外提供修改subject的接口，而getstate()对观察者提供获得subject状态的接口，在subject调用notify函数时，subject遍历列表中每一个观察者,使他们调用update函数（update函数参数为subject自身指针，即告诉观察者哪一个subject被更新了），update函数调用getstate()函数获取当前最新状态 代码：（类里面的代码很重要） http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html 代理模式 需求：在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。还可提供额外服务 Subject: 抽象主题角色 Proxy: 代理主题角色 RealSubject: 真实主题角色 与适配器模式的区别在于适配器中两类只有适配器继承于目标Target，而此模式真实物体和代理均继承于Subject父类，相同点在于代理和适配器中均有被代物的指针 代码：http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/proxy.html 简单工厂模式 需求：不需要知道调用类的名字，只需要知道其对应的参数，可以根据参数的不同返回不同类的实例 Factory：工厂角色 工厂角色负责实现创建所有实例的内部逻辑 Product：抽象产品角色 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreteProduct：具体产品角色 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 代码： http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html 工厂方法模式 需求：每一个工厂提供一个产品的创建方法 Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂 代码： http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html 单例模式 需求：希望对象只创建一个实例，并且提供一个全局的访问点。 Singleton：单例 代码：http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html 难点在于如何保证只存在一个实例： 解决方案： 简单判断： 保证线程同步： 但大部分情况直接返回，使用synchronized开销太大，于是使用双重判断： 利用一个类在一个ClassLoader中只会被初始化一次，这点是JVM本身保证的， 那就把初始化实例的事情扔给JVM好了： 避免恶汉式： 十二、访问者模式 需求：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。 访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。 抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。 元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。 结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色 代码： http://blog.csdn.net/zhengzhb/article/details/7489639 该模式中accept函数会调用visit方法（定义于visitor中，传入的参数是Element的指针），visit方法会调用Element中的dosomething函数。这里的操作不通过直接调用dosomething函数实现而用 一个visit函数将其封装，是为了扩展dosomehing的行为，即在visit函数中出了调用dosomething以外，还可以做其他的操作 十三、中介者模式 需求：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 Mediator: 抽象中介者 ConcreteMediator: 具体中介者 Colleague: 抽象同事类 ConcreteColleague: 具体同事类 代码： http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/mediator.html 这个模式主要是在每一个同事里有一个中间人的指针，客户端（main函数）先创建一个中间人，然后调用register函数注册中间人所处理的同事（编号，指针）到一个map，register函数然后调用setMediator函数设置注册同事的中间人指针指向自己。之后，每次同事之间的通信通过sendmessage和receivemessage实现。Sendmessage调用调停人的操作函数，操作函数将调用接受者的receivemessage函数，这样就实现了两者之间的通信 十四、装饰模式 需求: 动态地给一个对象增加一些额外的职责 Component: 抽象构件 ConcreteComponent: 具体构件 Decorator: 抽象装饰类 ConcreteDecorator: 具体装饰类 代码：http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html 开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭 设计模式6大原则：http://www.uml.org.cn/sjms/201211023.asp#6]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程学习</tag>
      </tags>
  </entry>
</search>
